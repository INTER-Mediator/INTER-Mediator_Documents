<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" class="hltr"><head><title>データベースの更新を行うページ</title><link href="00_default.css" rel="stylesheet" media="all"/></head><body xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:msyk="http://msyk.net/Editorial" xmlns:aid5="http://ns.adobe.com/AdobeInDesign/5.0/" xmlns:aid="http://ns.adobe.com/AdobeInDesign/4.0/"><div id="main"><h1><span id="H1-ANC-1"><span style="display:none">→</span></span><span class="chapternumber">Chapter 3</span><br/>データベースの更新を行うページ</h1><p class="version-notation">この章は、INTER-Mediator Ver.11をもとに記載しました。</p><p class="chapter-lead">前の章ではデータベースの内容をページに表示する方法を説明しました。続いて、ページ上で入力したり、あるいは新たなレコードを作成する方法について説明をします。バインドの仕組みを利用することで、手続き的なプログラムを記述しなくても、ページ上のデータを修正した結果がデータベースに反映されます。</p><!-- ============ SECTION START ============ --><h2><span id="H2-ANC-1"><span style="display:none">→</span></span><span class="sectionnumber">3-1</span>更新可能なテキストフィールド</h2><p class="section-lead">Webページ上にテキストフィールドを配置すると、通常はそのままで更新可能な状態になります。もちろん、データベースのアクセス権等の動作上の状況を満たしている必要がありますが、INTER-Mediaotrはテキストフィールド上のデータを修正したときに、そのデータをデータベースに書き戻すことができるようになっています。</p><h3><span id="H3-ANC-1"><span style="display:none">→</span></span><span xmlns="" id="ix-1"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>更新が可能なタグ要素</h3><p>　INTER-Mediatorで作成したWebページでは、<span xmlns="" id="ix-2"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>INPUT、<span xmlns="" id="ix-3"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>TEXTAREA、<span xmlns="" id="ix-4"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>SELECTの各タグで記述されたリンクノード（data-im属性があるタグ要素）については、更新すなわちそこに見えているデータを変更することによってデータベースへ変更結果を反映させることが可能です。それぞれのタグ要素は、INTER-Mediatorによって、自動的にid属性が設定されます。元からid属性がある場合にはそれを利用しますが、重複の可能性があれば書き換えるといった動作になります。そして、自動設定されたid属性をもとにして、それぞれの要素が、どのコンテキストの、どのレコードの、どのフィールドから得られたものなのかを内部で記録します。</p><p>　タグ要素に表示された値が変更されたときに、逆にそれらの情報を利用して、データベースを更新します。そのため、元のテーブルのどのレコードなのかを特定するために、テーブルのキーフィールドの指定が必要です。つまり、定義ファイルのコンテキストの中で、keyに対応した値が正しく指定されていなければなりません。INTER-Mediatorではクライアントサイドで、例えば<span xmlns="" id="ix-5"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>keyの値が「id」だとしたら、「id=23」のような形式で内部的ではレコードを特定する情報を記録します。ここでの「23」はidフィールドの値の例です。つまり、検索条件式のような記録をするということです。</p><p>　定義ファイルのコンテキストでは、<span xmlns="" id="ix-6"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>tableキーによる値が、更新時のエンティティとなります。tableキーを指定しないと、<span xmlns="" id="ix-7"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>nameキーが更新するエンティティになります。テーブルに対して、読出しと書込みをそのまま行うなら、nameキーのみを指定することでも読出しと更新はできます。しかしながら、ビューに対しては書込みができない場合もあります。そのため、読み込み時と書込み時で異なるエンティティを指定できるようにしました。また、同一のテーブルでも用途によって異なるnameキーの値を付けるという考え方もあるので、読出しはview、書込みはtableキーで指定したエンティティに対して処理を行うというルールで構築します。</p><h3><span id="H3-ANC-2"><span style="display:none">→</span></span>テキストフィールドやテキストエリアの更新の動作</h3><p>　<span xmlns="" id="ix-8"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>valueChangeイベントを利用して更新処理が行われます。例えばチェックボックスならクリックしたときに更新が行われます。一方、テキストフィールドやテキストエリアは、Tabキー等でフォーカスが移動したときに、データベースへの更新が行われます。これらのテキスト表示コンポーネントに関しては、自動的に更新する処理も組み込まれています。最後に入力をしてから、約5秒後に、自動的にデータベースへの更新が行われます。つまり、フォーカスを移動するか5秒程度待つことで、データベースには反映されるという動作になります。これらの動作は、<span xmlns="" id="ix-9"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>「何もしなくても自動的に保存される」という動作を目指したものです。</p><p>　テキストフィールドとテキストエリアに関しては、INTER-Mediator独自の<span xmlns="" id="ix-10"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>アンドゥ機能が実装されています。通常は、Command+ZあるいはCtrl+Z等で、ブラウザが提供するアンドゥが稼働しますが、リンクノードについては、フィールド内にフォーカスがある状態で<span xmlns="" id="ix-11"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Ctrl+Shift+Zを押すことで、そのフィールドの値はページを表示した直後の値に戻ります。フィールドが書き換えられている場合には、データベース側の変更も行います。</p><h3><span id="H3-ANC-3"><span style="display:none">→</span></span><span xmlns="" id="ix-12"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>楽観的<span xmlns="" id="ix-13"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ロックの実装</h3><p>　データベースの更新処理においては、複数のユーザーが同時に参照して書き込むような場合の競合の問題が発生します。通常、データの更新は、読み出した結果を、時間が経過して変更されるという流れになります。2人のユーザーAとBがそれぞれ、同一のテーブルの同一のフィールドを変更しようとした場合、Aの読み込み→Bの読み込み→Bの変更→Aの変更といった順序で処理がなされたとします。すると、Bが変更した結果は、最後のAの変更によって上書きされてしまいます。もちろん、これで問題がないという用途もあるかもしれませんが、一般には「先に保存した方が消えて無くなる」のは問題のひとつです。</p><p>　FileMakerを通常のアプリケーションとして利用した場合、Aが読み込み編集中の処理になった段階で、Bは編集作業に入ることができなくなります。こうした動作を「悲観的ロック」と呼びます。つまり、誰か1人だけがひとつの対象（この場合はフィールド）を編集可能にするという制御をするという手法です。この方法は有効ですが、インターネットを経由した接続の場合、突然の切断の可能性はそこそこ高く、ステートレスなHTTPの場合、切断の検出は一概にはうまく行きません。誰かが編集作業を始めた後、ネットワークが切断してしまったらデータベースはロックされたままになってしまい、以降の共同作業ができなくなってしまうこともあります。そこで、Webアプリケーションでは「楽観的ロック」という手法を実装するのが一般的です。楽観的ロックは、「読み出したデータに変更がなければ更新する」というルールです。</p><p>　AとBが同時に同じレコードを編集しようとしているとします。最初は「data」だったデータを、その後Bによって「changeb」に変更しようとしたとします。このとき、フィールドの値はまだ「data」なので、Bの更新作業は成功します。しかしながら、次にAが更新しようとするときに、データベース側の値を得ると「changeb」に変わっているので、ユーザーA側では元々のデータの「data」と、現在の値の「changeb」を比べて違うことを手掛かりにして、「他のユーザーが変更した」ことが検知できるのです。ここで、INTER-Mediatorは「データが変わっており本当に変更していいのか？」と問い合わせるので、ユーザーAは、そこでのボタン選択で、キャンセルも上書きもできるようにしています。なお、もちろん、この場合に、ユーザーBが、同じ値「data」に変更したとしても、それはユーザーAは検知できませんが、これは変更していないのも同然とみなすこともできます。厳密な意味での<span xmlns="" id="ix-14"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>排他制御ではないとも言えますが、一般的なアプリケーションではなんの排他制御をしないよりも遥かに安全であり、実用的な意味では十分なことが多いと思われます。</p><p>　INTER-Mediatorでは、更新処理の前に、再度データベースへのクエリーを発行して、対象とするレコードのフィールドの値に変更がないかどうかを確認します。この処理は自動的に行われて、他のユーザーが変更している形跡があれば、ダイアログボックスでそのまま上書きするか、更新をキャンセルするかをたずねます。</p><p>　なお、この楽観的ロックを行わないように、確認なく更新をしたい場合には、INTERMediatorクラスの<span xmlns="" id="ix-15"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ignoreOptimisticLockingプロパティを設定して、ページを構築します。例えば、ページ合成を行う前に呼び出されるメソッドをリスト3-1-1のように記述します。INTERMediatorOnPage.doBeforeConstructについては、『8-6　ブラウザーを判断するページ』の最後に解説があります。</p><div class="code"><div class="caption">リスト3-1-1　楽観的ロックを行わない場合</div><pre><code>INTERMediatorOnPage.doBeforeConstruct = function () {
    INTERMediator.ignoreOptimisticLocking = true;
}</code></pre></div><h3><span id="H3-ANC-4"><span style="display:none">→</span></span><span class="exsign">演習</span>Webページのテキストフィールドで更新する</h3><p>　INTER-Mediator-ServerのVMを利用して、データの書き戻しを伴うページの作成を行います。新たなページを作成して、更新の動作を検証します。</p><h4>テキストフィールドとテキストエリアのあるページ</h4><div class="step"><span class="stepnumber">1</span>ここからの作業は、Webブラウザー上で行います。ブラウザーで、「http://localhost:9080」に接続します。「トライアル用のページファイルと定義ファイル」というタイトルの部分を特定します。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-050.png"/></div><div class="step"><span class="stepnumber">2</span>「def02.phpを編集する」をクリックし、定義ファイルエディターでdef02.phpファイルを編集します。（もし、他の用途で2番目を利用しているのなら、例えば、def11.phpを利用するなど、別の番号のセットを使用してください。その場合ソースコードの記述が変わる部分がありますが、可能な限り注記します。）</div><div class="picture"><img class="picture-small" src="figs/ng-shot-051.png"/></div><div class="step"><span class="stepnumber">3</span>Contextsの中のQueryと書かれた部分を特定します。そして、その次の行の右の方にある「削除」をクリックして、Queryの設定がある行を削除します。</div><div class="step"><span class="stepnumber">4</span>「レコードを本当に削除していいですか？」とたずねられるので、OKボタンをクリックします。</div><div class="step"><span class="stepnumber">5</span>同様に、Sortingの次の行にある「削除」ボタンを押し、確認にOKボタンをクリックして、こちらの設定も削除しておきます。</div><div class="step"><span class="stepnumber">6</span>nameを「person」、keyを「id」とします。tableとviewはデータベースに応じて次のように設定します。Contextsのその他のテキストフィールドは空白にします。</div><div class="step-wo-number">[MySQL]の場合<br/>table、viewともに「person」と入力します。personは定義されているテーブルです。</div><div class="step-wo-number">[FileMaker]の場合<br/>table、viewともに「person_layout」と入力します。FileMakerではテーブル名やTO名ではなく、レイアウト名を指定します。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-052.png"/></div><div class="step"><span class="stepnumber">7</span>Database Settingsに設定を行います。</div><div class="step-wo-number">[MySQL]の場合<br/>db-classは「PDO」のままでかまいません。dsnに「mysql:host=db;dbname=test_db;charset=utf8mb4」と入力します。そして、userに「web」、passwordに「password」と入力します。</div><div class="step-wo-number">[FileMaker]の場合<br/>db-classを「FileMaker_DataAPI」に書き換えます。databaseは「TestDB」、userに「web」、passwordに「password」、serverに「gateway.docker.internal」、portに「443」、protocolに「https」、cert-vefifyingに「false」と入力します。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-053.png"/></div><div class="step"><span class="stepnumber">8</span>Debugについては、「false」にすると、デバッグ情報が出なくなります。なお、デバッグ情報をみながら動作を確認したい方は、「2」のままにしてこの後の作業を行ってください。</div><div class="step"><span class="stepnumber">9</span>「http://localhost:9080」で開いたページに戻り「page02.htmlを編集する」をクリックし、ページファイルのpage02.htmlを編集するページファイルエディターが開きます。HTMLでの記述内容を以下のように変更します。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div><div class="code"><pre><code>&lt;!DOCTYPE html&gt;
&lt;!--
/*
 * INTER-Mediator Ver.@@@@2@@@@ Released @@@@1@@@@
 * 
 *   Copyright (c) 2010-2015 INTER-Mediator Directive Committee, All rights reserved.
 * 
 *   This project started at the end of 2009 by Masayuki Nii  msyk@msyk.net.
 *   INTER-Mediator is supplied under MIT License.
 */  --&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type="text/javascript" src="def02.php"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
<strong>&lt;table border="1"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;name&lt;/th&gt;&lt;th&gt;mail&lt;/th&gt;&lt;th&gt;category&lt;/th&gt;&lt;th&gt;ckecking&lt;/th&gt;
      &lt;th&gt;location&lt;/th&gt;&lt;th&gt;memo&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;input type="text" data-im="person@name" /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;input type="text" data-im="person@mail" /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;/td&gt;
      &lt;td&gt;&lt;/td&gt;
      &lt;td&gt;&lt;/td&gt;
      &lt;td&gt;&lt;textarea data-im="person@memo"&gt;&lt;/textarea&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
 &lt;/table&gt;</strong>
&lt;/body&gt;
&lt;/html&gt;</code></pre></div><div class="step"><span class="stepnumber">10</span>「http://localhost:9080」で開いたページに戻り、「page02.htmlを表示する」をクリックします。page02.htmlファイルが別のタブあるいはウインドウで開きます。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）テキストフィールドに見えているデータは、データベースに入力されているデータです。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-054.png"/></div><h4>ページ上から更新できることを確認する</h4><div class="step"><span class="stepnumber">1</span>name列の適当なデータを書き換えます。以下の図は2つ目のテキストフィールドを書き換えました。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-055.png"/></div><div class="step"><span class="stepnumber">2</span>Tabキーを押すなどして、次のフィールドに移動します。このときに、INTER-Mediatorは自動的にデータベースへの書き戻しを行います。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-056.png"/></div><div class="step"><span class="stepnumber">3</span>一度、「page02.htmlを表示する」で開いたページを閉じます。その後、「http://localhost:9080」で開いたページで「page02.htmlを表示する」をクリックし、再度Webページを表示します。すると、書き換えたデータが、テキストフィールドに見えていることを確認できます。つまり、データベース上のデータが更新されています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-057.png"/></div><h4>楽観的ロックの動作を確認する</h4><div class="step"><span class="stepnumber">1</span>状況が分かりやすいように、別のブラウザーを起動します。ここまでの手順では、Safariで作業をしていましたが、Firefoxを起動します。新たに開いたブラウザー側で、同じページを開きます。元のブラウザーのアドレスバーのURLをコピーして、新たに開いたブラウザーのアドレスバーにペーストし、同一のページを開いてください。どうしてもひとつのブラウザーしかない場合は、「page02.htmlを表示する」をもう一度クリックして、同じブラウザー内で、同一のページを2つ開いてください。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-058.png"/></div><div class="step"><span class="stepnumber">2</span>最初のブラウザー（この例ではSafari）で、あるレコードのあるフィールドを変更します。ここでは2レコード目のnameフィールドを変更しました。Tabキーでフィールドを移動して確定しておきます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-059.png"/></div><div class="step"><span class="stepnumber">3</span>後から起動したブラウザーに切り替え、同一のテキストフィールドで異なるデータに変更します。その後に、Tabキーを押して、変更結果を確定します。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-060.png"/></div><div class="step"><span class="stepnumber">4</span>警告が表示されました。このFirefoxは英語モードで稼動しているので、メッセージは英語で出ています。読み出したデータ、自分が変更しようとしているデータ、別のユーザーが変更したデータを示しています。ここで、OKボタンをクリックすると、自分が変更しようとしているデータで上書きされます。Cancelをクリックすると、更新処理がキャンセルされます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-061.png"/></div><div class="step"><span class="stepnumber">5</span>OKやCancelボタンによる動作が期待通りかをいろいろと作業をしてみて、楽観的ロックの仕組みを確認しましょう。2つのページをまず、両方とも更新をした上で、作業を進めると良いでしょう。</div><div class="step-wo-number">FileMaker Serverを使っている場合、FileMaker Proでデータを変更している途中の状態で、Webページ上からデータの編集をしてみましょう。いろいろな条件でどのようになるかを確認しておきましょう。</div><h4>テキストエリアの動作を確認する</h4><div class="step"><span class="stepnumber">1</span>「page02.htmlを表示する」で開いたページのmemo列には、TEXTAREAタグによるテキスト入力が可能になっています。適当なレコードで、文字列を入力します。ここでは、改行も入力してみます。入力後にTabキーを押します。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-069.png"/></div><div class="step"><span class="stepnumber">2</span>ブラウザーのページを更新してみます。すると、入力した文字列がそのままテキストエリアに見えていて、実際にデータベースに入力されたことが分かります。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-070.png"/></div><div class="step"><span class="stepnumber">3</span>データベースに実際に改行コードが入力されていることも確認しましょう。MySQLの場合は、以下の手順で、コマンドを入力して確認してみますが、コマンドラインに慣れていない方は、結果も示しますので、結果をご覧ください。FileMaker Serverの場合は、TestDB.fmp12を開き、「person_layout」で実際のデータを参照すればすぐに分かりますので、FileMaker Pro上で確認をしてください。</div><div class="step"><span class="stepnumber">4</span>macOSの場合は「ターミナル」アプリケーション、Windowsの場合はTeraTermなどのSSHで接続可能なアプリケーションを利用してMySQLが稼働するコンテナに接続します。ユーザー名は「web」、パスワードは「password」です。ターミナルの場合は、次のようにコマンドを入力します。</div><div class="code"><pre><code>mysql -u web -h 127.0.0.1 -P 13306 --password=password test_db</code></pre></div><div class="step"><span class="stepnumber">5</span>ログインできるデータベースへのコマンドを入力することができます。mysql&gt; のプロンプトに続いて、以下のようにコマンドを入力して、リターンキーを押します。</div><div class="code"><pre><code>select name,memo from person;</code></pre></div><div class="picture"><img class="picture-small" src="figs/ng-shot-071.png"/></div><div class="step-wo-number">コマンドプロンプトで例えば以下のコマンドを入力すると、16進数表示でデータを参照できます。これにより、改行は16進コードの2行目の2バイト目にあり、0x0aという通常のコードで記録されていることが分かります。</div><div class="code"><pre><code>$ mysql -u web -p -r -h 127.0.0.1 -P 13306 --password=password -D test_db -e 'select memo from person where id=1'|xxd
mysql: [Warning] Using a password on the command line interface can be insecure.
00000000: 6d65 6d6f 0ae6 9c80 e588 9de3 81ae e8a1  memo............
00000010: 8c0a e694 b9e8 a18c e381 97e3 819f e382  ................
00000020: 880a                                     ..</code></pre></div><h4>演習のまとめ</h4><ul><li>テキストフィールドやテキストエリアにdata-im属性を記述してリンクノードとすれば、データの表示だけでなくデータベースの更新も行えます。</li><li>コンテキストには、keyキーによるキーフィールドの指定が必要になります。</li><li>データの更新時には楽観的ロックが自動的に稼動します。</li></ul><h3><span id="H3-ANC-5"><span style="display:none">→</span></span><span xmlns="" id="ix-16"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>まとめて更新処理を行う</h3><p>　最初にまず説明したいことは、通常はまとめて処理をする必要はないと考えています。テキストフィールドを更新するたびにデータベースアクセスするのは、待たされる時間が長くなるのではないかという心配はあるかもしれません。しかしながら、単一レコードの更新なので、よほど低速通信中でない限りはそんなに遅くはなりません。また、更新のデータベース処理は非同期処理をしているので、一般的なWebページのような「待ち」にはならないはずです。</p><p>　しかしながら、どうしても、まとめて保存をしたい方は、まとめて保存という仕組みを限定的ながらサポートをしています。まず、この仕組みを利用する場合は、ページネーションのコントロールを表示します。コンテキストの定義の中でpagingキーの値をtrueにします。ページファイルには、id属性が「IM_NAVIGATOR」である、ページネーションのコントロールを生成する場所を指定するタグを作っておきます。そして、IM_Entryの2つ目の引数の配列内に、<span xmlns="" id="ix-17"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>transactionキーで値が「none」の要素を追加します。定義ファイルエディターでこの項目を設定する場合は、ページ最上部の「Show All」ボタンをクリックしてください。リスト3-1-2は定義ファイルでの設定場所を要約したものです。</p><div class="code"><div class="caption">リスト3-1-2　一括保存する場合の定義ファイルの例</div><pre><code>&lt;?php
//todo ## Set the valid path to the file 'INTER-Mediator.php'
require_once('INTER-Mediator/INTER-Mediator.php');

IM_Entry(array (
  array (
    'name' =&gt; 'person',
    'key' =&gt; 'id',
    'view' =&gt; 'person',
    'table' =&gt; 'person',
    <strong>'paging' =&gt; true,</strong>
  ),
),
<strong>array (
  'transaction' =&gt; 'none',
)</strong>,
array (
  'db-class' =&gt; 'PDO', ....
),
false);</code></pre></div><p>　この設定により、ページネーションのコントロールに、「保存」ボタンが表示されます。修正のたびにデータベースへの保存は行わず、ボタンを押したときだけに保存が行われます。なお、この方法を使うとまとめて保存されますが、保存の処理は最適化されていません。単純に1フィールドずつ更新処理のためのサーバーアクセスを実行し、一連の処理をまとめてやるだけのものです。変更フィールドが大量になると、それなりに時間がかかるものと思われます。</p><h3><span id="H3-ANC-6"><span style="display:none">→</span></span><span xmlns="" id="ix-18"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-19"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>更新を行わないようにする</h3><p>　ここまでのところで、INTER-Mediatorではテキストフィールドに表示した値を変更すると自動的にデータベース更新がかかるバインドの処理が利用できるということが大きな特徴であることを説明してきました。一方で、データベースの内容は表示させたいものの、更新処理をしたくない場合もあるでしょう。その場合、タグ内に「data-im-control="<span xmlns="" id="ix-20"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>unbind"」と記述することで、データベースへの更新処理をしなくなります。</p><h3><span id="H3-ANC-7"><span style="display:none">→</span></span>このセクションのまとめ</h3><p>　テキストフィールド、テキストエリアについては、リンクノードとして定義していれば、フィールドのデータを表示するだけでなく、ユーザーの編集作業により、書き換えたデータを元のレコードのフィールドに更新をかけます。このとき、楽観的ロックの仕組みも利用できるため、マルチユーザー動作の基本的な処理も、ページ上のタグ要素に単にdata-im属性を記述するだけで実現できています。テキストエリアもサポートし、改行の入力にも対応しています。</p><!-- ============ SECTION START ============ --><h2><span id="H2-ANC-2"><span style="display:none">→</span></span><span class="sectionnumber">3-2</span>チェックボックス、ラジオボタン、ポップアップメニュー</h2><p class="section-lead">テキスト以外のフォームで使うコントロールについて解説をします。特に、チェックボックスとポップアップメニューはよく利用されるものです。データベースの値とこれらのコントロールの状態を対応づけることや、更新した状態、選択肢を用意する方法などを解説します。</p><h3><span id="H3-ANC-8"><span style="display:none">→</span></span><span xmlns="" id="ix-21"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>チェックボックス</h3><p>　HTMLのルールでは、チェックボックスは、type属性が「checkbox」の<span xmlns="" id="ix-22"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>INPUTタグ要素です。INTER-Mediatorでは、そのタグに、data-im属性でコンテキストとフィールドを指定してバインドすることで、データベースの内容に応じたチェックボックスを作成することができます。INTER-Mediatorで利用する場合には、value属性を指定することが必須です。チェックボックスをオンにしたら、value属性に指定した値をフィールドに書き込みます。チェックボックスをオフにしたら、そのフィールドの値をSQLデータベースの場合はNULL、FileMakerの場合は""にします。例えば、チェックボックスの名前が「チェック欄」などとなっていても、<span xmlns="" id="ix-23"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>value属性値を「1」にしておけば、フィールドには1かNULLのどちらかしか設定されません。したがって、チェックボックス名とは関係なく数値フィールドにすることもできます。もちろん、チェックボックスの名前と同じvalue属性を設定してもかまいませんが、その場合は、フィールドは文字列型にする必要が出てくるでしょう。チェックボックスのフィールドを表示するときには、フィールドのデータとvalue属性が一致していれば、チェックが入るようになります。そのため、value属性が「1」で、データベースのフィールドにあるデータが「2」の場合にはチェックは入りません。</p><h3><span id="H3-ANC-9"><span style="display:none">→</span></span><span xmlns="" id="ix-24"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ラジオボタン</h3><p>　HTMLのルールでは、ラジオボタンは、type属性が「radio」のINPUTタグ要素です。一般にはラジオボタンがひとつということはあり得ないので、複数のボタンが並び、どれかひとつをオンにすると、他はオフになるのが一般的です。そうした動作をさせるために、ラジオボタンのグループをまとめる属性として<span xmlns="" id="ix-25"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>name属性があり、同一のname属性のラジオボタンがセットとして動作する仕組みになっています。</p><p>　INTER-Mediatorでは、そのタグに、data-im属性でコンテキストとフィールドを指定してバインドすることで、チェックボックスと同様にデータベースの内容に応じたラジオボタンを作成することができます。同一のフィールドにバインドしたラジオボタンには、自動的に同一のname属性が設定されるので、グループとして動作します。複数のレコードを含む一覧の中にラジオボタンがあれば、レコードごとに、同一フィールドにバインドした複数のラジオボタンに同一のname属性がつけられます。そして、レコードごとに異なるname属性値を持ちますので、レコードごとに選択されるボタンは分離されます。</p><p>　その他の動作は、チェックボックスと同様です。ラジオボタンも<span xmlns="" id="ix-26"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>value属性を設定しますが、選択したラジオボタンのvalue属性値がフィールドに書き込まれます。一連のセットのラジオボタンのvalue属性値を異なるものにしておくことで、フィールドのデータに応じた値のボタンが選択されるようになります。ラジオボタンも、実際にデータベースに保存されるデータは、value属性の値になるので、もちろん、文字列でもいいのですが、数値に対応付けておいて数値型のフィールドとバインドしてもいいでしょう。</p><h3><span id="H3-ANC-10"><span style="display:none">→</span></span><span xmlns="" id="ix-27"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ポップアップメニューおよび<span xmlns="" id="ix-28"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>リスト</h3><p>　HTMLのルールでは、SELECTタグによってポップアップメニューやリストを構成でき、選択肢はOPTIONタグを利用して記述をします。INTER-Mediatorの場合は、SELECTタグにdata-im属性を指定して、指定したコンテキストのフィールドとのバインドを行います。その結果、フィールドの値に応じてポップアップメニューが選択され、ユーザーがメニュー選択すると、その項目の値にフィールドの値が書き換わります。</p><p>　フィールドに設定する値は、<span xmlns="" id="ix-29"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>OPTIONタグのvalue属性に記述します。OPTIONタグのテキストが実際に見える文字列になりますが、<span xmlns="" id="ix-30"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>value属性はそれと同じでもいいですし、整数と対応付けてもかまいません。したがって、バインドするフィールドはどんなデータを記録するのかに応じて、文字列型かあるいは数値型を選択することになります。</p><p>　ポップアップメニューは未選択の状態がないため、データがないときのポップアップメニューの選択項目の処理として、状況に応じた処理が必要になりますが、INTER-MediatorではデータがないNULLの状態のときには何も表示しないという動作を行います。なお、後からフィールドのクリアをするような場合には、OPTIONタグでクリアに相当する項目を用意しなければなりません。</p><p>　選択肢自体をテーブルから取り出すようなことももちろん可能です。これについては、『4-3　複数のコンテキストとリレーションシップ』にあるリレーションシップについての知識が必要ですので、そちらで説明をします。</p><p>　リストの場合、複数の項目を選択するリストも動作上は可能ですが、その場合のバインド処理については正しく行われないので、リストの場合は単独項目の選択でご利用ください。</p><h3><span id="H3-ANC-11"><span style="display:none">→</span></span><span class="exsign">演習</span>テキスト以外のコントロールを設定する</h3><p>　チェックボックス、ラジオボタン、ポップアップメニューを実際にページ上に表示して、フィールドのデータを更新できるところを確認してみます。</p><h4>チェックボックスをページに用意する</h4><div class="step"><span class="stepnumber">1</span>前の演習の続きで行います。定義ファイルエディター、ページファイルエディター、ページがそれぞれタブあるいはウインドウで開いていることを確認します。もし、定義ファイルエディターやページファイルエディターが開いていない場合には、Webブラウザーで「http://localhost:9080」を開き、「def02.phpを編集する」「page02.htmlを編集する」「page02.htmlを表示する」のリンクをクリックして、それぞれのタブを開きます。</div><div class="step"><span class="stepnumber">2</span>「page02.htmlを編集する」をクリックして開いたページファイルエディターで、page02.htmlのHTMLを次のように変更します。（追加部分を太字にしますが、その他の変わらない部分は一部省略します。）</div><div class="code"><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type="text/javascript" src="def02.php"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table border="1"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;name&lt;/th&gt;&lt;th&gt;mail&lt;/th&gt;&lt;th&gt;category&lt;/th&gt;&lt;th&gt;ckecking&lt;/th&gt;
      &lt;th&gt;location&lt;/th&gt;&lt;th&gt;memo&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;input type="text" data-im="person@name" /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;input type="text" data-im="person@mail" /&gt;&lt;/td&gt;
      &lt;td&gt;
        <strong>&lt;select data-im="person@category"&gt;</strong>
        <strong>&lt;option value="1"&gt;Family&lt;/option&gt;</strong>
        <strong>&lt;option value="2"&gt;Class Mate&lt;/option&gt;</strong>
        <strong>&lt;option value="3"&gt;Collegue&lt;/option&gt;</strong>
      &lt;/select&gt;
      &lt;/td&gt;
      &lt;td&gt;
        <strong>&lt;input type="checkbox" data-im="person@checking" value="1"/&gt;</strong>
      &lt;/td&gt;
      &lt;td&gt;
        <strong>&lt;input type="radio" data-im="person@location" value="1"/&gt;Domestic</strong>
        <strong>&lt;input type="radio" data-im="person@location" value="2"/&gt;International</strong>
        <strong>&lt;input type="radio" data-im="person@location" value="3"/&gt;Neighbor</strong>
        <strong>&lt;input type="radio" data-im="person@location" value="4"/&gt;Space</strong>
      &lt;/td&gt;
      &lt;td&gt;&lt;textarea data-im="person@memo"&gt;&lt;/textarea&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div><div class="step"><span class="stepnumber">3</span>「page02.htmlを表示する」をクリックして開いたページで更新をするなどして、page02.htmlを表示します。すると、ポップアップメニュー、チェックボックス、ラジオボタンが見えています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-072.png"/></div><div class="step"><span class="stepnumber">4</span>メニュー選択や、チェックボックスのオン/オフ、ラジオボタンの選択を行います。もちろん、応答しますが、ページを更新することで、直前と同じ状態になり、データが記録されていることが分かります。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-073.png"/></div><h4>フィールドに設定される値を確認する</h4><div class="step"><span class="stepnumber">1</span>実際にフィールドにどのようなデータが入力されているのかを見てみましょう。SQLコマンドをターミナルから叩いてもいいのですが、せっかくですからINTER-Mediatorを使ってその変化を確認してみましょう。「def02.phpを編集する」をクリックして表示される定義ファイルエディターの画面を呼び出します。</div><div class="step"><span class="stepnumber">2</span>Contextsのタイトルの下にある「追加」ボタンをクリックします。すると、nameが「= new context = 」という新しいコンテキストの枠が追加されます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-074.png"/></div><div class="step"><span class="stepnumber">3</span>新しくできたコンテキストで、nameを「personlist」にします。keyの値として「id」を入力します。tableとviewは、MySQLの場合は「person」、FileMakerの場合は「person_layout」にします。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-075.png"/></div><div class="step"><span class="stepnumber">4</span>「page02.htmlを編集する」をクリックして開いたページファイルエディターで、page02.htmlのHTMLを次のように変更します。（追加部分を太字にしますが、その他の変わらない部分は一部省略します。）</div><div class="code"><pre><code>            :
      &lt;td&gt;&lt;textarea data-im="person@memo"&gt;&lt;/textarea&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
<strong>&lt;table border="1"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;name&lt;/th&gt;&lt;th&gt;mail&lt;/th&gt;&lt;th&gt;category&lt;/th&gt;&lt;th&gt;ckecking&lt;/th&gt;
      &lt;th&gt;location&lt;/th&gt;&lt;th&gt;memo&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td data-im="personlist@name"&gt;&lt;/td&gt;
      &lt;td data-im="personlist@mail"&gt;&lt;/td&gt;
      &lt;td data-im="personlist@category"&gt;&lt;/td&gt;
      &lt;td data-im="personlist@checking"&gt;&lt;/td&gt;
      &lt;td data-im="personlist@location"&gt;&lt;/td&gt;
      &lt;td data-im="personlist@memo"&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</strong>
&lt;/body&gt;
&lt;/html&gt;</code></pre></div><div class="step"><span class="stepnumber">5</span>「page02.htmlを表示する」をクリックして開いたページで更新をするなどして、page02.htmlを表示します。チェックボックスやラジオボタン、ポップアップメニューを選択してみて、下半分のテーブルに見える値が変化することを確認します。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-076.png"/></div><div class="step-wo-number">上のテーブルも、下のテーブルも、同一のレコードの同一のフィールドを表示しています。INTER-Mediatorではこのように、異なるタグ要素に配置したものでも、同一のデータを表示している場合には、一方を変更すると他方も変更するような動作を自動的に行います。こうした機能もバインドの動作のひとつです。2つのテーブルはそれぞれ同じテーブルを基にしていますが、異なるコンテキスト名を設定している点に注意をしてください。</div><h4>演習のまとめ</h4><ul><li>チェックボックスとラジオボタンは、data-im属性とvalue属性を指定してタグを定義することで、バインドしつつ、値の更新が可能です。</li><li>ポップアップメニューはSELECTタグにdata-im属性を指定してバインドし、選択肢を記述するOPTIONタグのvalue属性でフィールドに保存する値と対応付けます。</li><li>同一ページ上で、同じレコードの同じフィールドの値をバインドによって表示されていれば、一方を変更するともう一方も自動的に変更されます。</li></ul><h3><span id="H3-ANC-12"><span style="display:none">→</span></span>このセクションのまとめ</h3><p>　このセクションでは、チェックボックス、ラジオボタン、ポップアップメニューの構築方法を説明しました。INPUT、SELECT、OPTIONタグを利用し、いずれもdata-im属性を指定してバインドすることで、データベースの値とユーザーインターフェースが連動します。value属性の値が、実際にフィールドに記録される値になります。</p><!-- ============ SECTION START ============ --><h2><span id="H2-ANC-3"><span style="display:none">→</span></span><span class="sectionnumber">3-3</span>レコードの追加・削除・複製</h2><p class="section-lead"><span xmlns="" id="ix-31"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-32"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-33"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-34"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-35"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-36"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ここまで、データの表示と更新を見てきましたが、残る処理は新規作成と削除です。これらを行うために、定義ファイルで設定を加えます。すると、その定義に関連した適切な場所に、削除と挿入のためのボタンが自動的に作られます。ただし、新規にレコードを作成するというのは単に空欄を作ればいいだけではすまないこともあります。その場合は、JavaScriptによるプログラムと併用することを検討する必要があります。Ver.5.2以降でサポートする「複製」についても説明しましょう。</p><h3><span id="H3-ANC-13"><span style="display:none">→</span></span>挿入と削除が可能なコンテキスト</h3><p>　定義ファイルに指定するコンテキストでは、tableキーで指定したエンティティに対して、レコードの挿入や削除の処理が実施されます。tableキーが記述されていない場合には、nameキーの値をエンティティとして利用します。同時に、keyキーにより、そのエンティティでの主キーあるいはそれに準じるフィールド名を指定する必要があります。レコード削除の場合は、どのレコードを削除するのかを特定するために、主キーのフィールドの指定は必須です。一方、レコードの挿入だけなら特に主キーの扱いは不要ではありますが、INTER-Mediatorでは、新たにレコードを作った時にそのレコードの主キー値を得て、そのレコードを表示します。1レコードだけを表示させるように設定してあれば、編集可能な状態で開くことができます。つまり、新たに挿入されたレコードの主キー値を得るために、キーフィールド名をkeyキーに指定する必要があります。</p><p>　ここで、PostgreSQLについては、連番を主キーフィールドに設定する仕組みを「シーケンス」と呼ばれるオブジェクトを使って実現しています。テーブル自体に自動連番の機能はなく、連動して稼働するシーケンスオブジェクトが「次の値」を返すという仕様になっています。したがって、レコード挿入時に新たに作られたレコードにおけるkeyキーで指定したフィールドの値は、シーケンスの値から取り出す必要があります。そのため、PostgreSQLについては、シーケンスオブジェクト名を明示的にコンテキスト内で指定できるようになっています。定義ファイルエディターでも、「Sequence」のラベルで記入欄があります。以下、PostgreSQLの場合のみ、コンテキストへの追加の指定が必要になります。手法としては、自分で定義したシーケンスオブジェクトを使う場合と、自動で用意するシーケンスオブジェクトを使用する場合があります。なお、SERIAL型を利用する場合は、シーケンスオブジェクトの認識を自動的に行うため、sequenceキーの指定は不要です。</p><h3><span id="H3-ANC-14"><span style="display:none">→</span></span><span xmlns="" id="ix-37"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-38"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>挿入と削除のコントロール</h3><p>　定義ファイルに記述する手法として、コンテキスト内の<span xmlns="" id="ix-39"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>repeat-controlキーに、表3-3-1のような値を与える方法があります。これにより、適当な場所を選んで、「追加」ボタンや「削除」ボタン、「複製」ボタンを追加することができます。複数の値を空白で区切って指定することもできるので、それぞれのボタンをいずれも表示することができます。</p><div class="table"><table><tr><th>repeat-controlキーの値</th><th>動作</th></tr><tr><td><span xmlns="" id="ix-40"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>insert</td><td>「追加」ボタンをリピーターの後に追加する</td></tr><tr><td><span xmlns="" id="ix-41"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>insert-top</td><td>「追加」ボタンをリピーターの前に追加する</td></tr><tr><td><span xmlns="" id="ix-42"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>delete</td><td>「削除」ボタンを追加する</td></tr><tr><td><span xmlns="" id="ix-43"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>confirm-insert</td><td>「挿入」ボタンをリピーターの後に追加する。ボタンを押した後、挿入していいかどうかを確認する</td></tr><tr><td><span xmlns="" id="ix-44"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>confirm-insert-top</td><td>「挿入」ボタンをリピーターの前に追加する。ボタンを押した後、挿入していいかどうかを確認する</td></tr><tr><td><span xmlns="" id="ix-45"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>confirm-delete</td><td>「削除」ボタンを追加する。ボタンを押した後、削除していいかどうかを確認する</td></tr><tr><td><span xmlns="" id="ix-46"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>copy</td><td>「複製」ボタンを追加する</td></tr><tr><td><span xmlns="" id="ix-47"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>confirm-copy</td><td>「複製」ボタンを追加する。ボタンを押した後、複製していいかどうかを確認する</td></tr><tr><td><span xmlns="" id="ix-48"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>copy-CCCC</td><td>「複製」ボタンを追加する。複製時にリレーションシップで関連付けられたコンテキストCCCCについても複製を行う</td></tr><tr><td><span xmlns="" id="ix-49"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>confirm-copy-CCCC</td><td>「複製」ボタンを追加する。複製時にリレーションシップで関連付けられたコンテキストCCCCについても複製を行う。ボタンを押した後、複製していいかどうかを確認する</td></tr></table><div class="caption">表3-3-1　repeat-controlキーに指定可能な値</div></div><p>　<span xmlns="" id="ix-50"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>「削除」ボタンは、レコードごとに付与されます。言い換えれば、ひとつのリピーターに対して、ひとつのボタンが付与されます。ボタンは、リピーターの末尾に付与されます。もし、リピーターがTRタグ要素であるのなら、その内部のTDタグが並んでいるはずですが、最後にひとつ、中身が空のTDタグ要素（つまり「&lt;td&gt;&lt;/td&gt;」）を追加しておけば、そのセルにボタンが挿入されます。「削除」ボタンは、<span xmlns="" id="ix-51"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>IM_Button_Deleteというclass属性が付与されるので、ボタンのスタイルのカスタマイズは、このクラス名をセレクタとして使用したCSSの定義を記述します。</p><p>　<span xmlns="" id="ix-52"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>「追加」ボタンは、コンテキストに対してひとつ付与されます。こちらも、言い換えれば、ひとつのエンクロージャーに対して、新たなレコードを作成するボタンが付与されます。挿入ボタンの挿入は位置は、エンクロジャーがTBODYの場合は、TFOOT領域に新たにTRタグ要素を作り、その中の最初のTDタグ要素の中にボタンを生成します。キーワードに「-top」が含まれていれば逆にTHEAD領域に新たなTRタグ要素を作り、その中のTD要素の中にボタンを生成します。テーブルではないエンクロージャーの場合には、最後のリピーターの後に追加します。「-top」があれば、リピーターの前に追加します。「追加」ボタンは、<span xmlns="" id="ix-53"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>IM_Button_Insertというclass属性が付与されるので、ボタンのスタイルのカスタマイズは、このクラス名をセレクタとして使用したCSSの定義を記述します。</p><p>　<span xmlns="" id="ix-54"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>「複製」ボタンは、「削除」ボタンと同様にレコードごとに付与され、配置の方法は「削除」ボタンと同様です。クリックすると、対応するレコードの複製が行われ、それぞれのフィールドの値が複製された新しいレコードが作成されます。ただし、定義ファイルのコンテキスト定義にあるkeyキーで指定したフィールド、および、データベースでのテーブル定義において既定値が設定されているフィールドについてはコピーを行いません。keyキーで指定したフィールドは自動的に連番を設定することを想定して、複製対象のフィールドから除外しています。「削除」ボタンは、IM_Button_Copyというclass属性が付与されるので、ボタンのスタイルのカスタマイズは、このクラス名をセレクタとして使用したCSSの定義を記述します。「copy-」に続いて別のコンテキストのnameキーで指定した名前を指定した場合を考えてみましょう。現在のコンテキストとの間でリレーションシップが定義されていれば、関連するレコードのコピーも同時に行います。これについては、『4-3　複数のコンテキストとリレーションシップ』の演習で説明します。</p><p>　これらのボタン名称は、ブラウザーの言語に応じて、「削除」や「Delete」と変化しますが、独自に名前をつけたい場合には、定義ファイルのコンテキスト定義において、<span xmlns="" id="ix-55"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>"button-names"キーに指定する連想配列で、そのコンテキストに登場するボタン名のカスタマイズが可能です。リスト3-3-1や図3-3-1のように、コンテキストの定義に設定を行えば、例えば削除のためのボタンの名称は「レコード削除」ボタンとなります。定義ファイルでは、ページ冒頭のShow Allボタンをクリックして、設定項目を表示して設定してください。</p><div class="code"><div class="caption">リスト3-3-1　button-namesキーの定義ファイル上での設定例</div><pre><code>IM_Entry(array (
  array (
    'name' =&gt; 'person',
    'key' =&gt; 'id',
    'view' =&gt; 'person',
    'table' =&gt; 'person',
    'repeat-control' =&gt; 'confirm-insert confirm-delete copy',
    'records' =&gt; 10,
    'maxrecords' =&gt; 100,
    <strong>'button-names' =&gt; array (</strong>
      <strong>'insert' =&gt; 'レコード追加',</strong>
      <strong>'delete' =&gt; 'レコード削除',</strong>
      <strong>'copy' =&gt; 'レコード複製',</strong>
    <strong>),</strong>
  ),</code></pre></div><div class="picture"><img class="picture-small" src="figs/ng-shot-077.png"/><div class="caption">図3-3-1　button-namesキーの定義ファイルエディターでの設定例</div></div><h3><span id="H3-ANC-15"><span style="display:none">→</span></span><span class="exsign">演習</span>挿入と削除のコントロールを追加する</h3><div class="step"><span class="stepnumber">1</span>前の演習の続きで行います。定義ファイルエディター、ページファイルエディター、ページがそれぞれタブあるいはウインドウで開いていることを確認します。もし、定義ファイルエディターやページファイルエディターが開いていない場合には、Webブラウザーで「http://localhost:9080」を開き、「def02.phpを編集する」「page02.htmlを編集する」「page02.htmlを表示する」のリンクをクリックして、それぞれのタブを開きます。</div><div class="step"><span class="stepnumber">2</span>「def02.phpを編集する」をクリックして開いた、def02.phpファイルの定義ファイルエディターのページを表示します。personコンテキストのrepeat-controlキーの値に「confirm-insert confirm-delete」とキータイプします。Tabキーで移動して、次のテキストフィールドに移動し、設定値を書き込んでおきます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-078.png"/></div><div class="step"><span class="stepnumber">3</span>「page02.htmlを表示する」のリンクをクリックして表示されるページを開きます。つまり、page02.htmlを実際に開きます。もともと開いていたのなら、更新ボタンにより更新します。前の演習の最後に比べて、「削除」ボタンがレコードの右端に、「追加」ボタンがテーブルの最後に追加されているのが分かります。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-079.png"/></div><div class="step"><span class="stepnumber">4</span>適当なレコードの右端にある「削除」ボタンをクリックします。「confirm-delete」が設定なので、削除前にダイアログボックスが表示されて、ほんとうに削除していいかをたずねます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-080.png"/></div><div class="step"><span class="stepnumber">5</span>OKボタンをクリックすると、実際にレコードが削除されます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-081.png"/></div><div class="step"><span class="stepnumber">6</span>「追加」ボタンをクリックします。「confirm-insert」が設定なので、挿入前にダイアログボックスが表示されて、ほんとうにレコードを作成していいかをたずねます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-082.png"/></div><div class="step"><span class="stepnumber">7</span>OKボタンをクリックすると、実際にレコードが追加されました。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-083.png"/></div><div class="step"><span class="stepnumber">8</span>新しく作られたレコードのテキストフィールドに入力すると、もちろん、入力した値はそれぞれのフィールドに記録され、データベースに保存されます。</div><h4><span xmlns="" id="ix-56"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-57"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ページネーションに「追加」ボタンを表示する</h4><div class="step"><span class="stepnumber">1</span>「def02.phpを編集する」をクリックして開いた、def02.phpファイルの定義ファイルエディターのページを表示します。personコンテキストのpagingキーの値を「true」にします。Tabキーで移動して、次のテキストフィールドに移動し、設定値を書き込んでおきます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-084.png"/></div><div class="step"><span class="stepnumber">2</span>「page02.htmlを編集する」をクリックして開いた、page02.htmlのページファイルエディターのページを開きます。次のように、ページネーションコントロールの追加を行います。</div><div class="code"><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type="text/javascript" src="def02.php"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
<strong>&lt;div id="IM_NAVIGATOR"&gt;&lt;/div&gt;</strong>
&lt;table border="1"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;name&lt;/th&gt;&lt;th&gt;mail&lt;/th&gt;&lt;th&gt;category&lt;/th&gt;&lt;th&gt;ckecking&lt;/th&gt;
      &lt;th&gt;location&lt;/th&gt;&lt;th&gt;memo&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
		:</code></pre></div><div class="step"><span class="stepnumber">3</span>「page02.htmlを表示する」のリンクをクリックして表示されるページを開きます。つまり、page02.htmlを実際に開きます。もともと開いていたのなら、更新ボタンにより更新します。ページネーションがある場合、追加のためのボタンは、ページネーション上に、コンテキスト名を伴い「レコード追加」ボタンをとして配置されます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-085.png"/></div><div class="step"><span class="stepnumber">4</span>「def02.phpを編集する」をクリックして開いた、def02.phpファイルの定義ファイルエディターのページを表示します。personコンテキストのrecordsキーの値を「1」にします。この設定により、personコンテキストは1レコードずつ表示され、事実上「カード型」のレイアウトのような動作になります。Tabキーで移動して、次のテキストフィールドに移動し、設定値を書き込んでおきます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-086.png"/></div><h4>1レコードごとに表示する場合のレコード追加</h4><div class="step"><span class="stepnumber">1</span>「page02.htmlを表示する」のリンクをクリックして表示されるページを開きます。つまり、page02.htmlを実際に開きます。もともと開いていたのなら、更新ボタンにより更新します。「レコードの追加」「レコードの削除」ともに、ページネーション側に表示されるようになりました。1レコード単位の場合のみ、削除ボタンもページネーションに表示されます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-087.png"/></div><div class="step"><span class="stepnumber">2</span>ページネーションにある「レコード追加 : person」ボタンをクリックします。レコードを追加していいかどうかをたずねられるので、OKボタンをクリックします。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-088.png"/></div><div class="step"><span class="stepnumber">3</span>内容が空白のレコードが表示された状態になりました。全レコード数は1になっています。この前はレコード数が3だったのですが、新たに1レコードが加わり、テーブルには4レコードあります。しかしながら、1レコードずつ表示しているときには、新規に作成されたレコードだけが検索された状態になります。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-089.png"/></div><div class="step"><span class="stepnumber">4</span>もちろん、新しいレコードのフィールドに入力できます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-090.png"/></div><div class="step"><span class="stepnumber">5</span>ページネーションにある「更新」ボタンをクリックすると、4レコード中の最初のレコードが表示されます。「&gt;&gt;」ボタンをクリックして、最後のレコードに移動すると、今、新たに作成されたレコードが見えています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-091.png"/></div><h4>レコードの「複製」ボタンを設置する</h4><p>　レコードの複製の機能は、Ver.5.2より搭載していますが、MySQLでの搭載のみです。FileMaker等は将来の実装予定項目となっています。</p><div class="step"><span class="stepnumber">1</span>「def02.phpを編集する」をクリックして開いた、def02.phpファイルの定義ファイルエディターのページを表示します。personコンテキストのrepeat-controlキーの値を「copy」にします。paging、records、maxrecordsの値は空欄にしておきます。Tabキーで移動して、次のテキストフィールドに移動し、設定値を書き込んでおきます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-092.png"/></div><div class="step"><span class="stepnumber">2</span>「page02.htmlを編集する」をクリックして開いた、page02.htmlのページファイルエディターのページを開きます。次のように、ページネーションのコントロールを出力する部分をコメントにします。</div><div class="code"><pre><code>&lt;body&gt;
<strong>&lt;!-- &lt;div id="IM_NAVIGATOR"&gt;&lt;/div&gt; --&gt;</strong>
&lt;table border="1"&gt;</code></pre></div><div class="step"><span class="stepnumber">3</span>「page02.htmlを表示する」のリンクをクリックして表示されるページを開きます。つまり、page02.htmlを実際に開きます。もともと開いていたのなら、更新ボタンにより更新します。「複製」ボタンが各レコードの右側に表示されます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-093.png"/></div><div class="step"><span class="stepnumber">4</span>例えば、上から2番目のレコードの「複製」ボタンをクリックすると、そのレコードが複製されて、リストの最後に見えています。実行時の状態によって画面の内容は変わりますので、実際に複製された内容はご利用しているブラウザー上で確認してください。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-094.png"/></div><div class="step"><span class="stepnumber">5</span>「def02.phpを編集する」をクリックして開いた、def02.phpファイルの定義ファイルエディターのページを表示します。personコンテキストのpagingを「true」、recordsを「1」にします。Tabキーで移動して、次のテキストフィールドに移動し、設定値を書き込んでおきます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-095.png"/></div><div class="step"><span class="stepnumber">6</span>「page02.htmlを編集する」をクリックして開いた、page02.htmlのページファイルエディターのページを開きます。次のように、ページネーションのコントロールを出力する部分をコメントにしていましたが、コメントを取り除きます。</div><div class="code"><pre><code>&lt;body&gt;
<strong>&lt;div id="IM_NAVIGATOR"&gt;&lt;/div&gt;</strong>
&lt;table border="1"&gt;</code></pre></div><div class="step"><span class="stepnumber">7</span>「page02.htmlを表示する」のリンクをクリックして表示されるページを開きます。つまり、page02.htmlを実際に開きます。もともと開いていたのなら、更新ボタンにより更新します。ページネーション側に「複製」ボタンが表示されています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-096.png"/></div><div class="step"><span class="stepnumber">8</span>ページネーションコントロールにある「レコード複製：person」というボタンをクリックします。レコードがひとつ増え、コピーされたレコードが表示される状態になりました。つまり、1レコードずつ表示している場合には、複製と新規レコードは同様な動作を行います。</div><h4>演習のまとめ</h4><ul><li>コンテキストにrepeat-controlキーに対する値を記述すれば、レコードの削除や新規レコード作成、レコード複製のためのボタンが自動的に挿入されます。</li><li>単に削除やレコード追加するだけでなく、確認をしたのちに削除や追加を行うユーザーインターフェースも指定できます。</li><li>ページネーションがあれば、レコード追加ボタンはページネーション上に追加されます。</li><li>1レコードずつ表示しているコンテキストの場合、レコード追加したり複製をすると、新しいレコードだけが検索された状態でページは表示されます。</li></ul><h3><span id="H3-ANC-16"><span style="display:none">→</span></span>新規レコードの<span xmlns="" id="ix-58"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-59"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>フィールドの初期値</h3><p>　レコードを新規に作成したとき、データベースエンジン側に設定された既定値はもちろん機能して、指定に従ってフィールドに値が設定されます。加えて、定義ファイルに指定するコンテキストの中に<span xmlns="" id="ix-60"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>default-valuesキーによる値を追加することで、コンテキスト単位でレコードを作成したときにフィールドに設定される値を指定できます。fieldキーとvalueキーを持つ連想配列のさらに配列にしたものが、default-valuesキーの値として設定可能です。</p><p>　リスト3-3-2は定義ファイルをPHPのコードで見た場合での設定例です。同一の設定を定義ファイルで行う場合には、図3-3-2になります。定義ファイルエディターのページの冒頭にあるShow Allボタンをクリックすることで、Default Valuesの設定項目が表示されるので、その下にある「追加」ボタンをクリックして項目を追加し、テキストフィールドの値を書き直します。</p><p>　コンテキストがこの状態で新しいレコードを作成すると、nameフィールドには「Jon Doe」、mailフィールドには「msyk@msyk.net」という値がレコード作成時には自動的に設定されます。もし、コンテキストにqueryキーによる検索条件が設定されているとき、場合によっては新規レコードを作成しても、条件に合わないで、コンテキストとして取り出されない可能性があります。その場合は、default-valuesの指定により、新規レコードでもqueryの条件に合うようにレコードを作るということで対処できるでしょう。</p><div class="code"><div class="caption">リスト3-3-2　default-valuesキーの定義ファイル上での設定例</div><pre><code>IM_Entry(array (
  array (
    'name' =&gt; 'person',
    'key' =&gt; 'id',
    'view' =&gt; 'person',
    'table' =&gt; 'person',
    'repeat-control' =&gt; 'confirm-insert confirm-delete',
    'paging' =&gt; true,
    'records' =&gt; 10,
    'maxrecords' =&gt; 100,
    <strong>'default-values' =&gt; array (</strong>
      <strong>array ( 'field' =&gt; 'name', 'value' =&gt; 'Jon Doe', ),</strong>
      <strong>array ( 'field' =&gt; 'mail', 'value' =&gt; 'msyk@msyk.net', ),</strong>
    <strong>),</strong>
  ),</code></pre></div><div class="picture"><img class="picture-small" src="figs/ng-shot-098.png"/><div class="caption">図3-3-2　default-valuesキーの定義ファイルエディターでの設定例</div></div><p>　さらに、フィールドの既定値をJavaScriptのプログラムで動的に設定する方法もあります。INTERMediatorオブジェクトにある<span xmlns="" id="ix-61"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>additionalFieldValueOnNewRecordプロパティを利用します。このプロパティは、コンテキスト名をプロパティ名としたオブジェクトを参照します。例えば、ページファイルのヘッダー部にあるSCRIPTタグ要素のプログラムをリスト3-3-3のように記述したとします。ここでは、historyというコンテキストで新しいレコードを作成すると、startdateフィールドに今日の日付を初期値として設定します。<span xmlns="" id="ix-62"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>additionalFieldValueOnNewRecordに続いて、コンテキスト名を [ ] で指定します。右辺の値は、fieldキーとvalueキーを持つオブジェクトです。fieldキーにはフィールド名を指定し、valueキーには値を指定します。この場合は、正確には、ページを開いた日付になります。なお、FileMakerの場合は、日付の文字列を「月/日/年」形式にしなければなりません。</p><div class="code"><div class="caption">リスト3-3-3　レコード作成時の既定値指定のプログラム例</div><pre><code>INTERMediator.additionalFieldValueOnNewRecord
  ["history"] = {
    field: "startdate", 
    value: new Date().toISOString().substr(0, 10)
  };
</code></pre></div><p>　もし、新規レコード時に値を設定するフィールドが複数ある場合、fieldおよびvalueキーを持つオブジェクトの配列で記述をします。リスト3-3-4はその例です。新しくhistoryコンテキストにレコードを作ったとき、startdateおよびenddateフィールドに、今日の日付が入力されます。</p><div class="code"><div class="caption">リスト3-3-4　レコード作成時の既定値が複数フィールドある場合</div><pre><code>INTERMediator.additionalFieldValueOnNewRecord
  ["history"] = [
    { field: "startdate", 
      value: new Date().toISOString().substr(0, 10) },
    { field: "enddate", 
      value: new Date().toISOString().substr(0, 10) },
  ];</code></pre></div><p>　なお、これらフィールドの初期値に関する設定は新規レコード作成時だけでなく、レコード複製時にも適用されます。</p><h3><span id="H3-ANC-17"><span style="display:none">→</span></span>論理削除に対応する</h3><p>　定義ファイルのコンテキスト定義に、<span xmlns="" id="ix-63"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>soft-deleteキーによる値を追加すれば、<span xmlns="" id="ix-64"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>論理削除（<span xmlns="" id="ix-65"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Soft Delete）に対応します。論理削除とは、レコードの削除操作においては実際にレコードを削除するのではなく、フラグとなるフィールドになんらかの値を代入して、削除したことにする手法です。soft-deleteキーの値を「true」にするのが基本です。そのときは、コンテキストのもとになっているテーブルにあるdeleteフィールドを、削除したかどうかのフラグに使います。soft-deleteキーの値を文字列にすると、その文字列がフラグとなるフィールド名になります。</p><p>　soft-deleteキーが設定されるとフラグとなるフィールドが、数値の1のものが削除されたレコードであると判断します。それ以外のものは削除されていないものと判断します。repeat-controlキー等で付与した「削除」ボタンは、実際にはレコード削除はしないで、フィールドに1を設定するだけにします。削除とみなさないレコードでは、そのフィールドの値はNULLあるいは""でかまいません。したがって、初期値を特に設定はする必要はありません。</p><p>　論理削除が設定されたコンテキストに対してクエリーを行うとき、「delete != 1」という検索条件が必ず付与されるので、検索結果からは論理的に削除されたレコードは排除される仕組みになっています。</p><p>　なお、論理削除されたレコードを参照したい場合は、別のコンテキストを定義してください。もちろん、そのコンテキストでは、soft-deleteキーは設定しないでおきますし、場合によってはqueryキーの値を利用して、deleteが1のレコードに最初から絞り込んでも良いでしょう。そして、復活させるためのユーザーインターフェースを、例えばポップアップメニューで作成するなどしてください。</p><p>　実際に、INTER-Mediator-Server VMを利用して、論理削除の動作の確認をしてみます。以下のページは、page06.html、def06.phpを利用しましたが、すでにこのファイルを使っている場合には、異なる番号のファイルを利用してください。定義ファイルは、図3-3-3のように作成しました。personテーブルを使用したコンテキストを2つ「person」と「personall」定義します。図はMySQLに対応するもので、FileMakerの場合は、tableおよびviewキーの値を「person_layout」と設定してください。personコンテキストはsoft-deleteキーの値を「checking」としています。これは、テーブルに定義された数値型のフィールドです。このフィールドを、削除のフラグとして利用するということをこれで宣言しています。personallコンテキストではsoft-deleteキーの値はなく、queryキーも設定されていないので、原則としてすべてのレコードが出力されます。</p><div class="picture"><img class="picture-small" src="figs/ng-shot-102.png"/><div class="caption">図3-3-3　論理削除のテストを行う定義ファイル</div></div><p>　ページファイルはリスト3-3-5のように作成しました。それぞれのコンテキストをTABLEタグで一覧表示しています。テーブルが左右に並ぶように、style属性を設定してあります。その他はこれまでに説明してきたことと特に違いはありません。</p><div class="code"><div class="caption">リスト3-3-5　論理削除のテストを行うページファイル</div><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type="text/javascript" src="def06.php"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table style="float:left" border="2"&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td data-im="personall@name"&gt;&lt;/td&gt;
      &lt;td data-im="personall@checking"&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table style="float:left" border="1"&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;input type="text" data-im="person@name"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;br clear="all"/&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div><p>　実際にページを表示してみます。図3-3-4では、左側のテーブルに、全レコードが表示されていて、1レコード目のcheckingフィールドが「1」であることが分かります。右側は、論理削除の設定が機能しているため、checkingフィールドの値が「1」のレコードは当初から見えていません。最初からcheckingが「1」のレコードがない場合は、以降の説明を参考にレコードを増やして確認してみてください。</p><div class="picture"><img class="picture-small" src="figs/ng-shot-101.png"/><div class="caption">図3-3-4　論理削除を設定したコンテキストのレイアウト結果</div></div><p>　ここで右側のテーブルの下にある「追加」ボタンを押して、レコードを追加します。追加後は、ブラウザーのページの更新を行って、再度ページの構築を行ってください。そして、右側のテーブルで新規レコードに対するnameフィールドのテキストフィールドがあるので、そこに適当な名前を入力しておきます。</p><div class="picture"><img class="picture-small" src="figs/ng-shot-105.png"/><div class="caption">図3-3-5　新しいレコードを追加した</div></div><p>　この状態で、右側のテーブルの新しいレコードに対応する「削除」ボタンをクリックします。すると、右側のテーブルでレコードが消えますが、フィールドの反映された値を確認するために、ブラウザーのページの更新を行って、再度ページの構築を行ってください。そうすれば、後から追加したレコードのcheckingフィールドの値が「1」になっていることが分かります。つまり、「削除」ボタンでは削除は行われず、データベースに対して行う処理はchekingフィールドに「1」を設定するだけになります。</p><div class="picture"><img class="picture-small" src="figs/ng-shot-106.png"/><div class="caption">図3-3-6　レコードの削除を行ったが実際には消えていない</div></div><p>　論理削除を加味したコンテキストと加味しないコンテキストを同時に表示するようなことは、実際の業務で作られることはまずないと思われます。ここで、確認のための更新作業を行うことは、実用上は大きな問題にはならないと考えます。</p><h3><span id="H3-ANC-18"><span style="display:none">→</span></span>PostgreSQLでの<span xmlns="" id="ix-66"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>シーケンスオブジェクト</h3><p>　このセクションの最初にも説明したように、<span xmlns="" id="ix-67"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>PostgreSQLではレコード挿入操作の動作を他のデータベースと揃えるために、シーケンスオブジェクトの名前をコンテキストに<span xmlns="" id="ix-68"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>sequenceキーで指定する必要があります。</p><p>　まず、シーケンスオブジェクトを自分で定義する場合を考えます。リスト3-3-6は、スキーマ定義の一部分です。まず、CREATE SEQUENCEでserialというシーケンスオブジェクトを定義しています。そして、personテーブルのidフィールドでは、シーケンスオブジェクトのserialより新たな値を得て、それを初期値にしています。最後の方には、GRANTステートメントで、この場合のユーザーwebに対して権限を与えていますが、テーブルへの権限だけでなく、シーケンスオブジェクトへの権限も適切に与えることを忘れないようにします。</p><div class="code"><div class="caption">リスト3-3-6　シーケンスオブジェクトを伴うスキーマの一部</div><pre><code>CREATE SEQUENCE serial START 1000;
CREATE TABLE person (
    id INTEGER DEFAULT nextval('serial'),
    :
}
GRANT ALL PRIVILEGES ON im_sample.serial TO web;
GRANT ALL PRIVILEGES ON im_sample.person TO web;</code></pre></div><p>　定義ファイルの記述方法として、PHPでの一部分を示します。リスト3-3-7のように、sequeceキーで、シーケンスオブジェクトの名前を指定します。なお、ここでの「im_sample」はスキーマ名です。定義にスキーマ名を含めるかどうかは、データベースの設計次第でもありますが、INTER-MediatorのPostgreSQLのサンプルでは、データベースのエンティティは「スキーマ名.エンティティ名」という形式で記述しました。</p><div class="code"><div class="caption">リスト3-3-7　シーケンスオブジェクトの指定を含むコンテキスト定義</div><pre><code>array(
    'records' =&gt; 1,
    'paging' =&gt; true,
    'name' =&gt; 'person',
    'view' =&gt; 'im_sample.person',
    'table' =&gt; 'im_sample.person',
    'key' =&gt; 'id',
    'repeat-control' =&gt; 'insert delete',
    <strong>'sequence' =&gt; 'im_sample.serial',</strong>
),</code></pre></div><p>　一方、テーブル定義を行う時に、フィールドの型をSERIAL型で定義して、自動的にシーケンスオブジェクトを用意するという手法もあります。このとき、CREATE SEQUENCEによるオブジェクトの定義は不要ですが、「テーブル名_フィールド名_seq」というシーケンスオブジェクトが自動的に作られて、初期値が1になっています。例えば、im_sampleスキーマのpersonテーブルのidフィールドがSERIAL型だったとします。すると、person_id_seqというシーケンスオブジェクトが自動的に作られます。自動的に作られるオブジェクトにもアクセス権の設定を記述する必要があります。ただし、この場合は、sequenceキーの指定は不要です。</p><h3><span id="H3-ANC-19"><span style="display:none">→</span></span>このセクションのまとめ</h3><p>　レコードの削除やレコード作成は、コンテキストにrepeat-controlキーで値を指定することで、自動的にボタンを生成することができます。ボタンの位置や、あるいは確認をするかどうかなどは、指定値によりある程度はカスタマイズが必要です。ページネーションが表示されていれば、ページネーション上にレコード作成ボタンが表示されます。コンテキストのrecordsキーの値が1の場合に新規レコードを作成すると、新規レコードだけが検索された状態になり、ボタンを押せば新規レコードだけが表示されるといった動作になります。</p><!-- ============ SECTION START ============ --><h2><span id="H2-ANC-4"><span style="display:none">→</span></span><span class="sectionnumber">3-4</span>入力専用のPost Onlyモード</h2><p class="section-lead">アンケートの記入などのような、入力専用のページを作成することもできます。ボタンをクリックすると、コンテキストに新しいレコードを作ることができます。</p><h3><span id="H3-ANC-20"><span style="display:none">→</span></span>ページファイルでの違い</h3><p>　<span xmlns="" id="ix-69"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>入力専用モード（あるいは「<span xmlns="" id="ix-70"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Post Onlyモード」）で動作させる場合には、定義ファイルは通常通り作成し、新規レコード作成できる状態になっていればOKです。具体的には、tableキーあるいはnameキーで指定される書き込み時のテーブルが、実際に存在して書き込み可能になっていれば動作します。定義ファイルでは、動作のバリエーションのための指定を加えることができますが、これはこの後に説明します。</p><p>　Post Onlyモードのページも、通常のページファイルと同様に作成します。これまでに説明した部分でもFORMタグは使っていませんが、Post Onlyモードでも同様です。ただし、エンクロージャーに相当するタグ要素にdata-im-control属性を設定して、値は「<span xmlns="" id="ix-71"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>post」とします。また、レコード作成のボタン（以下、「<span xmlns="" id="ix-72"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>登録ボタン」と記述します）が必要ですが、BUTTONタグの要素に対して、<span xmlns="" id="ix-73"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>data-im-control属性を設定して、こちらも値は「post」とします。この2つの点が通常のデータベースの内容を表示するページと異なりますが、後は同様です。なお、原則として、ひとつのエンクロージャーに1セットのリピーターという構成になります。リピーター内部のリンクノードは、通常通り、data-im属性に「コンテキスト名@フィールド名」の値を設定します。コンテキスト定義に指定したvalidationキーの設定についても適用されます。</p><p>　<span xmlns="" id="ix-74"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>チェックボックスと<span xmlns="" id="ix-75"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ラジオボタンをグループとして動作させることもできます。その場合、data-im属性ではなく、<span xmlns="" id="ix-76"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>data-im-group属性に「コンテキスト名@フィールド名」の値を設定します。ラジオボタンであればどれかひとつの要素だけが選択されますが、チェックボックスは複数の要素をオンにすることで、それらの要素のvalue属性値を改行で区切った値をデータベースに送り込みます。FileMakerの<span xmlns="" id="ix-77"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>チェックボックスセットに似た機能です。</p><p>　Post Onlyモードでは、data-im-control属性に「post」を指定したエンクロージャーの外部にあるエンクロージャーに対しては、普通にページ合成ができるので、データベースアクセスの結果と、入力フォームを混在させることもできます。また、入力フォームの内部のエンクロージャーも同様に通常通り処理されるので、ポップアップメニューの選択肢をデータベースから取り出して配置することなど、通常のページと同様な処理ができます。つまり、ページファイルの中にあるひとつのコンテキストだけをPost Onlyモードで動作させることができます。このとき、データベースの新規レコードを作成に使うコンテキストの範囲はそのコンテキストに加えて、コンテキストの中にある別のコンテキストの領域も探します。</p><p>　階層化したコンテキストの動作を説明するために、具体的に説明しましょう。まず、商品申し込み用紙のようなページを作るとします。申し込み用紙に相当するPost Onlyモードのコンテキストを「request」とします。その中で、商品一覧を「products」コンテキストから取り出して表示します。商品一覧の中に商品を選択するチェックボックスを配置し、そのチェックボックスはrequestコンテキストに含むようにして選択結果を新しいレコードに加えたいとします。ページファイルをリスト3-4-1のように記述します。</p><div class="code"><div class="caption">リスト3-4-1　別のコンテキストを含むPost Onlyモードのコンテキスト</div><pre><code>&lt;table&gt;
&lt;tbody data-im-control="post"&gt;
&lt;tr&gt;&lt;th&gt;名前&lt;/th&gt;&lt;td&gt;&lt;input type="text" data-im="request@name"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;住所&lt;/th&gt;&lt;td&gt;&lt;input type="text" data-im="request@addr"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;メール&lt;/th&gt;&lt;td&gt;&lt;input type="text" data-im="request@mail"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;商品&lt;/th&gt;&lt;td&gt;
	&lt;table&gt;
	&lt;tbody&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;input type="checkbox" data-im-group="request@selection"
				data-im-control="unbind"
				data-im="products@product_id@value"&gt;&lt;/td&gt;
		&lt;td data-im="products@name"&gt;&lt;/td&gt;
	&lt;/tr&gt;
	&lt;/tbody&gt;
	&lt;/table&gt;
&lt;/td&gt;
&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;td&gt;&lt;button data-im-control="post"&gt;送信&lt;/button&gt;&lt;/td&gt;
&lt;/tbody&gt;
&lt;/table&gt;</code></pre></div><p>　実際にページを表示するとき、外側のテーブルのrequestコンテキストはPost Onlyモードで動作するので、基本的にそのまま展開されるだけです。しかしながら、内側のテーブルではproductsコンテキストがあるので、複数のレコードを取り出していくつかの行に展開します。各行には、チェックボックスと、おそらく商品名がそれぞれセル内に表示されているでしょう。チェックボックスのvalue属性は、product_idフィールドの値が設定されます。</p><p>　ここで、「送信」ボタンをクリックすれば、外側のテーブルの内部にあるdata-imおよびdata-im-group属性がrequestコンテキストの要素だけでなく、内部のコンテキスト、つまり内側のテーブルの中のdata-imおよびdata-im-group属性がrequestコンテキストの要素も収集して、データベースに送り込みます。このときのデータベースに送られるINSERT文を模式的にMySQLの文法で記述すると、リスト3-4-2のようになります。productsコンテキストでは、いくつかの商品がチェックボックスとともに見えていて、そのうち、product_idが21と44と32のチェックボックスを選択していたとします。selectionフィールドは改行で区切られます。このフィールドを保存するには、SQLデータベースの場合は文字列型にしておく必要があります。なお、この結果を持って、さらに別のテーブルにレコードを作りたい場合には、『8-3　サーバーサイドでの処理の追加』以降で説明するアドバイス定義クラスをPHP言語でのプログラミングで記述する必要があります。</p><div class="code"><div class="caption">リスト3-4-2　レコード作成時のSQLステートメント例</div><pre><code>INSERT INTO request 
SET name='Someone', addr='Anywhere', mail='foo@bar.com', selection='21\n44\n32'</code></pre></div><p>　ただし、このように、データベースの値を適用したチェックボックスを用意しつつ、その結果をPost Onlyモードで利用する場合でも、チェックボックスは通常のコンテキストであるproductsコンテキストで展開しているため、product_idフィールドとバインドしてしまいます。ここでは、単に表示だけよく、値の収集はrequestコンテキストとして稼働するので、チェックボックスのオン/オフで、データベース更新する必要はありません。そこでタグの中に「data-im-control="<span xmlns="" id="ix-78"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>unbind"」と記載してバインドをしないようにして、データベースへの更新処理を行わないようにしています。</p><h3><span id="H3-ANC-21"><span style="display:none">→</span></span>登録ボタンを押した後の動作の設定</h3><p>　ここまで設定したPost Onlyモードのコンテキストの場合は、登録ボタンを押した後、ページはそのままなので、何度もボタンを押されてしまう可能性があります。その都度レコードが作成されてしまい、意図しない動作を引き起こします。そこで、表3-4-1のような設定を、コンテキストに加えます。これにより、ボタンを押したら、ボタンが即座に消えて、2回押されることはほぼなくなります。また、その後にメッセージを出したり、別のURLに移動できるので、入力者に対する適切なユーザーインターフェースを構築することができます。なお、これらの動作の前に、データベースに新しいレコードを作成します。</p><div class="table"><table><tr><th>コンテキストで使用できるキー</th><th>動作</th></tr><tr><td><span xmlns="" id="ix-79"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>post-reconstruct</td><td>この設定があれば、登録ボタンを押した後に<span xmlns="" id="ix-80"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-81"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ページの再合成を行う。値はなんでも良いが論理値として定義されているので、trueを指定する。post-dismiss-messageが指定されていれば、4秒後に再合成する</td></tr><tr><td><span xmlns="" id="ix-82"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>post-dismiss-message</td><td>入力型フォームにおいて、登録ボタンを押した後に、ボタンを消してここに記述した<span xmlns="" id="ix-83"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-84"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>メッセージの文字列を表示する。文字列はSPANタグでclass属性が「<span xmlns="" id="ix-85"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>IM_POSTMESSAGE」のタグ要素に含まれている</td></tr><tr><td><span xmlns="" id="ix-86"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>post-move-url</td><td>入力型フォームにおいて、登録ボタンを押した後に、ここで指定した<span xmlns="" id="ix-87"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-88"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>URLにページを移動させる。指定しない場合にはページ移動はない。post-dismiss-messageが指定されていれば、4秒後に移動する</td></tr></table><div class="caption">表3-4-1　登録ボタンをクリックした後の動作</div></div><p>　いずれも、画面更新や別のURLへの移動までの動作時間は4秒としましたが、その時間を変更したい場合には、INTER-Mediatorで参照されるオブジェクトのwaitSecondsAfterPostMessageプロパティの値を設定してください。単位は秒です。リスト3-4-3は指定例で、例えば、ページ合成前に実行されるメソッドに記述をします。INTERMediatorOnPage.doBeforeConstructについては、『8-6　ブラウザーを判断するページ』の最後に解説があります。</p><div class="code"><div class="caption">リスト3-4-3　ページの再合成までの時間を10秒にする</div><pre><code>INTERMediatorOnPage.doBeforeConstruct = function () {
	INTERMediator.waitSecondsAfterPostMessage = 10;
}</code></pre></div><p>　登録ボタンをクリックした後に独自のプログラムを追加したい場合は、リスト3-4-4のような記述でメソッドを定義します。例えば、データベースに新規レコードを作成する際に、独自の判定ルールに合致している場合だけ新規レコード作成を認めるといった運用が考えられます。表3-4-1に示したメッセージ表示、ページ再合成、ページ移動が定義ファイルに設定されていた場合、それらよりも前に、以下に定義した関数を実行します。processingBeforePostOnlyContextは、データベースへの書き込み前に実施され、返り値がfalseだとデータベース処理を行わず、ページ移動なども行いません。processingAfterPostOnlyContextはデータベース処理後に実行され、返り値は指定しません。</p><div class="code"><div class="caption">リスト3-4-4　データベースへの書き込み前後に行う処理の記述</div><pre><code>INTERMediatorOnPage.processingBeforePostOnlyContext
  = function(node){
	  // any program here.
	  return true;
     };
INTERMediatorOnPage.processingAfterPostOnlyContext
  = function(node){
	   // any program here.
     };</code></pre></div><h3><span id="H3-ANC-22"><span style="display:none">→</span></span><span class="exsign">演習</span>Post Onlyモードのページを作成する</h3><p>　実際にPost Onlyモードのページを作成して、その動作を見てみましょう。ここでは、新しくページを作りますが、これまでに使ってきたpersonテーブルに入力するので、入力した結果はこの章のこれまでの演習で作ってきたページを利用します。</p><h4>Post Onlyモードのページの作成</h4><div class="step"><span class="stepnumber">1</span>ブラウザーで、「http://localhost:9080」に接続します。「トライアル用のページファイルと定義ファイル」というタイトルの部分を特定します。すでに開いているのなら、そのタブあるいはウインドウを開きます。</div><div class="step"><span class="stepnumber">2</span>「def03.phpを編集する」をクリックし、定義ファイルエディターでdef03.phpファイルを編集します。（もし、他の用途で3番目を利用しているのなら、例えば、def11.phpを利用するなど、別の番号のセットを使用してください。その場合ソースコードの記述が変わる部分がありますが、可能な限り注記します。）</div><div class="step"><span class="stepnumber">3</span>Contextsの中のQueryと書かれた部分を特定します。そして、その次の行の右の方にある「削除」をクリックして、Queryの設定がある行を削除します。</div><div class="step"><span class="stepnumber">4</span>「レコードを本当に削除していいですか？」とたずねられるので、OKボタンをクリックします。</div><div class="step"><span class="stepnumber">5</span>同様に、Sortingの次の行にある「削除」ボタンを押し、確認にOKボタンをクリックして、こちらの設定も削除しておきます。</div><div class="step"><span class="stepnumber">6</span>nameを「person」、tableとviewはデータベースに応じて次のように設定します。Contextsのその他のテキストフィールドはkeyはid、recordsは1,pagingはtrue、その他は空白にします。</div><div class="step-wo-number">[MySQL]の場合<br/>table、viewともに「person」と入力します。personは定義されているテーブルです。</div><div class="step-wo-number">[FileMaker]の場合<br/>table、viewともに「person_layout」と入力します。FileMakerではテーブル名やTOC名ではなく、レイアウト名を指定します。</div><div class="step"><span class="stepnumber">7</span>Database Settingsに設定を行います。</div><div class="step-wo-number">[MySQL]の場合<br/>db-classは「PDO」のままでかまいません。dsnに「mysql:host=db;dbname=test_db;charset=utf8mb4」と入力します。そして、userに「web」、passwordに「password」と入力します。</div><div class="step-wo-number">[FileMaker]の場合<br/>db-classを「FileMaker_DataAPI」に書き換えます。databaseは「TestDB」、userに「web」、passwordに「password」、serverに「gateway.docker.internal」、portに「443」、protocolに「https」、cert-vefifyingに「false」と入力します。</div><div class="step"><span class="stepnumber">8</span>Debugについては、「false」にすると、デバッグ情報が出なくなります。なお、デバッグ情報をみながら動作を確認したい方は、「2」のままにしてこの後の作業を行ってください。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-107.png"/></div><div class="step"><span class="stepnumber">9</span>「http://localhost:9080」で開いたページに戻り「page03.htmlを編集する」をクリックし、ページファイルのpage03.htmlを編集するページファイルエディターが開きます。HTMLでの記述内容を以下のように変更します。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div><div class="code"><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type="text/javascript" src="def03.php"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
<strong>&lt;table&gt;
  &lt;tbody data-im-control="post"&gt;
    &lt;tr&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;td&gt;&lt;input type="text" data-im="person@name"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;mail&lt;/th&gt;
      &lt;td&gt;&lt;input type="text" data-im="person@mail"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;category&lt;/th&gt;
      &lt;td&gt;
        &lt;select data-im="person@category"&gt;
          &lt;option value="1"&gt;Family&lt;/option&gt;
          &lt;option value="2"&gt;Class Mate&lt;/option&gt;
          &lt;option value="3"&gt;Collegue&lt;/option&gt;
      	&lt;/select&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;td&gt;&lt;button data-im-control="post"&gt;Register&lt;/button&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</strong>
&lt;/body&gt;
&lt;/html&gt;</code></pre></div><div class="step"><span class="stepnumber">10</span>「http://localhost:9080」で開いたページに戻り「page03.htmlを表示する」をクリックし、ページを表示します。フォーム要素を持つテーブルが、記述通りに動作して、ページが作成されています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-109.png"/></div><div class="step"><span class="stepnumber">11</span>適当に入力して、Registerボタンをクリックします。クリック後、この状態では特にページに変化はありません。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-110.png"/></div><div class="step"><span class="stepnumber">12</span>page02.htmlを表示します。すでに開いている場合には、そのタブあるいはウインドウに切り替えて、ページの更新をします。開いていない場合には「http://localhost:9080」で開いたページに戻り、「page02.htmlを表示する」をクリックします。確かに、前の手順で登録した内容が追加されています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-111.png"/></div><h4>登録後に状態を表示するページにする</h4><div class="step"><span class="stepnumber">1</span>「def03.phpを編集する」をクリックして表示したページのタブあるいはウインドウを開き、定義ファイルエディターでdef03.phpファイルを編集します。Show Allボタンをクリックして、表示項目数を増やします。personコンテキストの中にある、post-reconstructを「true」、post-dismiss-messageに「投稿しました」と入力します。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-112.png"/></div><div class="step"><span class="stepnumber">2</span>page03.htmlを表示します。すでに開いている場合には、そのタブあるいはウインドウに切り替えて、ページの更新をします。適当に入力して「Register」ボタンをクリックすると、即座に、post-dismiss-messagに指定した文字列が表示されます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-113.png"/></div><div class="step"><span class="stepnumber">3</span>4秒後にページが更新され、新規入力できる初期画面に戻りました。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-114.png"/></div><h4>演習のまとめ</h4><ul><li>エンクロージャーと登録ボタンにdata-im-control属性を設定し、値を「post」にすれば、データベースの内容を合成しない、Post Onlyモードのコンテキストがページ上に構築されます。</li><li>登録ボタンをクリックすると、テキストフィールドなどに入力した内容をフィールドの値とした新しいレコードが作成されます。</li><li>ボタンを押した後にメッセージを表示したり、あるいはページの再合成が可能なので、二重登録を避けることができます。</li></ul><h3><span id="H3-ANC-23"><span style="display:none">→</span></span>Post Onlyモードと「<span xmlns="" id="ix-89"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>確認画面」が不要な理由</h3><p>　INTER-Mediatorでは、Post Onlyモードによる新規レコード作成に対応しています。通常、フォームで入力するときには、入力結果を改めて別の画面に明示し、入力者に確認をさせて、OKかあるいは修正するというユーザーインターフェースが一般的です。もちろん、そのような動作をPost Onlyモードで実現してもよいのですが、開発者としてはその機能は不要と考えます。</p><p>　Web情報を検索してみると、確認画面に対する否定的な意見がいくらかある一方で、確認画面の作り方というサイトは大量に出てきます。現状、確認画面は作って当たり前というのがどうも業界の一般常識なのでしょうか？　ただし、なぜ、必要なのかという積極的な説明を明確にしたサイトは筆者が探した中にはありませんでした。一方、不要であるという主張に対する理由には「出したところで見ている人はほとんどいないだろう」という消極的な理由を挙げているものがほとんどです。</p><h4>確認フォームが必要な理由</h4><p>　まず、一般的なWebフォームではなぜ確認が必要なのかということがあります。当然の理由として、入力したものを「確認したいから」、あるいは「確認する必要があるから」ということになりますが、理由はもう少し掘り下げて考えないといけません。おそらく、過去からのいろいろな経験の積み重ねで次のような理由があるからでしょう。</p><ul><li>フォームのページでは入力した情報がすべて見えているとは限らない</li><li>入力した情報以外のものを表示したい（販売サイトの合計金額や送料など）</li><li>ReturnキーやEnterキーによって、submitボタンが押されたのと同じになり、意図せずサブミットしてしまうときにやり直しが効かない</li><li>積極的な理由はない、一般にそうだからとか、とにかく確認させたいといった理由</li></ul><p>　これらを順次検討しましょう。まず、最初の理由、つまりすべての要素が見えていないというのは、大昔の解像度の低いWebページを作っていた時代では確かにあったかもしれません。テキストフィールド枠が40文字しかない画面で、それ以上の文字入力を許している場合、入力後に全体を確認する必要があります。ユーザーは垂直方向はもちろん、水平方向にもスクロールしないと文字が見えません。そのような状況で、念のため一度全部、ページに見せるということは確かに必要でした。</p><p>　しかしながら、現在は解像度が高いディスプレイが一般的になり、一覧性が高まりました。また、スマホのように画面表示領域が小さいデバイスの場合には、1ページにすべてを詰め込むような設計は避けられています。現在はデザインが重視されており、入力中に今自分が入力したものが見えないようなレイアウトは、一般にはデザインが悪いと言わざるを得ないでしょう。もし、この理由でフォームの確認画面が必要なら、まず、フォーム自体を見直す必要があります。入力中に全体像が分かるようにしてあれば、わざわざ確認画面を出す必要はなくなるでしょう。項目が多くなると、スクロールしないとすべてが見えないから、確認画面が必要という議論もあるかもしれません。しかしながら、その場合は、確認画面自体もスクロールが必要になることが一般的ではないでしょうか？　とにかく、入力フォームの段階で、確認ができるレベルでページを作っておくのが最善策であることを目指すのが適切な対処だと考えます。</p><p>　2つ目は、入力したもの以外の情報を確認したいという理由です。例えば、販売サイトでの合計や送料等の表示があります。これは、入力した結果の確認画面の話でしょうか？　違います。これは、システムが生成した結果を利用者が確認する画面のことで、入力の確認画面の議論と混同してはいけません。</p><p>　3つ目の理由は、古い時代のフォームでは、入力途中にReturnキーに触れてしまって意図せずサブミットされることがありました。テキストフィールドにフォーカスがあるときにReturnキーを押すと、自動的にそれを含むFORMタグのsubmitボタンがクリックしたものとみなされるのは一般的な動作です。他のフレームワークならともかく、INTER-MediatorはテキストフィールドでReturnを押しても、設定やあるいはプログラムを追加しない限りsubmit的な動作は起こりません。つまり、INTER-Mediatorであれば、Returnで意図せずサブミットされることはありません。逆に、Returnでサブミットしたいのなら、何かしらの記述を追加しなければなりません。</p><p>　4つ目の理由は、積極的な理由がなく、そう言われているからやるというものです。積極的な理由もなく、何かをするのでしょうか？　理由がないのが理由ということに対しては、エクスキューズの必要すらないと考えます。本当に利用者のことを真剣に考えているのであれば、何か理由があるはずです。ユーザーにとって特別なメリットがないのに機能を組み込むのは開発者側の勝手な思い込みではないでしょうか？</p><h4>それでも“従来手法”を求められたら？</h4><p>　INTER-Mediatorでシステムを作る場合、それでも「確認」ページの作成を求められたらどうしましょうか？　確認の実装方法として、「ボタンを押したらダイアログボックスで短いメッセージを出して確認」があります。新たなページを作るのではなく、単に入力フォームの内容が書き込みされるということを促して、人間の手による応答が入ればいい程度のような場合です。</p><p>　この場合は、Post Onlyモードで入力ページを作成します。そして、データベースへの書き込みに行く前に実行するメソッドを定義して、そこでダイアログボックスを表示します。例えば、ページファイルのヘッダー部にあるSCRIPTタグ要素のプログラムをリスト3-4-5のように記述したとします。ページファイル内でPost Onlyモードのリピーターがあり、そこでボタンをクリックすると、ここに定義した<span xmlns="" id="ix-90"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>processingBeforePostOnlyContextメソッドが呼び出されます。このメソッドがfalseを返せば、データベース処理等は何も行いません。<span xmlns="" id="ix-91"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>confirm関数はダイアログボックスを表示し、OKをクリックすればtrue、キャンセルをクリックすればfalseを返します。</p><div class="code"><div class="caption">リスト3-4-5　入力前にダイアログボックスで確認する</div><pre><code>&lt;script type="text/javascript" src="def03.php"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
INTERMediatorOnPage.processingBeforePostOnlyContext 
  = function(node) {
    return confirm("本当に入力していいでしょうか？　" 
                 + "しつこいようですが、やっちゃいますよ");
  }
&lt;/script&gt;</code></pre></div><p>　これ以上の仕組み、例えば、確認用の別のページを見せるような手法については、少し複雑になります。次にそのヒントについて説明をします。</p><h3><span id="H3-ANC-24"><span style="display:none">→</span></span><span xmlns="" id="ix-92"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-93"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>確認付きの入力フォームの作成方法</h3><p>　以上のように、入力結果を新規レコードとして残すような入力フォームでは、INTER-Mediatorで適切なデザインをしていれば、確認画面が必要な積極的な理由はありません。しかしながら、発注側の要求は常に論理的とは限りません。ここまでに記載したような説明をしたとしても、「やっぱり確認ページが欲しいです」という場合もあるでしょう。その場合の一般的な対処法についてまとめておきます。</p><p>　まず、いわゆる「確認ページ」が欲しいという場合には、入力および確認のための要素をすべて1ページに作り、CSSのdisplay属性を利用していずれか一方を表示するような仕組みにして、Post Onlyモードで新規レコードを作成するという方法があります。この方法は、複数のページを経由して書き込みをするような場合にも応用できます。</p><p>　確認ページ付きのPost Onlyモードのページの例を示します。INTER-Mediator-Server VMの適当なWebページのセット（例えば、def21.phpとpage21.html）等に入力すれば確認できます。定義ファイルは図3-4-1のように、入力結果を受け付けるsurveyという名前のコンテキストが定義されているとします。Database Settingsのセクションは、これまでの演習で紹介したように指定します。このコンテキストには、フィールドにはQ1とQ2が少なくともあるとします。ページファイルはリスト3-4-6に示します。</p><div class="picture"><img class="picture-small" src="figs/ng-shot-062.png"/><div class="caption">図3-4-1　使用しているコンテキスト</div></div><div class="code"><div class="caption">リスト3-4-6　確認を伴うPost Onlyモードのページ</div><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        .input {
            display: table-row;
        }
        .confirm {
            display: none;
        }
    &lt;/style&gt;
    &lt;script type="text/javascript" src="def21.php"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
    function toConfirm()	{
      var textNode, value, textNode;
      value = document.getElementById("Q1Input").value
      textNode = document.createTextNode(value);
      document.getElementById("Q1Confirm").appendChild(textNode);
      value = document.getElementById("Q2Input").value
      textNode = document.createTextNode(value);
      document.getElementById("Q2Confirm").appendChild(textNode);
      toggle("none", "table-row");
    }

    function toInput()	{
      document.getElementById("Q1Confirm").innerHTML = "";
      document.getElementById("Q2Confirm").innerHTML = "";
      toggle("table-row", "none");
    }

    function toggle(inputDisplay, confirmDisplay) {
      var body, nodes, i;
      body = document.getElementsByTagName("BODY")[0];
      nodes = INTERMediatorLib.getElementsByClassName(body, "input");
      for (i = 0 ; i &lt; nodes.length ; i ++)  {
        nodes[i].style.display = inputDisplay;
      }
      nodes = INTERMediatorLib.getElementsByClassName(body, "confirm");
      for (i = 0 ; i &lt; nodes.length ; i ++)  {
        nodes[i].style.display = confirmDisplay;
      }
  }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table&gt;
&lt;tbody data-im-control="post"&gt;
&lt;tr class="input"&gt;
    &lt;th&gt;Q1&lt;/th&gt;
    &lt;td&gt;&lt;input type="text" data-im="survey@Q1" id="Q1Input" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="input"&gt;
    &lt;th&gt;Q2&lt;/th&gt;
    &lt;td&gt;&lt;input type="text" data-im="survey@Q2" id="Q2Input"/&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="input"&gt;
    &lt;th&gt;&lt;/th&gt;&lt;td&gt;&lt;button onclick="toConfirm()"&gt;確認&lt;/button&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="confirm"&gt;
    &lt;th&gt;Q1&lt;/th&gt;&lt;td id="Q1Confirm"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="confirm"&gt;
    &lt;th&gt;Q2&lt;/th&gt;&lt;td id="Q2Confirm"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="confirm"&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;td&gt;
        &lt;button onclick="toInput()"&gt;戻る&lt;/button&gt;
        &lt;button data-im-control="post"&gt;書き込み&lt;/button&gt;
    &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div><p>　実際にページを表示した結果が、図3-4-2です。最初、2つのフィールドに対するテキストフィールドが見えているので、適当にキータイプをします。そして、「確認」ボタンをクリックすると、確認のための表示に切り替わります。ここで、「戻る」ボタンだと、テキストフィールドの表示に戻り、「書き込み」ボタンをクリックすると、Post Onlyモードの動作として、レコードを新たに作成し、Q1およびQ2フィールドは、それぞれテキストフィールドに入力した値になります。</p><div class="picture"><img class="picture-small" src="figs/ng-shot-063.png"/><img class="picture-small" src="figs/ng-shot-064.png"/><div class="caption">図3-4-2　ページの表示例</div></div><p>　プログラム部分を解説します。それぞれのボタンから呼び出されるJavaScriptのプログラムにあるtoggle関数は、classの値に応じて引数の値をCSSのdisplay属性に設定します。display属性が「table-row」なら行として表示、「none」であれば非表示になります。class属性がconfirmの行は、ヘッダー部のSTYLEタグの定義により、ページを表示したときには非表示になります。<span xmlns="" id="ix-94"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>INTERMediatorLib.getElementsByClassNameは、INTER-Mediatorによって提供されるメソッドで、最初の引数で指定したタグ要素（この場合は、BODYタグ要素）以下の要素（ノード）を検索し、2つ目の引数で指定した名前のclass属性を持った要素の配列を得るものです。これ以外は、JavaScriptの標準的なメソッドや関数を利用したものです。</p><p>　toConfirm関数では、テキストフィールドに入力した文字列を、確認用のセルの値に設定し、表示する行を切り替えています。Post Onlyモードでは、data-im属性があっても、id属性は変更されずに定義通りに残ります。id属性を手掛かりにして、テキストフィールドを参照しvalue属性で入力した文字列を取得しています。なお、DOMのAPIでは、プログラムにあるようにテキストノードを生成して、appendChildで子要素として設定するといったややこしいことを行う必要があります。jQueryを使えばもっと短く記述できますので、そちらに慣れているのならjQueryも併用しましょう。原則、INTER-MediatorとjQueryは共存できるはずです。toInput関数は表示する行を切り替えればいいのですが、何度も行き来すると、確認用のセルに、つどつどテキストフィールドの値が追加されることになるので、入力用のセルを表示する前にいったん確認用のセルはクリアしています。</p><p>　なお、このままでは、バリデーションの実装に悩むところです。バリデーションのルールに合わなくても、toConfirm関数を実行して、確認ページに遷移してしまいます。確認ページではバリデーションの結果は得られません。</p><p>　解決方法として、INTER-Mediatorのバリデーション機能を統合するのもひとつの方法ですが、もっと明確な方法もあります。toConfirm関数では、実質的には入力したデータをひとつひとつ変数に取り出しています。であるならば、かえって、JavaScript上で確認処理を実装したほうがより明確ですし、正しくないときの処理も自由に組み込めます。発展させるなら、そちらの方向がより良い方法と考えられます。</p><h3><span id="H3-ANC-25"><span style="display:none">→</span></span>処理結果を伴う場合の対処</h3><p>　ECサイトにあるような、商品申し込みをした後に、送料が計算されて出てくるようなアプリケーションを考えてみましょう。こうした確認用のページは発注者から見れば「入力フォーム」かもしれませんが、状況に応じて（あるいは一定の）送料が付加される点では、単なる入力ページではなく、何らかの処理を行うページであり、入力フォームの確認ということとは動作上は意味合いが違うということはこれまでに説明しました。</p><p>　では、そういうページはどう作ればいいのでしょうか？　これらについて、画一的な方法はありません。そのアプリケーションに応じた作り方をしなければならないと考えます。もし、一定の「送料」を付加するだけなら、直前の『確認付きの入力フォームの作成方法』で紹介した方法の応用でできるでしょう。確認ページでは、送料を追加で表示します。データベース側に送料の金額をフィールドに入れたい場合には、typeがhiddenのINPUTタグを用意してフィールドにバインドしておき、JavaScriptのプログラムでそこに設定を行います。</p><p>　さらに複雑なロジックが絡む場合の対処法については、さまざまなプログラミングテクニックが絡むので、『6-5　Post Onlyモードと連動した処理』で実例として示します。</p><h3><span id="H3-ANC-26"><span style="display:none">→</span></span>このセクションのまとめ</h3><p>　Post Onlyモードという仕組みで、入力専用のページの作成が可能です。エンクロージャーおよび内部のボタンに、data-im-control属性がpostのものを用意するのが基本で、これにより、テキストフィールド等に入力したデータを、新規レコードとして指定したコンテキストに追加できます。ボタンを押した後にメッセージを表示したり、別のページに移動する仕組みも定義ファイルで実装できます。バリデーションや、リピーター内部にエンクロージャーを指定したマスター参照による選択肢の構築なども可能です。なお、一般には、入力後の処理をする仕組みも含めて「入力フォーム」と呼ばれることが多いのですが、INTER-Mediatorでは処理を含む場合、Post Onlyモードだけの仕組みでは思った通りの動作ができないかもしれません。その場合は、Post Onlyモードを使わないという選択肢も考慮すべきです。</p><!-- ============ SECTION START ============ --><h2><span id="H2-ANC-5"><span style="display:none">→</span></span><span class="sectionnumber">3-5</span>バリデーション</h2><p class="section-lead">データの入力や更新時には、ユーザーの入力した結果を検証し、間違いであることが分かればデータベースへの入力をしないで、ユーザーに修正を求めたいことがあります。こうした一連の機能を<span xmlns="" id="ix-95"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>バリデーションと呼びます。INTER-Mediatorではコンテキストへの定義の追加でバリデーションの設定が可能です。</p><h3><span id="H3-ANC-27"><span style="display:none">→</span></span>コンテキスト定義に設定するバリデーション</h3><p>　コンテキストの定義では、<span xmlns="" id="ix-96"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>validationキーによって指定が可能です。値は、field、rule、message、notifyをキーに持つ連想配列を要素とした配列です。これは、queryキーなどと同様な形式です。定義ファイルエディターでは、ページの冒頭にある「show all」ボタンを押すことで、設定項目が表示されます。連想配列に指定する内容は表3-5-1の通りです。</p><div class="table"><table><tr><th>キー</th><th>指定する値</th><th>動作</th></tr><tr><td><span xmlns="" id="ix-97"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>field</td><td>フィールド名のみ</td><td>データ確認を行うフィールド名</td></tr><tr><td><span xmlns="" id="ix-98"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>rule</td><td>JavaScriptの式</td><td>入力値は変数value、ノードへの参照は変数targetに入っているものとして、式を組み立てることができる。式の結果がtrueならそのまま処理を進める</td></tr><tr><td><span xmlns="" id="ix-99"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>message</td><td>文字列</td><td>正しくない場合に表示するメッセージ。ruleで指定した式の結果がfalseなら、messageの文字列を表示して値を元に戻す</td></tr><tr><td><span xmlns="" id="ix-100"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>notify</td><td>（省略、以下のもの以外）</td><td>ダイアログボックスでメッセージを表示する</td></tr><tr><td/><td><span xmlns="" id="ix-101"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>inline</td><td>ノードの直後に文字列としてmessageをSPANタグ（クラスは_im_alertmessage）で追加する</td></tr><tr><td/><td><span xmlns="" id="ix-102"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>end-of-sibling</td><td>兄弟ノードの最後にmessageをSPANタグ（クラスは_im_alertmessage）で追加する</td></tr></table><div class="caption">表3-5-1　validationキーの値に指定する連想配列</div></div><p>　fieldでは、コンテキスト内に現れるフィールド名を指定します。ruleには式を記述しますが、変数valueとtargetをいきなり記述できます。例えば、リスト3-5-1のようなvalidationキーの値を記述した場合、フィールドnameとバインドしたテキストフィールド全てで、データの変更を行ったときに、「length(value) &gt; 1」という式を計算します。式の記述については『4-4　計算プロパティの設定』で解説をしますが、lengthは文字列の長さを求める関数です。つまり、テキストフィールドに入力された文字列を調べて、1より大きい場合はtrueになり、そのままフィールドの値が更新されて何もメッセージは出しません。しかしながら、文字列が1文字だけの場合ではruleの式はfalseになります。すると、messageやnotifyで指定されたメッセージが表示されます。</p><div class="code"><div class="caption">リスト3-5-1　validationキーを指定したコンテキストの例</div><pre><code>IM_Entry( array (
  array (
    'name' =&gt; 'person',
    'key' =&gt; 'id',
    'view' =&gt; 'person',
    'table' =&gt; 'person',
    'validation' =&gt; array (
      array (
        'field' =&gt; 'name',
        'rule' =&gt; 'length(value) &gt; 1',
        'message' =&gt; '2文字以上入力してください',
      ),
    ),
  ),</code></pre></div><div class="picture"><img class="picture-small picture-dummy" src="figs/ng-shot-115.png"/><div class="caption">図3-5-1　ダイアログボックスでメッセージを表示した例</div></div><p>　ダイアログボックス以外のメッセージの表示方法として、ページ上にテキストノードを追加する方法があります。テキストフィールドの右側などに、「文字を入力してください」といったようなメッセージが表示されます。このときは、notifyキーの値を指定してください。テキストを赤文字にしたいなどのスタイルを指定したい場合には、テキスト自体のclass属性が_im_alertmessageとなっているので、このクラス名に対するセレクタをCSSで記述すれば良いでしょう。</p><h3><span id="H3-ANC-28"><span style="display:none">→</span></span><span class="exsign">演習</span>バリデーションを組み込む</h3><p>　</p><h4>Post Onlyモードのページの作成</h4><div class="step"><span class="stepnumber">1</span>ブラウザーで、「http://localhost:9080」に接続します。「トライアル用のページファイルと定義ファイル」というタイトルの部分を特定します。すでに開いているのなら、そのタブあるいはウインドウを開きます。</div><div class="step"><span class="stepnumber">2</span>「def04.phpを編集する」をクリックし、定義ファイルエディターでdef04.phpファイルを編集します。（もし、他の用途で4番目を利用しているのなら、例えば、def11.phpを利用するなど、別の番号のセットを使用してください。その場合ソースコードの記述が変わる部分がありますが、可能な限り注記します。）</div><div class="step"><span class="stepnumber">3</span>Contextsの中のQueryと書かれた部分を特定します。そして、その次の行の右の方にある「削除」をクリックして、Queryの設定がある行を削除します。</div><div class="step"><span class="stepnumber">4</span>「レコードを本当に削除していいですか？」とたずねられるので、OKボタンをクリックします。</div><div class="step"><span class="stepnumber">5</span>同様に、Sortingの次の行にある「削除」ボタンを押し、確認にOKボタンをクリックして、こちらの設定も削除しておきます。</div><div class="step"><span class="stepnumber">6</span>nameを「person」、tableとviewはデータベースに応じて次のように設定します。</div><div class="step-wo-number">[MySQL]の場合<br/>table、viewともに「person」と入力します。personは定義されているテーブルです。</div><div class="step-wo-number">[FileMaker]の場合<br/>table、viewともに「person_layout」と入力します。FileMakerではテーブル名やTOC名ではなく、レイアウト名を指定します。</div><div class="step"><span class="stepnumber">7</span>Contextsにあるkeyは「id」、pagingは「true」、repeat-controlは「confirm-insert confirm-delete」、recordsは「1」とします。その他のテキストフィールドは空白にします。</div><div class="step"><span class="stepnumber">8</span>Database Settingsに設定を行います。</div><div class="step-wo-number">[MySQL]の場合<br/>db-classは「PDO」のままでかまいません。dsnに「mysql:host=db;dbname=test_db;charset=utf8mb4」と入力します。そして、userに「web」、passwordに「password」と入力します。</div><div class="step-wo-number">[FileMaker]の場合<br/>db-classを「FileMaker_DataAPI」に書き換えます。databaseは「TestDB」、userに「web」、passwordに「password」、serverに「gateway.docker.internal」、portに「443」、protocolに「https」、cert-vefifyingに「false」と入力します。</div><div class="step"><span class="stepnumber">9</span>Debugについては、「false」にすると、デバッグ情報が出なくなります。なお、デバッグ情報をみながら動作を確認したい方は、「2」のままにしてこの後の作業を行ってください。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-116.png"/></div><div class="step"><span class="stepnumber">10</span>「http://localhost:9080」で開いたページに戻り「page04.htmlを編集する」をクリックすれば、ページファイルのpage04.htmlを編集するページファイルエディターが開きます。HTMLでの記述内容を以下のように変更します。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div><div class="code"><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type="text/javascript" src="def04.php"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="IM_NAVIGATOR"&gt;&lt;/div&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;td data-im="person@id"&gt;&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;
        &lt;th&gt;name&lt;/th&gt;
        &lt;td&gt;&lt;input type="text" data-im="person@name"&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;th&gt;mail&lt;/th&gt;
        &lt;td&gt;&lt;input type="text" data-im="person@mail"&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre></div><h4>データを判定してエラーを表示する</h4><div class="step"><span class="stepnumber">1</span>「def04.phpを編集する」をクリックして表示したページのタブあるいはウインドウを開き、定義ファイルエディターでdef04.phpファイルを編集します。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div><div class="step"><span class="stepnumber">2</span>Show Allボタンをクリックして、表示項目数を増やします。personコンテキストの中にある、Validationsの「追加」ボタンをクリックします。項目を作成して良いかどうかを確認されるので、OKをクリックします。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-117.png"/></div><div class="step"><span class="stepnumber">3</span>Validationsの設定枠が作られます。ここで、fieldは「name」、ruleは「length(value)&gt;0」、messageは「空欄はだめです！」と入力します。notifyは空欄にします。変更後、Tabキーを押して、確実に変更結果が書き込まれるようにします。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-118.png"/></div><div class="step"><span class="stepnumber">4</span>「http://localhost:9080」で開いたページに戻り「page04.htmlを表示する」をクリックし、ページを表示します。personテーブルの一部のフィールドが編集可能な状態で表示されるページが作成されています。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div><div class="picture"><img class="picture-small" src="figs/ng-shot-119.png"/></div><div class="step"><span class="stepnumber">5</span>ページネーションのコントロールにある「レコード作成: person」をクリックして、新たにレコードを作ります。レコードを作成して良いかどうかを確認されるので、OKをクリックします。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-120.png"/></div><div class="step"><span class="stepnumber">6</span>Validationsの設定があるnameフィールドのテキストフィールドをクリックして、入力しようとします。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-121.png"/></div><div class="step"><span class="stepnumber">7</span>何も入力しないで、Tabキーを押して、次のフィールドに移動しようとしてみます。すると、「空欄はだめです！」というメッセージが表示されます。「閉じる」をクリックしても、元のnameのテキストフィールドに文字カーソルが点滅しており、次のフィールドに移動しません。つまり、Validationsの設定にあるruleを評価し、現在のvalueは "" なので、length("")の結果が0になって、不等式が成り立たなくなり、値が不正と判定してメッセージを表示しているのです。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-122.png"/></div><div class="step"><span class="stepnumber">8</span>nameフィールドに適当に何か入力してTabキーを押すと、次のフィールドに移動します。入力された値は "test" なので、Validationsのrulesの条件式がtrueとなって条件式が成り立つので、想定された正しい範囲の値が入力されたと判定して、警告等は表示せず先に進みます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-123.png"/></div><h4>インラインでエラー表示</h4><div class="step"><span class="stepnumber">1</span>「def04.phpを編集する」をクリックして表示したページのタブあるいはウインドウを開き、定義ファイルエディターでdef04.phpファイルを編集します。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div><div class="step"><span class="stepnumber">2</span>定義されているpersonコンテキストのValidationsの設定を変更します。設定が見えていない時には、ページ上部の「Show All」ボタンをクリックしてください。そして、notifyの設定を「inline」とします。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-124.png"/></div><div class="step"><span class="stepnumber">3</span>「page04.htmlを表示する」をクリックして表示したページのタブあるいはウインドウを開き、page04.htmlをブラウザーに表示します。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div><div class="step"><span class="stepnumber">4</span>ブラウザーの更新ボタンをクリックして、修正したコンテキストの結果を反映させます。</div><div class="step"><span class="stepnumber">5</span>ページネーションコントロールの「&gt;&gt;」をクリックするなどして、直前に作成したレコードに移動します。そして、nameフィールドを表示しているテキストフィールドの文字列を削除して何も文字が入力されていない状態にして、Tabキーを押します。すると、Validationsの設定のruleを満たさない状態になりますが、メッセージはダイアログボックスではなく、ページ内に文字列として表示されます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-125.png"/></div><div class="step-wo-number">すでに作られているレコードを編集するページでValidationsの設定をした場合、判定は、設定に含まれているフィールドに対するテキストフィールドなどで編集したり、あるいはクリックするなどして編集しようとした後など、そのフィールドに対して何らかのアクションを取った時にしか判定を行いません。</div><h4>Post Onlyモードでのバリデーション</h4><div class="step"><span class="stepnumber">1</span>「page04.phpを編集する」をクリックして表示したページのタブあるいはウインドウを開き、ページファイルエディターでpage04.phpファイルを編集します。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div><div class="step"><span class="stepnumber">2</span>すでに存在するtableタグのテーブルのすぐ後に、以下のPost Onlyモードの領域を作成します。もちろん、ここまでに表示したのと同じpersonコンテキストへの新規レコードを作成を行うPost Onlyモードの領域です。このコンテキストには、すでにValidationsの設定が行われていることに注目してください。</div><div class="code"><pre><code>  &lt;table&gt;
    &lt;tbody data-im-control="post"&gt;
      &lt;tr&gt;
        &lt;th&gt;name&lt;/th&gt;
        &lt;td&gt;&lt;input type="text" data-im="person@name"&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;th&gt;mail&lt;/th&gt;
        &lt;td&gt;&lt;input type="text" data-im="person@mail"&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;th&gt;&lt;/th&gt;
        &lt;td&gt;&lt;button data-im-control="post"&gt;入力&lt;/button&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;</code></pre></div><div class="step"><span class="stepnumber">3</span>「page04.htmlを表示する」をクリックして表示したページのタブあるいはウインドウを開き、page04.htmlをブラウザーに表示します。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div><div class="step"><span class="stepnumber">4</span>ブラウザーの更新ボタンをクリックして、修正したページの結果を反映させます。</div><div class="step"><span class="stepnumber">5</span>新たに追加したテーブルのnameフィールドのテキストフィールドをクリックして、何も入力せずにTabキーを押します。すると、エラーメッセージが表示され、次のフィールドには進みません。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-127.png"/></div><div class="step"><span class="stepnumber">6</span>ブラウザーの更新ボタンをクリックして最初から作業を始めるとします。新たに追加したテーブルの「入力」ボタンをクリックします。すると、やはりメッセージが表示され、入力処理には以降しません。Post Onlyモードの場合は、データベース処理を行う前に、コンテキストに定義されたValidationsの設定を全てチェックします。</div><h4>演習のまとめ</h4><ul><li>Validationsの設定により、指定したフィールドの値が一定の条件を満たさない場合にはエラーメッセージを表示することができます。</li><li>条件には式を記述します。式では、フィールドの値を示すvalue変数や、HTML要素を参照するtarget変数を利用できます。</li><li>標準ではダイアログボックスでエラーメッセージを表示しますが、設定により、HTMLページ内にメッセージを表示することができます。</li></ul><h3><span id="H3-ANC-29"><span style="display:none">→</span></span>バリデーション機能の利用と注意点</h3><p>　バリデーションの仕組みは、ユーザーインターフェースの応答を重視して、クライアントサイドのみで実施されるようになっています。しかしながら、JavaScriptを利用してサーバーへ直接データを投入することにより、定義したバリデーションを無視したデータ入力ができることになります。この点は問題としては捉えていますが、実現方法に懸念すべき点が多く、Ver.5.7の開発を行っている2017年後半における計画では、先のメジャーアップデートであるVer.6系列で実現する考えです。</p><p>　Post Onlyモードの場合、複数のフィールドの値をもとに判断をするようなバリデーションを実装したいときには、JavaScriptを利用する必要があります。JavaScript関連の章の『6-5　Post Onlyモードと連動した処理』『Post Onlyモードで利用できるAPI』で解説します。</p><p>　演習でもありましたが、バリデーションの機能はレコード編集時には、そのテキストフィールドにフォーカスが入らないと実施されません。「確定」ボタン的なものを持たないユーザーインターフェースなので、そのような動作になります。しかしながら、空欄のままになっては困るということもあるかと思います。その場合、エンクロージャーの処理を終了したときに呼び出されるメソッド（『6-4　ページ合成に割り込む処理の追加』で説明）に、特定のフィールドをフォーカスするようなメソッドを組み込むことで実現できるでしょう。</p><h3><span id="H3-ANC-30"><span style="display:none">→</span></span>このセクションのまとめ</h3><p>　入力したデータが正しいかどうかを判定して、正しくない場合にはエラーメッセージを出す機能が組み込まれています。一般にはバリデーションと呼ばれる機能で、定義ファイルには、特定のフィールドの値を元に判断する設定を記述することができます。一方、複数のフィールドを元にバリデーションを行うには、JavaScriptのプログラミングが必要です。</p></div></body></html>
