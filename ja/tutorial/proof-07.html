<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" class="hltr"><head><title>INTER-Mediatorのセキュリティ</title><link href="00_default.css" rel="stylesheet" media="all"/></head><body xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:msyk="http://msyk.net/Editorial" xmlns:aid5="http://ns.adobe.com/AdobeInDesign/5.0/" xmlns:aid="http://ns.adobe.com/AdobeInDesign/4.0/"><div id="main"><h1><span id="H1-ANC-1"><span style="display:none">→</span></span><span class="chapternumber">Chapter 7</span><br/>セキュリティと認証・アクセス権</h1><p class="version-notation">この章は、INTER-Mediator Ver.11をもとに記載しました。</p><p class="chapter-lead">この章が目指す最も重要な目標は、作成するアプリケーションのセキュリティを確保することです。もちろん、手軽にできるのであれば長々と説明する必要はありません。しかしながら、INTER-Mediator自身のさまざまな設定に加えて、INTER-Mediator外のデータベースやサーバーOSといった部分にも注意が必要です。この章では、全体的なセキュリティ設定に加えて、データベースエンジンで確保すべき動作と、INTER-Mediatorのソリューションに対する設定などを説明します。</p><!-- ============ SECTION START ============ --><h2><span id="H2-ANC-1"><span style="display:none">→</span></span><span class="sectionnumber">7-1</span>Webアプリケーションセキュリティの前提</h2><p class="section-lead">INTER-Mediatorによるシステムを作成した場合の、サーバーやクライアントにおいて、何を前提として<span xmlns="" id="ix-1"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>セキュリティ設計するべきかをまず最初にまとめておきます。</p><h3><span id="H3-ANC-1"><span style="display:none">→</span></span>INTER-Mediatorを稼働する<span xmlns="" id="ix-2"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-3"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>サーバーの前提条件</h3><p>　INTER-Mediatorで作成したソリューションを稼働するには、原則として何らかのサーバーが必要です。すでにこれまでに紹介している通り、Dockerコンテナでの稼働も可能ですが、サーバー機での運用、クラウドサービス上のインスタンス、VPS、レンタルサーバーなど、さまざまな形態で稼働させることができます。ここでのセキュリティ上の原則は、「管理者以外はログインできない」そして「サーバーは健全に稼働している」ということです。</p><p>　管理者であれば、ログインできて、ファイルの内容を参照したり、ファイルを書き換えたりができますが、そうでないユーザーはログインができないということが大原則になります。この原則が守られていて、サーバーが意図した通りに稼働していれば、PHPのファイル、つまり定義ファイルや、あるいは別の設定ファイルなどにデータベース利用のための「パスワードを記述する」ということをしても、パスワード自体は外部に漏れません。</p><p>　また、以前にはよく見られたトラブルとして、PHPが稼働していないときにWebブラウザーから.phpファイルを開くと、PHPのプログラムが丸見えになるようなことがあります。この時、もちろん、プログラム自体に何かのパスワードが書かれていれば、見えてしまい、パスワードの漏洩が発生します。しかしながら、これは意図した動作ではありません。そうならないように稼働させるのが管理者の役割であり、あるいはプロバイダの役割でもあります。「Webサーバーは生きているのにPHPだけ落ちる可能性がある」という指摘もあるかもしれませんが、問題がある状況を前提にするのは、かなり信頼性が疑われるシステムであり、このようなシステムはそもそも業務の実運用に利用するべきではありません。通常の「稼働していることが前提」のシステムは、問題があればWebサーバーを停止させるのが原則であり、言い換えれば、問題があれば一切の機能を落とすくらいの作業をしなければ、「PHPのソースが見える」だけでなく、さまざまな悪影響が出てしまう可能性があります。これは、サーバー運用のポイントでもあります。</p><p>　結果的には、サーバーでは、管理者が意図したサービスのみをクライアントに提供している状態にするのが原則です。例えば、WebサーバーでTLS（一般にはSSLと言われますが、この章ではSSLの後継規格である「TLS」を用います）でしか接続させていないというのであれば、そのサーバーはネットワークから見ると、443番ポートしか開いていないというのが原則です。管理者がそのようにセットアップをして、第三者による変更を許さないようサーバー管理者が責任を持つ、という前提条件でWebアプリケーションは成り立っています。</p><h3><span id="H3-ANC-2"><span style="display:none">→</span></span>INTER-Mediatorを利用する<span xmlns="" id="ix-4"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-5"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ネットワークの前提条件</h3><p>　Webアプリケーションなので、ネットワーク上に存在しているということは当然なのですが、業務系のアプリケーションの場合、文字通りの意味で世界中のネットワークを通るわけではなく、場合によっては、組織内のクローズドなネットワークだけを通してのアプリケーションの利用に限られていることもあります。状況に応じて脅威は変化し、対策も変わってきます。</p><p>　しかしながら、アプリケーションの開発者や利用者にコントロールできるのは、TLSの利用をするかどうかという点が一番大きいでしょう。また、アプリケーションによっては認証の利用やアクセス権（認可）の設定が必要かどうかを検討するかもしれません。認証やアクセス権については、この章の大きな目的であって各所で説明があるので、ここではTLSについての基本的なスタンスを説明します。</p><p>　執筆時点で最新規格であるTLS 1.3は、送信者と受信者以外に通信内容を取り出せないように暗号化通信を実現できます。その前の規格のTLS 1.2の段階では「適切な暗号スイートを利用すれば」と但し書きが必要でしたが、TLS 1.3は安全な暗号スイートに絞られており、設定のミスで危険性を高める可能性は低いと言えます。TLSを利用すれば、暗号化した通信内容を解読するには極めて長い時間を要することから、将来致命的な弱点が見つからない限り、現実的な時間での解読はほぼ困難と言えるでしょう。なお、SSLについては攻撃手段が発見されて、通信の傍受の可能性は0ではなくなったので、利用する仕組みとしては現在は既に除外されています。</p><p>　TLSで守られるとしたら、どういう状況でしょうか？　まず、クライアントとサーバーでは、通信前後に暗号化が解除される段階があるので、TLSによって、すべてが守られるわけではありません。一方、Wi-Fiの電波を解析したり、Ethernetに流れる通信結果を取り出しても前述の通り解析は事実上不可能ですので、漏洩はTLSを使う限り原則的には発生しません。通信内容を読み取られたとしても通信経路上のデータは暗号化されているからです。また、サーバーとクライアントの間には、たくさんのルーティングの機材（ルータあるいはホスト）が介在しますので、その機材を通る間のパケットを傍受される可能性もあります。しかし、TLSの場合は、中間で暗号化の解除は通常はできませんので、この脅威も取り除かれることになります。</p><p>　では、組織内のネットワークしか通過しないのなら、TLSは必要でしょうか？　これは、組織内のネットワークが正しく運用されているかと、組織内のスタッフを信用できるかどうかに関わってきます。「社内だから大丈夫」と思ったら、Wi-Fiに誰もが入れるようなお粗末な管理だと、「内部ネットワーク」とは言えず、結果的にはインターネットカフェなどと同じ程度の安全性になります。つまり、組織内だからTLSは不要であるという結論を出すには、ネットワークの管理が正しく行われているかどうかに依存します。その上で、スタッフを信頼できるかどうかは、是非とも組織内でディスカッションをしてみるべきテーマです。</p><h3><span id="H3-ANC-3"><span style="display:none">→</span></span><span xmlns="" id="ix-6"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-7"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ブラウザーのセキュリティ</h3><p>　現在、セキュリティ上の懸念点があるのは、サーバーやネットワークよりもむしろブラウザーであると言えるでしょう。ソフトウェアは作り方によってはセキュリティ上の問題点を発生します。特にXSS（クロスサイトスクリプティング）については、あらゆるWebアプリケーション開発者が常に意識すべき問題です。これについては、このすぐ後の『クロスサイトスクリプティング攻撃（XSS）とinnerHTML』で説明します。</p><p>　ブラウザーでの一番の問題は、利用者が切り替わる場合の対処です。認証が必要なサイトをあるユーザーが利用していたとして、しばらくデスクを空けていたとします。その間に、画面がスリープやロックになって、元のユーザーにしか分からないパスワードでしか解除できない状況なら問題はありません。しかし、ブラウザーのウインドウが開きっぱなしならどうでしょうか？　それまでのユーザーになりすまして、別のユーザーも利用できてしまいます。これは、使用中だけでなく、使用後と思っても正しくログアウトできていない場合、やはり別のユーザーが偶然に認証済みのページを見つけてしまうかもしれません。この問題は、すべてのアプリケーションに存在し、防ぐ方法はありません。言い換えれば、利用者が端末を適切な方法で利用しない場合には、脅威として必ず存在します。もちろん、INTER-Mediatorだけの問題ではありません。アプリケーションを実装するときに、何もしないと認証が時間切れになる仕組みを利用したり、あるいはその時間を短くするなどで、他人がなりすます可能性を少しは減るかもしれませんが、力ずくで端末を開いた状態で取り上げられるようなことがあれば、やはり脅威となり得るのです。</p><p>　ブラウザー上で稼働するJavaScriptのプログラムの場合、常に、変数の結果を参照したり、あるいは書き換えたり、場合によってはプログラムの書き換えができてしまう点に注意を払う必要があります。INTER-Mediatorでは、パスワードそのものは変数にも残さないようにしていますが、認証の手がかりとなる情報は変数に残しています。ある操作をすれば、それは参照できますが、原則として、本人が操作して見えてしまっても、本人である限りは問題ないと言えます。また、書き換えた結果、何もできなくなるのなら、それは書き換えた人の責任であり、開発する側は責任を取る必要はないと考えます。しかしながら、問題になるのは、そうして書き換えをした結果、別のユーザーになりすますことができるような状況があるかどうかです。INTER-Mediatorでは、その点はテストしており、認証時に別のユーザーになりすますことはできない仕組みになっています。少なくとも、開発時にはその点も考慮しました。</p><p>　いずれにしても、JavaScriptのプログラムをクライアントで触れる点は問題になりそうですが、それによって他のユーザーになりすましたり、あるいはシステムやデータに損傷を加えることがなければ問題はないと言えます。ただし、この点について「バグが発見されていない」というだけのことで、この点について保証できるものではありません。潜在的には何かしらの問題点がある可能性があります。バグによる脆弱性の存在の可能性はINTER-Mediatorに限らずどんなソフトウェアにも存在します。何らかの懸念点があれば、アプリケーション開発者でもフレームワークの動作を検証する必要はあるかもしれません。</p><h3><span id="H3-ANC-4"><span style="display:none">→</span></span><span xmlns="" id="ix-8"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>クロスサイトスクリプティング攻撃（<span xmlns="" id="ix-9"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>XSS）と<span xmlns="" id="ix-10"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>innerHTML</h3><p>　クロスサイトスクリプティング攻撃（XSS）は、現在のWebアプリケーション開発において、必ず考慮されなければならないセキュリティ要件です。このXSSは、攻撃者が仕込んだ任意のJavaScriptが実行できる状況において発生し、その結果、例えばある特定のサイト向けのクッキー情報やページ上に表示された情報を、攻撃者のサイトにネットワーク転送してしまうような悪用が考えられます。つまり、ページ上で、任意のスクリプトが実行される状況を作ってしまうと、XSSが可能なセキュリティホールが発生します。これは、フレームワークに内在する問題ではなく、どんなフレームワークを使っても、アプリケーション側で意図せずに実装されてしまう可能性のあるセキュリティホールです。</p><p>　XSSが発生する代表的な例が、「誰でも書き込みができるBBS」の事例です。せっかくのBBSを盛り上げるために、HTMLで自由にスタイルなどを設定するようにしていたとします。すると、書き込むメッセージにSCRIPTタグがあるとします。そのSCRIPTタグのプログラムは、書き込んだ人だけでなく、BBSを閲覧している人のブラウザー上でも実行します。クッキーの情報は、記録したドメインと同じドメインのサイトに接続しないと読み出せないといった制限がかかってはいるものの、スクリプトはまさにそのサイトにおいて実行しているので、他の人のクッキーを得ることができます。クッキーに含まれる情報で認証の成立を確認する状況は比較的利用されており、クッキーを第三者に取り出されてしまうと、その第三者によってなりすましのログインができてしまう場合も最悪はあり得ることになります。</p><p>　この時、メッセージのHTMLテキストを表示するのに利用されるひとつの方法が、innerHTMLプロパティへの代入です。HTML文字列をそのまま代入できて便利なのですが、その文字列にSCRIPTタグが含まれている可能性があるならば、innerHTMLの利用は危険です。INTER-Mediatorでは、意図的にinnerHTMLを使用するように設定した場合と、認証パネルのカスタマイズの部分を除いて、innerHTMLは利用しないようになっています。通常のデータベースから得られたデータをタグ要素にマージするときには、DOMのAPIを使ってテキストノードとして追加をしています。</p><p>　INTER-Mediatorで制限付きながらもinnerHTMLをサポートしている理由を説明しましょう。innerHTMLの危険性がある一方で、innerHTMLがあれば必ずXSS攻撃を受けてしまうということにはなりません。任意のHTMLテキストをデータとして書き込めるユーザーを限定すれば、第三者からのXSS攻撃は防ぐことができます。例えば、ある組織の通販サイトを運用するのであれば、メッセージを書き込むのは通常は通販会社の担当者です。利用者からのメッセージは例えばテキストだけにするということが一般的です。そういう状況においては、INTER-Mediatorは「任意のスクリプトを第三者が実行できる」状態にはなっていません。そのためにも、HTMLテキストを書込み権限は認証したユーザーだけに与えることをベースにして設計する必要があります。悪意のある人に書き込み権限を与えない方策を備えていれば、innerHTMLを全面的に排除していないことが、問題にはならないと考えています。すなわち、システムを運用する組織としての信頼関係があるユーザーだけに書き込みを許可すれば、XSSの発生となる根本原因を除去できるということです。もちろん、信頼した相手が攻撃をしないという前提の元で成り立つことです。</p><h3><span id="H3-ANC-5"><span style="display:none">→</span></span><span xmlns="" id="ix-11"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>クロスサイトリクエストフォージェリ（<span xmlns="" id="ix-12"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>CSRF）を排除する</h3><p>　クロスサイトリクエストフォージェリ（CSRF）は、最終的にはユーザーが意図しないサイトへ誘導されて、意図しない処理をさせられてしまう可能性のある攻撃です。攻撃者は攻撃用のWebページを公開し、あるユーザーがそのWebページを参照したとします。そのページの中にあるJavaScriptが、全く別のサイトに接続してリクエストを送るということができます。例えば、偽の「お買い得情報！」メールを送り、それを見たユーザーが攻撃者のサイトとは知らずにアクセスしたとします。その際に、そのサイトのファイル一式の中に、オンラインショップに接続して何か購入することを決定するようなスクリプトが組まれていたとしたらどうでしょう。そのユーザーがいつも使うオンラインショップであれば、認証がすでに有効になったままかもしれません。そのままJavaScriptのAJAXの機能を利用して自動的にオンラインサイトを操作して、購入決定までさせてしまうことは技術的には可能です。購入操作が無事完了したかに見えますが、商品は届かないかもしれません。もちろんオンラインショップのコントロールは難しそうですが、匿名の掲示板だとそれほど困難ではありません。ユーザー自身が知らないうちにあちこちのBBSに、攻撃者が記述したなりすましメッセージを書き込まれてしまうということにもなってしまいます。</p><p>　INTER-Mediatorでは、作成したアプリケーションがCSRFを受け入れる脆弱性を持ってしまうことを防ぐための対策も組み入れています。対策方法としては、<a href="http://d.hatena.ne.jp/hasegawayosuke/20130302/p1">リクエストヘッダーにX-FromおよびOriginを利用する手法</a>を利用しました。ポイントは、HTTPリクエストがサーバーに来た時にOriginヘッダーをチェックすることです。JavaScriptで作成した通信処理はXMLHttpRequestクラスを利用しますが、通信においてはそのページが生成されたサーバーのURLがクライアント側で自動的に<span xmlns="" id="ix-13"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Originヘッダーの値に設定されます。そこで、INTER-Mediatorのサーバーでは自分自身のFQDN値を記録し、クライアント側では<span xmlns="" id="ix-14"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>X-Fromヘッダーにその値に付与するように動作します。元サーバーから自動的に付与されるOriginがX-Fromと同じであり、それがサーバーに設定したFQDNと同じであれば、CSRF攻撃ではないと判断できます。さらに、DNSサーバーの応答を操作することでの攻撃を回避するためにHostヘッダーも確認しています。攻撃側では攻撃対象のサーバーのFQDNはもちろん分かりますが、それを攻撃プログラムに組み込んでもDNSが正しく稼働している限りはOriginは攻撃者のサーバーになるので、OriginとX-Fromは一致せずCSRF攻撃であるとみなして処理はスキップします。X-Fromを攻撃者のサーバーと同じに設定しても、サーバーに設定したFQDNとも違うので、やはり攻撃が成り立ちません。CSRF対策として自分自身のFQDNをサーバーへ設定する方法については『2-6　設定ファイルparams.php』で説明します。</p><h3><span id="H3-ANC-6"><span style="display:none">→</span></span>データベースアカウントへのアクセス権設定</h3><p>　データベースエンジンには通常、アクセスするためのアカウントを設定可能です。INTER-Mediatorはデータをデータベースに保持するので、<span xmlns="" id="ix-15"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>データベースアカウントを利用することで、可能な限り安全な運用が可能です。なお、SQLデータベースのひとつであるSQLiteではアカウントの設定機能はありません。設定の詳細については、『2-1　データベースからの取り出し設定』で説明があります。</p><p>　SQLiteはネットワーク接続ができませんが、その他のINTER-Mediatorが対応するデータベースはすべてネットワークからの接続ができます。しかしながら、INTER-MediatorあるいはWebサーバーで稼働するWebアプリケーションから利用するときには、ネットワーク接続が必須なわけではありません。例えば、Webサーバーとデータベースサーバーが同一の場合は、データベースへのネットワーク接続は不要です。その場合は、localhostからの接続だけに限定することで、セキュリティ面では「他のコンピューターからの直接接続」は排除できて、不正なアクセスを許す要因は取り除かれます。また、Webサーバーとデータベースサーバーが異なるホストでも、データベース側ではWebサーバーからのアクセスのみを許可することで、他のコンピューターからの接続は排除できます。不要なネットワーク処理を利用できる状態にしないというのは、データベースに限らず、すべてのサーバー運用では鉄則と言える対処です。</p><p>　MySQLやPostgreSQLなどSQLサーバーでデータベースを構築するときには、データベースサーバー自体に対して何でもできるスーパーユーザーを設定します。MySQLではroot、PostgreSQLではpgsql、SQL ServerではSAというユーザー名が一般的でしょう。また、FileMaker Serverは、各データベースにすべての設定変更が可能な管理者ユーザーを設定します。名称は任意ですが、Adminなどの名前をつけます。これらのアカウントには原則としてパスワードを設定します。PostgreSQLの場合は、OSのアカウントを利用するのですが、パスワードを利用してログインをします。これらデータベースエンジンのアカウントは、最初にデータベースを作ったり、スキーマの適用をする場合には必要になりますが、実運用、特に、Web経由のアクセスに応答するために利用することは、可能なかぎり避けるべきでしょう。理由は、「制限したユーザーでの利用の方が少しでも安全になる確率が高い」からです。</p><p>　もし、Webアプリケーションからのアクセスが、データベースからの読み出しのみの場合、データベースのユーザーは、スキーマ定義ができないことはもちろん、必要なテーブルに対してSELECTのみ、あるいは読み出しのみの権限のみを与えておきます。また、Web側から更新があるのなら、スキーマ定義はできないものの、SELECT/DELETE/INSERT/UPDATE、あるいは読み書き権限を与えておきます。こうした、スーパーユーザーでないユーザーの運用制限を加えておくことで最悪の事態が起きた場合でもデータの安全が確保されることになります。最悪の場合に考えられるのは、ソースコードごと漏洩してデータベースのスーパーユーザーが知られてしまう可能性があることや、設定を誤り、抜け道を作ってしまい、読み出ししかできないはずが認証もなくデータを消すことができてしまったといったことがあります。</p><p>　もし、サーバー管理を正しく構築し、ソリューションにセキュリティホール無く作ることができれば、スーパーユーザーでも問題ないのかもしれません。しかしながら、一種の保険として、データベースへのアクセス権を必要以上に広げないようにすることをお勧めします。そんなことは不要、あるいは過剰と思われるかもしれませんが、サーバー運用において不要なポートを閉じるのと同様な、予防的な措置として検討しましょう。</p><p>　なお、プロバイダのレンタルサーバーでは、スキーマ定義や読み書きができるひとつのアカウントしか使えないことがあります。その場合は仕方ありませんので、他の手法でセキュリティを確保することにします。</p><h3><span id="H3-ANC-7"><span style="display:none">→</span></span>セキュリティ設定に関連するヘッダーを通信に含める</h3><p>　セキュリティの確保のための設定がparams.phpにあります。表7-1-1にある変数を定義することで、通信ヘッダー等に情報が追加されます。</p><div class="table"><table><tr><th>変数名</th><th>既定値</th><th>用途</th></tr><tr><td>$xFrameOptions</td><td>"SAMEORIGIN"</td><td>変数に指定した値を<span xmlns="" id="ix-16"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>X-Frame-Optionsヘッダーの値として応答に含める。使用できる文字列は、"SAMEORIGIN", "DENY", "ALLOW-FROM uri"の形式で、""（空文字列）にすれば、X-Frame-Optionsヘッダー自体を出力しない</td></tr><tr><td>$contentSecurityPolicy</td><td>""(空文字列)</td><td>変数に指定した値を<span xmlns="" id="ix-17"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Content-Security-Policyヘッダーの値として応答に含める。""（空文字列）にすれば、Content-Security-Policyヘッダー自体を出力しない</td></tr><tr><td>$accessControlAllowOrigin</td><td>（未定義）</td><td>変数に指定した値を<span xmlns="" id="ix-18"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Access-Control-Allow-Originヘッダーの値として応答に含める。未定義ないしは ""（空文字列）の場合は、Content-Security-Policyヘッダー自体を出力しない</td></tr><tr><td>$webServerName</td><td>設定なし</td><td>Webアプリケーションが稼働しているホストのFQDN名を配列で指定してCSRF攻撃対策を行う。例えば、array('www.inter-mediator.com', 'inter-mediator.org')など。ひとつだけであってもarrayで指定する</td></tr></table><div class="caption">表7-1-1　params.phpに記述できるセキュリティ関連の変数</div></div><p>　HTTPレスポンスに含めるセキュリティ関連のヘッダーについての変数が、$xFrameOptionsと$contentSecurityPolicyです。<span xmlns="" id="ix-19"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>X-Frame-Optionsヘッダーは通常、値が<span xmlns="" id="ix-20"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>SAMEORIGINでヘッダーに含まれています。異なるドメイン名のサイトの内部にINTER-Mediatorのページをiframeタグ要素で挿入するような場合、このヘッダーを非表示にしたり、特定URIに対する許可を与えるなどする必要がありますが、その場合<span xmlns="" id="ix-21"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>クロスサイトスクリプティング攻撃の可能性が高まりますので注意が必要です。<span xmlns="" id="ix-22"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Content-Security-Policyヘッダーは通常は出力されていませんが、こちらも必要なら指定ができます。このヘッダーを適切に指定することで、クロスサイトスクリプティング攻撃の機会を減らすことができます。設定の記述は多岐に渡りますので、詳細は<a href="https://developer.mozilla.org/ja/docs/Web/Security/CSP/Using_Content_Security_Policy">こちら</a>を参照してください。さらに、$webServerName変数を指定することで、<span xmlns="" id="ix-23"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>CSRF対策を行います。URLと接続した先のサーバー名が同一FQDNかどうかを判定する仕組みを稼働させます。Webアプリケーションのセキュリティに関することは、『7-1　Webアプリケーションセキュリティの前提』も参照してください。</p><p>　Webアプリケーションは通常サーバーに配備され、クライアントはそのサーバーとのやりとりだけで完結できます。しかしながら、クライアントがさらに<span xmlns="" id="ix-24"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-25"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>別のサーバーに対してAjax通信を行おうとしても、ブラウザーはセキュリティ上の理由（<span xmlns="" id="ix-26"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Same-Originポリシー）から通常は阻止をします。その時は、<span xmlns="" id="ix-27"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Access-Control-Allow-Originヘッダーを応答に追加すれば、値に指定したURLの通信は別のサーバーでも許可されます。params.phpファイルに$accessControlAllowOrigin変数を定義して、URLを含む文字列の値を代入します。サーバーAとクライアントCがあって、サーバーAにあるWebアプリケーションにクライアントCから接続して利用している場合を想定してください。この場合、AとCのやり取りは特に何もしなくても可能です。もし、Cのクライアントアプリケーションで、別のサーバーBに対してAjaxつまりXMLHTTPRequestクラスを使った通信を行おうとするとき、通常はエラーになります。このとき、AのサーバーのURLを値に持つAccess-Control-Allow-OriginヘッダーをBのサーバーがクライアントCに返すことで、Aの配下のクライアントCであってもBへのアクセスを許可します。Access-Control-Allow-OriginヘッダーをINTER-Mediatorで使う場面として、<span xmlns="" id="ix-28"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Web APIを作成するような場合があります。任意のクライアントからWeb APIを利用できるようにこのヘッダーの指定が必要になります。もしくは、定義ファイルを複数のサーバーで分散処理する場合にもこのヘッダーを利用する必要があります。INTER-Mediatorが扱う分散処理の例として、ページファイルのサーバーと定義ファイルのサーバーが異なるURLになる場合があります。そのような場合にはこのヘッダーの設定を利用して、ページファイルのURLからの要求を定義ファイルを供給する側のサーバーで許可するように設定します。</p><h3><span id="H3-ANC-8"><span style="display:none">→</span></span>セクションのまとめ</h3><p>　Webアプリケーションは、「サーバー側を誰もが自由に参照したり改変することはできない」という前提のもとで、セキュリティ対策を行っています。つまり、Webサーバーにログインできるユーザーを制限することが大前提です。また、データベースを利用するためのユーザーについても、余分な処理をできないようにしておくことで、他の問題が発生してもセキュリティが確保される確率は幾分は高くなるでしょう。</p><!-- ============ SECTION START ============ --><h2><span id="H2-ANC-2"><span style="display:none">→</span></span><span class="sectionnumber">7-2</span>ユーザー認証とアクセス権適用を行う仕組み</h2><p class="section-lead">INTER-Mediatorは従来形式のWebアプリケーションと違い、クライアントサイドでの処理がむしろ主になっています。認証とアクセス権適用の考え方については、クライアントとサーバーでの役割が従来とは異なります。ただし、アプリケーション利用者にとっては違いがないようになっています。このセクションでは、INTER-Mediatorの認証やアクセス権の機能に加えて、その実現に必要なことを説明します。</p><h3><span id="H3-ANC-9"><span style="display:none">→</span></span>認証とアクセス権</h3><p>　改めて、「<span xmlns="" id="ix-29"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>認証（Authentication）」についての定義を記載します。認証は、利用者の特定を行い、アカウントが確定することです。ユーザー名とパスワードを入力するのが認証の代表的な手法です。何らかの方法で、アカウント、つまりシステムに記録された利用者のどれかを確定することが認証で実現されることです。もちろん、他のアカウントになりすましたり、他のアカウントとして振るまえてしまうということがないようにする必要があります。ユーザー名とパスワードを使う方式ではさまざまなセキュリティ的なリスクがありますが、一番大きいものが「<span xmlns="" id="ix-30"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-31"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>パスワードの漏洩」です。言い換えれば、パスワードはそのアカウントに対応する人しか知りえないという前提の下で成り立つセキュリティの確保の手法です。</p><p>　「<span xmlns="" id="ix-32"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>アクセス権（Authorization）」は、「認可」とも呼ばれます。通常は認証によって確定したアカウントに対する処理範囲の制限を行う機能です。制限は、アプリケーション開発者やあるいはシステム管理者によって指定されます。一般には、特定の処理だけに制限するような設定、ないしは特定のアカウントに対してだけ特定の処理の許可を与えるといった設定が可能です。アクセス権についてのセキュリティ的なリスクとしては、もちろん、フレームワークのバグや、バックドアなどのアクセス権回避手段が存在しないといった、フレームワークの実装面のことがあります。また、アクセス権の設定は複雑になりがちであり、設定のミスが起こりやすいとも言えるので、作成したアプリケーションの十分な実証テストは欠かせません。</p><h3><span id="H3-ANC-10"><span style="display:none">→</span></span>アカウントとグループ</h3><p>　INTER-Mediatorは、<span xmlns="" id="ix-33"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>アカウントとして「<span xmlns="" id="ix-34"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ユーザー」「<span xmlns="" id="ix-35"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>グループ」、そして内部的なアカウントとして「クライアント」の3種類をサポートします。グループは、ユーザーの集合ではありますが、グループにグループを所属させることができます。ユーザーは自分が所属するグループの一覧を得て、アクセス権の適用を受けます。</p><p>　ユーザーのアカウントを記録する方法としては、アプリケーションが利用するデータベースに含まれるテーブルあるいはビューを利用する方法（<span xmlns="" id="ix-36"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ユーザー認証）が基本です。また、外部の認証サーバを利用するSAML認証にも対応していますが、その場合でも利用するデータベースでのユーザー用テーブルは必須となります。</p><p>　一方、グループについては、INTER-Mediator側で定義したものだけが指定できます。データベースエンジン側で定義したものに対してのアクセス権設定はできません。ユーザー認証時はもちろん、ネイティブ認証時にもアプリケーションが利用するデータベースにグループを管理するためのテーブルを定義し、そのグループレコードの利用のみです。</p><p>　<span xmlns="" id="ix-37"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-38"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>クライアントのアカウントは、通信のやり取りが発生したときにINTER-Mediatorによって自動的に割り振られるコードです。専用のテーブルは不要ですが、認証のための情報を記録するテーブルのひとつのフィールドとして記録されます。このクライアントコードを利用して、クライアント、正確には「ブラウザーのウインドウ」を識別しますので、同じページを同一のブラウザの別々のタブで表示していても、クライアントとしては別々のものとして認識しています。</p><h3><span id="H3-ANC-11"><span style="display:none">→</span></span><span xmlns="" id="ix-39"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-40"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ユーザーのテーブル</h3><p>　利用するデータベースでは、ユーザーのテーブルが必要です。既定のテーブル名は「<span xmlns="" id="ix-41"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>authuser」としています。この名前は設定で別のものにもできますが、以下、特定しやすいように、ユーザーアカウントのテーブルはauthuserテーブルと呼ぶことにします。なお、テーブル名は任意の名前を指定できますが、フィールド名は決められたもののを使用する必要があります。表7-2-1に必要なフィールドを記述します。認証だけならテーブル自体は読み込みのみのアクセス権でも構いませんが、パスワードの変更をログインパネル上で行う場合には、パスワードのフィールドは書き込み可能である必要があります。また、テーブルの内容をアプリケーションで追加編集する場合には、一般には読み出しだけでなく変更や追加、削除の権限も必要になります。サポートするデータベースのサンプルファイルあるいはサンプルスキーマには、authuserテーブルそのものあるいは生成コマンドが含まれているので、自分で作成するアプリケーションの場合はその部分をコピーすると良いでしょう。</p><div class="table"><table><tr><th>フィールド名</th><th>型の例</th><th>説明</th></tr><tr><td>id</td><td>INT AUTO_INCREMENT</td><td>連番の数値を入れて、キーフィールドとする</td></tr><tr><td>username</td><td>VARCHAR(48)</td><td>ユーザー名（重複した名前が定義されないようにする）</td></tr><tr><td>hashedpasswd</td><td>VARCHAR(72)</td><td>パスワードのハッシュ値（パスワード変更があるなら要書き込み）</td></tr><tr><td>email</td><td>VARCHAR(100)</td><td>ユーザーのメールアドレス（メールアドレスをユーザー名にするときには必須）</td></tr><tr><td>limitdt</td><td>DATETIME</td><td>SAML認証で必要。キャッシュしたアカウントの期限</td></tr></table><div class="caption">表7-2-1　authuserテーブルのフィールド</div></div><p>　<span xmlns="" id="ix-42"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>パスワードのフィールドには、パスワードはそのまま入れずに<span xmlns="" id="ix-43"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ダイジェスト関数によって処理された値を使います。当初はSHA-1を利用していましたが、セキュリティ上の問題が内在されておりSHA-1の利用自体が問題視される状態になったので、Ver.8でSHA-256に対応しました。なお、認証におけるセキュリティ的な問題は、ダイジェスト関数の脆弱性によるものだけでなく、むしろディクショナリ攻撃や不味い運用（全員同じパスワードなど）によるものの方が深刻であると考えられるものの、SHA-1を使っているというだけでセキュリティ上の問題と判断される風潮でもあるので、SHA-2ベースに移行しました。SHA-1を使っている状態を「認証バージョン1」、その後に改訂してSHA-256を使っている状態を「認証バージョン2」と称することにします。Ver.11現在、過去との互換性を考慮して、既定値は認証バージョン1になっています。新たにアプリケーションを構築する場合は特に縛りはないと思われるので、認証バージョン2での運用をお勧めします。なお、認証バージョン2で運用している場合でも、以前のアプリケーションでバージョン1のみで運用していた時代のauthuserのレコードはそのまま認証で使えます。</p><p>　パスワードのハッシュ値の計算方法は以下のとおりです。独自に生成する場合には、saltを常に異なる値にすることが必要です。なお、JavaScript側のライブラリの制約により、パスワードおよびsaltはASCII文字として表現可能な範囲にします。コントロールコードや漢字は利用しないようにします。シェルスクリプトで生成する場合のサンプルは、INTER-Mediatorのレポジトリにあるdist-docs/usergenerator.shを参照してください。</p><div class="code"><div class="caption">リスト7-2-1　hashedpasswdフィールドの値の求め方</div><pre><code>pw：パスワード
salt：4バイトのソルト値
hash()：認証バージョン1ではSHA-1、認証バージョン2ではSHA-256を5000回繰り返しによるダイジェスト値を求める関数
hex()：16進法による表記に変換する関数
+：文字列の結合

hashedpasswdフィールドの値 = hex(hash(pw + salt)) + hex(salt)
認証バージョン1は48バイト、認証バージョン2は72バイト</code></pre></div><p>　表7-2-1に示したauthuserテーブルのフィールドは必須のフィールドですが、任意のフィールドを追加してもかまいません。例えば、VARCHAR(20)型のrealnameフィールドに、ユーザーのフルネームを入れておけば、ログインした人の氏名をページ上に表示するようなことにも利用できるでしょう。</p><p>　もし、すでに別の名前でユーザーテーブルが作られているのであれば、SQLデータベースの場合には、authuserビューを定義し、フィールド名はビュー定義のコマンドで別の名前に付け替えるような記述を行えば良いでしょう。FileMakerの場合には、レイアウト名をauthuserにすることで、任意のテーブルを利用できます。ただし、既存のフィールドが作られている場合ではフィールド名が表7-2-1のようになっていない可能性があります。その場合はフィールド名を変更するか、あるいは計算フィールド等フィールドの追加を行い、表に示したフィールドが存在するように見えるようにします。</p><h3><span id="H3-ANC-12"><span style="display:none">→</span></span><span xmlns="" id="ix-44"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-45"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>グループのテーブル</h3><p>　グループを構成するテーブルは2つ必要です。まず、ひとつはグループそのものを定義する「<span xmlns="" id="ix-46"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>authgroup」テーブルです。加えて、ユーザーやグループの所属関係を定義する「<span xmlns="" id="ix-47"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>authcor」テーブルです。いずれも、任意の名前を利用できますが、テーブルの種類を特定する場合、authgroupテーブル、authcorテーブルと呼ぶことにします。表7-2-2と表7-2-3に、必要なフィールドを記述します。</p><div class="table"><table><tr><th>フィールド名</th><th>型の例</th><th>説明</th></tr><tr><td>id</td><td>INT AUTO_INCREMENT</td><td>グループを識別するための番号</td></tr><tr><td>groupname</td><td>VARCHAR(48)</td><td>グループ名</td></tr></table><div class="caption">表7-2-2　authgroupテーブルのフィールド</div></div><div class="table"><table><tr><th>フィールド名</th><th>型の例</th><th>説明</th></tr><tr><td>id</td><td>INT AUTO_INCREMENT</td><td>レコードを識別するための番号</td></tr><tr><td>user_id</td><td>INT</td><td>所属するユーザーのidフィールドの値</td></tr><tr><td>group_id</td><td>INT</td><td>所属するグループのidフィールドの値</td></tr><tr><td>dest_group_id</td><td>INT</td><td>所属されるグループのidフィールドの値</td></tr></table><div class="caption">表7-2-3　authcorテーブルのフィールド</div></div><p>　authgroupテーブルは単にグループ名とid番号の割り当てのためのものです。グループへの所属関係を記録するauthcorテーブルのひとつのレコードでは、user_idフィールドもしくはgroup_idフィールドのどちらかを入力し、一方はNULL（FileMakerでは""）にします。これらのフィールドには、authuserおよびauthgroupテーブルのidフィールドの値を設定します。dest_group_idフィールドにはauthgroupテーブルに存在するidフィールド値を指定します。ユーザー名やグループ名を指定するのではありません。</p><p>　例えば、{user_id: 1, group_id: NULL, dest_group_id: 101}といったレコードがあれば、authuserテーブルのid=1のレコードが示すユーザーが、authgroupテーブルのid=101というグループに所属することを意味します。また、autugroup_id=3のグループがauthgroupテーブルのid=101というグループに所属することは、{user_id: NULL, group_id: 3, dest_group_id: 101}と言ったレコードで記述します。</p><h3><span id="H3-ANC-13"><span style="display:none">→</span></span><span xmlns="" id="ix-48"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-49"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ユーザーレコード生成のためのスクリプト</h3><p>　データベースのスキーマを読み込む段階で、すでにいくつかのユーザーを作っておきたい場合もあるでしょう。もちろん、自分でハッシュを計算することで可能ですが、INTER-Mediatorには、macOSあるいはLinuxで利用できるユーザーレコード作成のコマンドが用意されています。INTER-Mediatorフォルダー内のdist-docsフォルダー内にある「<span xmlns="" id="ix-50"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>passwdgen.sh」というシェルスクリプトです。</p><p>　このシェルスクリプトを使えば、hashedpasswdフィールドの値を求め、場合によっては、<span xmlns="" id="ix-51"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>SQLステートメントの形式で得られます。INTER-Mediator/dist-docsがカレントディレクトリにあるとして、例えばリスト7-2-2のようにコマンド入力できます。行の最初に$があるのがコマンド入力行です。最初のコマンド例は、引数として--userでユーザー名、--passwrodで<span xmlns="" id="ix-52"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>パスワード文字列を指定しており、出力は、CSVファイルの形式で、ユーザー名、パスワード、hashedpasswdフィールドの値の順に表示されます。ソルトは乱数で生成しています。2つ目のコマンド例は、さらに、--sqlを引数に指定しており、これにより、SQLステートメントの形式で出力をしています。なお、ハッシュ値の計算は、認証バージョン2に対応したものです。opensslで5000回のハッシュ計算を内部的には行えず、コマンドを5000回処理しているので、スクリプトの処理にはちょっと時間がかかります。</p><div class="code"><div class="caption">リスト7-2-2　passwdgen.shスクリプトの利用例</div><pre><code>$ ./passwdgen.sh --user=test --password=testpassword
'test','testpassword','07559ce0fc95e44760dcb9a7794060ab740aad861b41f12b0a4856323d6e3b4c677a6867'
$ ./passwdgen.sh --user=test --password=testpassword --sql
INSERT authuser(username,initialpass,hashedpasswd) INSERT authuser(username,initialpass,hashedpasswd) VALUES('test','testpassword','a1ec3bb4e914822a35427c0fce3e25a43e86dbbc753ca525488bc9d8426df5f4636e6246');</code></pre></div><p>　一方、CSVファイルを用意して、そのファイルを「./passwdgen.sh --sql --csv=CSVファイルのパス」のように指定すると、上記の処理をCSVファイルから取り出して行うので、多数のユーザー用のSQLステートメントを生成できます。CSVファイルは1列目がユーザー名、2列目がパスワードです。カンマで区切りますが、それぞれのフィールドは、シングルクォートやダブルクォートで囲っても構いませんし、囲わなくても構いません。</p><p>　同じフォルダーに、<span xmlns="" id="ix-53"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>usergenerator.shというスクリプトファイルもあり、こちらは、パスワードの自動生成などを行います。なお、引数は特に取りません。なお、これらのスクリプトでは不満がある場合もあるかもしれません。いずれもシェルスクリプトですので、必要に応じて改良して使ってください。また、スクリプトのソースはユーザー自動生成の方法の参考になると思います。</p><h3><span id="H3-ANC-14"><span style="display:none">→</span></span><span xmlns="" id="ix-54"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-55"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ハッシュ値用テーブルの内容</h3><p>　認証を行う場合、ユーザとグループのテーブルだけでなく、表7-2-4に示すテーブルが必要です。このテーブル名についてもカスタマイズは可能ですが、ここでは既定値の「<span xmlns="" id="ix-56"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>issuedhash」テーブルと呼ぶことにします。通信を行うたびにレコードを生成するので、1回のページ表示でたくさんのレコードを作成します。そのため、このテーブルをFileMakerで運用するにはパフォーマンス上の問題が発生しますが、FileMaker Serverで運用しつつ、<span xmlns="" id="ix-57"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-58"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>issuedhashテーブルのみをSQLiteで運用するということもできるようになっています。FileMakerではこの方法により、パフォーマンスを大きく損なうことなく認証処理ができるようになっています。</p><div class="table"><table><tr><th>フィールド名</th><th>型の例</th><th>説明</th></tr><tr><td>id</td><td>INT AUTO_INCREMENT</td><td>レコードを識別するための番号</td></tr><tr><td>user_id</td><td>INT</td><td>authuserテーブルのキーフィールドとなるid値</td></tr><tr><td>clienthost</td><td>VARCHAR(64)</td><td>クライアントを識別する自動生成されるコード</td></tr><tr><td>hash</td><td>VARCHAR(64)</td><td>チャレンジに使うハッシュ値。実際には24バイトの16進数文字列</td></tr><tr><td>expired</td><td>DateTime</td><td>チャレンジの有効期限を示すタイムスタンプ値</td></tr></table><div class="caption">表7-2-4　issuedhashテーブルのフィールド</div></div><p>　このテーブルの意味を理解するには、INTER-Mediatorのクライアントサーバー間でのプロトコルを理解する必要があります。ここで解説は行いますが、機能を利用する上ではこの仕組みまで知る必要はありません。セキュリティのアセスメントが必要な方はソースコードを分析して理解してください。</p><h3><span id="H3-ANC-15"><span style="display:none">→</span></span>INTER-Mediatorの認証プロトコル</h3><p>　INTER-Mediatorの認証プロトコルは、『7-3　認証とアクセス権の設定』の『定義ファイルでの設定』で説明する、<span xmlns="" id="ix-59"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>storingの設定に依存します。この設定は当初は、coockieおよびcookie-domainの設定しかできず、クッキーを利用した認証のみでした。その後にsession-storageを利用した認証が加わりましたが、その後にセキュリティ面を見直して、「<span xmlns="" id="ix-60"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>credential」という設定を追加しました。原則として、これらの設定はいずれも使用は可能ですが、現在はもっともセキュリティへの配慮が進んだcredentialを使ってください。以下の説明も、基本的はcredentialを使った上での説明を中心とします。credentialは、http-onlyのクッキーを使った手法です。初期からある方法とは大きく異なり、認証を成立させる方法を、クライアント側のJavaScriptから一切取り出せないようにすることを意図した手法です。</p><p>　表7-2-5は、クライアントからサーバーに対してデータベースアクセス等の要求がある場合のやり取りに、認証情報がどのように関わるかを示したものです。storingがcredential以外の手法は、常にこのプロトコルに従いますが、credentialの場合にはこのプロトコルは認証パネルを出して、最初に認証するときのみに利用されれます。変数名と計算方法はリスト7-2-3に示します。単にアクセス要求と応答があるのではなく、チャレンジ要求が最初にあり、チャレンジをもとに要求を出したときに、サーバー側で認証が判定されるという点が大きな流れです。もちろん、認証が成立したら、データベースから取り出したデータを返したり、更新処理に入ります。認証が成立しなければ、ログインパネルを再度表示し、このプロトコルを最初からやり直します。</p><div class="table"><table><tr><th>クライアント側での処理</th><th>転送される認証情報</th><th>サーバー側での処理</th></tr><tr><td>チャレンジ要求</td><td>→user→</td><td>データベースよりhpwを取得しsaltを求める</td></tr><tr><td/><td/><td>chを乱数より生成，cidが未発行なら乱数で生成</td></tr><tr><td/><td/><td>user, cid, ch, 日付時刻をデータベースに記録</td></tr><tr><td>resを求める</td><td>←salt, cid, ch←</td><td/></tr><tr><td>データベース要求</td><td>→cid, user, res→</td><td>issuedhashテーブルより，cidからチャレンジを取得</td></tr><tr><td/><td/><td>res'を計算し、resと同じなら認証成立</td></tr></table><div class="caption">表7-2-5　認証を伴う処理の場合のINTER-Mediatorプロトコル</div></div><div class="code"><div class="caption">リスト7-2-3　変数と式</div><pre><code>user：ユーザー名（ユーザーが入力）
pw：本来のパスワード（ユーザーが入力）
salt：ユーザーごとに異なるソルト（4バイトのASCII文字）
hpw：データベースに保存されているパスワードのハッシュ値
pw'：入力したパスワード
cid：クライアントid（16進数で記述）
ch：サーバーから送られるチャレンジ（16進数で記述）
res：クライアントから送られるレスポンス
res'：サーバー側の情報から得られるレスポンスの期待値
hash()：認証バージョン1ではSHA-1、認証バージョン2ではSHA-256を5000回繰り返しによるダイジェスト値を求める関数
hmac(k, m)：HMAC-SHA256で求められるMAC値を求める関数。ハッシュ関数はSHA-256，鍵がk，メッセージがm
hex(m)：16進法による表記に変換する関数（hex(m) + hex(n) = hex(m + n)が成り立つ）
+：文字列の結合

hpw = hash(pw + salt) + salt
res = hmac(hash(pw' + salt) + salt, ch)
res' = HMAC(hpw, ch) = hmac(hash(pw + salt) + salt, ch)
pw = pw' であれば res' = res となる</code></pre></div><p>　まず、ログインパネルでユーザー名とパスワードを入力します。そして、ユーザー名（user）をサーバーに送ります。サーバー側では、そのユーザーのパスワードハッシュ値（hpw）とidフィールドの値をauthuserテーブルから取得します。hpwの最後の8バイトからソルト（salt）が得られます。そして、クライアントid（cid）とチャレンジ（ch）を乱数で生成します。そして、issuedhashテーブルにレコードを作成して、ユーザーのid値、cid、ch、日時を記録します。クライアントへは、応答としてsalt、cid、chを送ります。クライアントはデータベースの要求に加えてres値を計算して、サーバーへの要求に付加します。res値は、応答で得られた値と、入力したパスワードから求めておきます。また、要求にはuser、cidも返します。要求を受け取ったサーバーは、issuedhashテーブルを検索して、chを求めます。そして、ユーザー名から得られるsalt、返されたcidをもとに、res'を計算します。このres'がresと等しければ、クライアント側で正しいパスワードが入力されたと判断できるということです。resとres'は、式の上ではpwとpw'の部分だけが違います。</p><p>　この手法の大きな特徴は、ネットワーク上に流れるデータからパスワードを求めることができないということです。ネットワーク上のデータは、user、salt、cid、ch、resであり、これらの値からパスワード自体を求めることはできません。ハッシュ値hpwをデータベースに保存はしますが、パスワードはもちろん、そのハッシュ値自体もネットワーク上を流れないということです。この一連の作業で使われるチャレンジ（ch）は、サーバー側では共有しません。原則として1回のやり取りの間だけ有効になり、リクエストがあるたびに生成をします。したがって、resの値は要求ごとに異なる値になります。</p><p>　クライアントid（cid）については、可能な限り再利用を行います。この認証だけなら、cidでなくても認証はできそうに見えるかもしれませんが、同一ユーザーで同時に複数のページを利用している場合があることを考えれば、チャレンジ要求とデータベース処理要求を結びつける意味では必要です。</p><p>　なお、認証をすれば通常は1回の通信が2回へと倍になるのではないかと思われるかもしれませんが、より効率的な動作をします。データベース処理に対する応答には、次の要求のためのチャレンジ（ch）などのデータがすでに含まれていて、2回目以降は、データベースの応答と次のチャンレンジ応答を1回の応答で済ませてしまいます。したがって、認証がない時にn回の通信をする場合、認証があればn+1回の通信を行うことになり、1回、つまり最初のチャレンジ要求だけが増えることになります。</p><p>　storingにcredentialを指定した場合は、認証成立後に、http-onlyのクッキーがサーバから送られてクライアントに記録されます。クッキーの値は、その時のチャレンジ、クライアントid、ユーザパスワードのハッシュ値を合成した文字列に対するSHA-256のハッシュ値を求めています（sha256(ch + cid + (hash(pw + salt) + salt)）。クッキーに記録されたので、次にまたサーバを利用する時にはその値がサーバに送られます。そして、サーバーで値が正しいものかを判定し、正しければ認証が成立したものとみなします。前の応答では、{cid, ch, user} がissuedhashテーブルに記録されているので、cidを元に残されたデータを検索して、クッキーで送り込まれたハッシュが正しいものかは判定できます。なお、ユーザ名は応答に入れてありますが、issuedhashテーブルのレコードの検索に利用するので、クライアント側でユーザ名を書き換えれば異なるチャレンジを想定していることになり認証は成立しません。応答時には、また新しいチャレンジが生成されるので、クライアントに送り込むクッキーも新しいものが生成されます。</p><p>　このように、credentialを使った認証ではJavaScript側からクッキーを取り出したりあるいは書き込むことができないことから、何らかの方法でXSS等で第三者によるコード実行ができたとしても、認証に使うクッキーには手を出せない状態になっています。もちろん、第三者によるコード実行はできないようにしておくのが基本です。</p><p>　ログインパネルが表示された場合、そこにパスワードは打ち込まれる必要があります。そしてそれはプログラム処理するために変数に設定される必要がありますが、ローカル変数に設定されるため、時間的には即座に消えると考えてください。パスワードを取得したら、即座にresの値を求めますが、認証が成功すると、プロパティに置いたresはそこでクリアします。したがって、認証が成功したら、パスワード、そしてパスワードのハッシュ（hpw）、認証で利用するresの値は全部消されます。XSSによる第三者コードを使ってパスワードなどが、JavaScriptのコードを通じて盗まれる可能性はかなり低いと言えるでしょう。もちろん、第三者のコードが実行される機会がなければ、パスワードやハッシュ値は横取りされる心配はないと言えるでしょう。</p><h3><span id="H3-ANC-16"><span style="display:none">→</span></span><span class="exsign">演習</span><span xmlns="" id="ix-61"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-62"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ユーザー管理の簡易アプリケーションを使ってみる</h3><p>　INTER-Mediatorにはauthuser, authgroup, authcorテーブルの内容を編集する簡易アプリケーションが付属しています。テーブルの定義は必要ですが、それに加えて、このアプリケーションをベースにして、独自のユーザー管理アプリケーションを作成することもできるでしょう。この演習では、単にアプリケーションの存在と動作の確認だけ行います。実際の利用は、この後のセクションで何度か出てきます。</p><h4>ユーザー管理アプリケーションを参照する</h4><div class="step"><span class="stepnumber">1</span>演習環境を利用して、認証に利用するユーザなどのデータがどのようにデータベースに格納されているのかを確認します。ブラウザーで、「http://localhost:9080」に接続します。</div><div class="step"><span class="stepnumber">2</span>ページ内にある「トライアル用のページファイルと定義ファイル」というタイトルの部分を特定します。「ユーザー管理ページサンプル」というタイトルの部分をクリックします。</div><div class="step"><span class="stepnumber">3</span>ユーザー名とパスワードを入力するパネルが表示されるので、ユーザーに「user1」、パスワードに「user1」と入力して、「ログイン」ボタンをクリックします。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-296.png"/></div><div class="step-wo-number">このアプリケーションは「認証が通れば参照して変更できる」ようになっていますが、一般には、こうしたアプリケーションのユーザー管理機能は特定のグループのユーザーだけが参照し変更できるようにするのが安全な利用方法です。</div><div class="step"><span class="stepnumber">4</span>ページが表示されました。「User Accounts」と「Group Accounts」の2つのテーブルが表示されています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-297.png"/></div><div class="step-wo-number">パスワードの変更はこの段階では行わないでください。変更するには、ページ冒頭にある「New Password」の右にあるテキストフィールドにパスワードを入力して、User AccountsのHashed Password列の該当するユーザーの「Set」ボタンをクリックします。この操作により、ソルトの自動生成やハッシュ値の計算などを自動的に行って、hashedpasswdフィールドへ正しい値を設定します。</div><h4>設計内容を確認する</h4><div class="step"><span class="stepnumber">1</span>このアプリケーションの定義ファイルを参照します。GitHubにあるソースコードを参照しましょう。<a href="https://github.com/INTER-Mediator/INTER-Mediator/blob/master/samples/Auth_Support/MySQL_contexts.php" target="_blank">こちら</a>をクリックして、内容を参照します。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-300.png"/></div><div class="step"><span class="stepnumber">2</span>認証の設定は次のセクションで説明します。ここでは関連テーブルの内容の把握が主な目的です。定義ファイルを見ると、次の5つのコンテキストが定義されています。nameキーの値と、（）内にはviewおよびtableキーの値をピックアップしました。また、relationキーの有無も記載しました。</div><ul><li>authuser（view/table=authuser）</li><li>belonggroup（view/table=authcor）relation有り</li><li>groupname（view/table=authgroup）</li><li>authgroup（view/table=authgroup）</li><li>groupingroup（view/table=authcor）relation有り</li></ul><div class="step"><span class="stepnumber">3</span>ページの最初の方に、このファイルへのパス「INTER-Mediator/Auth_Support/MySQL_contexts.php」が見えている箇所があります。ここで、「Auth_Support」をクリックすると、Auth_Supportフォルダーの内容が表示されます。そこにあるページファイルの「MySQL_accountmanager.html」をクリックして、MySQL_accountmanager.htmlファイルの中身を表示します。</div><div class="step"><span class="stepnumber">4</span>User Accountsの見出しの下のテーブルを見てみます。authuserコンテキストのusernameやhashedpasswdフィールドなどが見えています。また5列目は、belonggroupコンテキストがSPANタグで展開されていますが、SELECTタグによるポップアップメニューは、belonggroupコンテキストの関連レコードdest_group_idを表示するようになっています。また、ポップアップメニューの選択肢はgroupnameコンテキストにより、authgroupテーブルのすべてのレコードが表示されています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-298.png"/></div><div class="step-wo-number">5列目は、結果として、そのユーザーが所属するグループの数だけポップアップメニューが並びます。つまりひとつのリピーターにひとつのポップアップメニューがあるので、該当するauthuserテーブルのidフィールドと同じ値をauthcorテーブルのuser_idフィールドに持つ関連付けられたレコードの数だけ繰り返されます。dest_group_idフィールドはauthgroupテーブルのidフィールドの値が入力されていますが、実際のグループ名に変換するのはポップアップメニューの仕組みを使っています。この点は、このすぐ後にauthcorテーブルの内容を確かめるので、その時に改めて内容を確認すると良いでしょう。</div><div class="step-wo-number">authuserコンテキストのbelongingフィールドは、元のテーブル定義にはありません。これは、サーバー側のPHPプログラム（同じフォルダーにあるUserList.php）によって、検索後にサーバーサイドの処理で付加されたフィールドです。この仕組みは、『Chapter 8　サーバーサイドでのプログラミング』で説明します。</div><div class="step"><span class="stepnumber">5</span>スクロールして、Group Accountsの見出しの下のテーブルを見てみます。authgroupコンテキストのgroupnameフィールドが見えています。2列目は関連付けられたgroupingroupコンテキストのdest_group_idフィールドの値を持つポップアップメニューが定義されています。そして、ポップアップメニューの選択肢はgroupnameコンテキストから得ています。2列目のポップアップメニューは、User Accountsテーブルの5列目と同様な構成になっています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-299.png"/></div><h4>ユーザーとグループの対応関係を確認する</h4><div class="step"><span class="stepnumber">1</span>「ユーザー管理ページサンプル」をクリックして表示した、ユーザー管理アプリケーションのページを表示します。通常は、以前に開いたタブあるいはウインドウがあるので、それを呼び出せば良いでしょう。</div><div class="step"><span class="stepnumber">2</span>User Accountsのうち、Groupsの列を見て、group1に含まれているのは、user1とuser2、user3の3つのアカウントであることを確認します。</div><div class="step"><span class="stepnumber">3</span>Group Accountsのgroup1は、さらにgroup3に含まれていることを確認します。</div><div class="step"><span class="stepnumber">4</span>User Accountsの中で、user1とuser2、user3は、Groupsの列を見る限りはgroup1にしか登録されていません。しかしながら、Belongingsの列を見ると、group1とgroup3に含まれていることになっています。つまり、group1に含まれるユーザーは自動的にgroup3にも含まれることになります。</div><div class="step"><span class="stepnumber">5</span>逆にgroup3に含まれるユーザーは、Belongingsの列にgroup3があるユーザーで、user1〜user5が相当します。言い換えれば、group3に対してアクセス権を与えることで、user1〜user5に与えるということができます。</div><div class="step"><span class="stepnumber">6</span>このように、グループは単にユーザーの分類ではなく、グループを所属させることによる階層的な構成をとることもできます。authuserとauthgroupテーブルの内容は、ページファイルに見える通りですが、authcorテーブルはこの状態では以下のような内容です。なお、フィールドの内容は実際にはidの整数値ですが、それだと分かりにくいので、対応するusernameあるいはgroupnameフィールドの値を（）で付記しました。</div><div class="table"><table><tr><th>user_id</th><th>group_id</th><th>dest_group_id</th></tr><tr><td>1（user1）</td><td>NULL</td><td>1（group1）</td></tr><tr><td>2（user2）</td><td>NULL</td><td>1（group1）</td></tr><tr><td>3（user3）</td><td>NULL</td><td>1（group1）</td></tr><tr><td>4（user4）</td><td>NULL</td><td>2（group2）</td></tr><tr><td>5（user5）</td><td>NULL</td><td>2（group2）</td></tr><tr><td>4（user4）</td><td>NULL</td><td>3（group3）</td></tr><tr><td>5（user5）</td><td>NULL</td><td>3（group3）</td></tr><tr><td>NULL</td><td>1（group1）</td><td>3（group3）</td></tr></table><div class="caption">表7-2-6　authcorテーブルの値</div></div><h4>演習のまとめ</h4><ul><li>INTER-Mediatorでの認証やアクセス権設定に使うテーブル、authuser、authgroup、authcorの関係を確認しました。</li><li>これらのテーブルのデータ処理を行えるWebアプリケーションがあるので、実際のアプリケーション開発ではこれを元にユーザー管理機能を構築すると良いでしょう。</li></ul><h3><span id="H3-ANC-17"><span style="display:none">→</span></span>セクションのまとめ</h3><p>　INTER-Mediatorでの認証やアクセス権設定では、ユーザーやグループを使用します。それらは、authuser、authgroup、authcorのそれぞれのテーブルに記録しておくのが基本です。これらのテーブルの内容を編集するためのWebアプリケーションがINTER-MediatorのレポジトリのAuth_Supportフォルダーに作られています。さらに、認証をチャレンジ-レスポンスによって行うためのissuedhashテーブルも必要です。認証のための通信では、パスワードやそのパスワードから求められてデータベースに記録されたハッシュ値を通信経路上に流すことなく、認証が行われます。</p><!-- ============ SECTION START ============ --><h2><span id="H2-ANC-3"><span style="display:none">→</span></span><span class="sectionnumber">7-3</span>認証とアクセス権の設定</h2><p class="section-lead">認証やアクセス権に対する設定は、params.phpファイルや定義ファイルに行います。これらの設定は、原則としてJavaScriptでカスタマイズすることはできません。言い換えれば、設定はクライアント側から変更することを一切できないようにすることで、セキュリティの確保を行っています。このセクションでは、設定方法と設定例を説明します。</p><h3><span id="H3-ANC-18"><span style="display:none">→</span></span><span xmlns="" id="ix-63"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-64"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>認証バージョンの指定</h3><p>　認証バージョンの指定については、<span xmlns="" id="ix-65"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>params.phpファイルで行います。このファイルを利用した設定の全体像については、『2-6　設定ファイルparams.php』で説明します。params.phpファイル内では、以下のような認証に関連する変数設定を行う箇所があります。ここで、<span xmlns="" id="ix-66"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>$passwordHash変数の行の頭の//を削除して、変数定義を有効にし、=の右側の値を '2' にすることで認証バージョン2で稼働します。新規に稼働するアプリケーションの場合には、 '2' に設定しておくのが良いでしょう。</p><div class="code"><div class="caption">リスト7-3-1　params.phpファイルの一部で認証バージョン指定等の箇所</div><pre><code>/* Authorization
 * =================== */
//$passwordHash = '1';  // '2m' supports SHA-256 and Wrapping SHA-1 with SHA-256,
// '2' supports SHA-256 password hash only,
// No specification or other string support SHA-1, SHA-256, and wrapping.
//$alwaysGenSHA2 = true; // On the password changing, generate SHA-2 hash. The default is false.
//$migrateSHA1to2 = true;// If the login account relays on SHA-a, exchange it with 2m style SHA-2 hash. The default is false.
//$credentialCookieDomain = ""; // The domain information of the cookie for 'credential' auth. Falsy value means no domain, also the default.
</code></pre></div><p>　ここで、以前から認証バージョン1で運用したシステムを利用している方向けの情報を記述します。$passwordHashの値を無指定、あるいは1にすると、認証バージョン1で稼働するのはもちろんですが、認証バージョン2およびそれらの中間とも言えるマイグレーションモードでの稼働も行うようになっています。$passwordHashを'2m'にすると、マイグレーションモード、'2'にすると認証バージョン2のみでの運用となります。</p><p>　<span xmlns="" id="ix-67"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>マイグレーションモードは、文字とおり、SHA-1とSHA-2との混在を示しています。ハッシュ値自体はSHA-1のものを利用しますが、通信上ではSHA-2によるハッシュを行うため、全面的にSHA-1ではないという状態です。ユーザのデータベースをそのままに可能な限りSHA-2で運用するというモードです。</p><p>　認証バージョン1で運用しているときに、<span xmlns="" id="ix-68"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>$alwaysGenSHA2をtrueにする、つまりparams.phpのこの変数の定義部分のコメントを外すと、パスワードの変更を行ったときに、パスワードのハッシュ値は認証バージョン2に対応したものになります。つまり、認証バージョン1で運用を続けるものの、パスワード変更を行ったユーザはそれ以降はSHA-2対応のハッシュ値で計算がなされるようになります。さらに、変数<span xmlns="" id="ix-69"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>$migrateSHA1to2をtrueにすれば、ログイン成功時に、そのユーザのパスワードはSHA-2に移行します。ログイン時にはパスワードが入力されているので、こうした自動変換が可能です。</p><h3><span id="H3-ANC-19"><span style="display:none">→</span></span>定義ファイルでの設定</h3><p>　認証やアクセス権に関する設定は、定義ファイルで行います。JavaScriptのAPIは用意していないので、原則として、すべて定義ファイル側で行うと考えてください。設定項目は多岐に渡ります。まず、リスト7-3-2に示したのは、定義ファイルのPHPによる記述で記述可能なキーをすべて示したものです。それぞれのキーに対する設定内容は、後で示します。IM_Entry関数の最初の引数（コンテキスト定義）に指定するコンテキスト定義に設定する項目があり、加えてIM_Entry関数の第2引数（オプション設定）に指定する項目もあります。</p><div class="code"><div class="caption">リスト7-3-2　定義ファイルでの認証やアクセス権設定の場所</div><pre><code>IM_Entry(
	array(	//コンテキスト定義
		array(	
			"name"=&gt;"context",	// コンテキスト名
			"authentication"=&gt;array(
				"all" =&gt; array(
					"user" =&gt; array( .... ),
					"group" =&gt; array( .... ),
					"target" =&gt; "....",
					"field" =&gt; "....",
				),
				"read" =&gt; array(
					/* "all" と同様 */
				),
				"update" =&gt; array(
					/* "all" と同様 */
				),
				"create" =&gt; array(
					/* "all" と同様 */
				),
				"delete" =&gt; array(
					/* "all" と同様 */
				),
			),
			"protect-writing" =&gt; array( .... ),
			"protect-reading" =&gt; array( .... ),
		),
	),
	array(	//オプション設定
		"authentication"=&gt;array(
			"user" =&gt; array( .... ),
			"group" =&gt; array( .... ),
			"user-table" =&gt; "string",
			"group-table" =&gt; "string",
			"corresponding-table" =&gt; "string",
			"challenge-table" =&gt; "string",
			"authexpired" =&gt; "string",
			"storing" =&gt; "cookie|cookie-domainwide|session-storage|credential",
			"realm" =&gt; "string",
			"email-as-username" =&gt; "boolean",
			"issuedhash-dsn" =&gt; "string",
		),
	),
....);</code></pre></div><p>　定義ファイルエディターでのコンテキスト内の設定は図7-3-1のようなもので、「Show All」ボタンをクリックすることで表示されます。最初の状態では認証関連の設定は見えていません。このうち、リスト7-3-3で、「array(...)」つまり配列で指定が必要な項目については、半角のカンマ（,）で区切ってテキストを記述することで、それぞれを要素とする配列をキーに対する値として設定します。設定値については、表7-3-1に示します。表に記載の内容も、順次説明します。</p><div class="picture"><img class="picture-small" src="figs/shot3030.png"/><div class="caption">図7-3-1　定義ファイルエディターでのコンテキスト定義内の認証関連設定</div></div><div class="table"><table><tr><th>指定場所</th><th>キー</th><th>キー</th><th>値と動作</th></tr><tr><td rowspan="14">コンテキスト/<span xmlns="" id="ix-70"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>authentication</td><td rowspan="5">all</td><td/><td>CRUDのすべての操作に対する設定をまとめて与える</td></tr><tr><td><span xmlns="" id="ix-71"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>user</td><td>ユーザー名の配列を指定すれば、それらのユーザーのみに許可が与えられる。省略するとすべてのユーザー</td></tr><tr><td><span xmlns="" id="ix-72"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>group</td><td>グループ名の配列を指定すれば、それらのグループのみに許可が与えられる。省略するとすべてのグループ</td></tr><tr><td><span xmlns="" id="ix-73"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>target</td><td>"table"あるいは省略の場合テーブルに対してアクセス権を設定、"field-user"あるいは"field-group"なら次のfieldキーの値で指定したフィールドにあるデータをユーザー名ないしはグループ名として、レコード単位でそのユーザーあるいはグループに対してのみアクセス権を付与する</td></tr><tr><td><span xmlns="" id="ix-74"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>field</td><td>レコード単位のアクセス権設定において、ユーザー名やグループ名が入力されるフィールドの名前</td></tr><tr><td rowspan="2">read</td><td/><td>テーブルからの読み出し（クエリー）に対するアクセス権を設定する</td></tr><tr><td>user/group/target/field</td><td>（"all"の場合と同じ）</td></tr><tr><td rowspan="2">update</td><td/><td>レコードへの更新に対するアクセス権を設定する</td></tr><tr><td>user/group/target/field</td><td>（"all"の場合と同じ）</td></tr><tr><td rowspan="2">create</td><td/><td>テーブルへの新規レコード作成に対するアクセス権を設定する</td></tr><tr><td>user/group/target/field</td><td>（"all"の場合と同じ）</td></tr><tr><td rowspan="2">delete</td><td/><td>テーブルからのレコード削除に対するアクセス権を設定する</td></tr><tr><td>user/group/target/field</td><td>（"all"の場合と同じ）</td></tr><tr><td>media-handling</td><td/><td>trueを指定すると、メディア向けのチャレンジを生成してクライアントに送る</td></tr><tr><td rowspan="2">コンテキスト</td><td><span xmlns="" id="ix-75"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>protect-writing</td><td/><td>フィールド名を配列で指定する。これらのフィールドはクライアントからの<span xmlns="" id="ix-76"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-77"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>更新を受け付けなくなる</td></tr><tr><td><span xmlns="" id="ix-78"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>protect-reading</td><td/><td>フィールド名を配列で指定する。これらのフィールドはクライアントからの<span xmlns="" id="ix-79"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-80"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>読み出しを受け付けなくなる</td></tr></table><div class="caption">表7-3-1　コンテキスト定義内の認証関連設定</div></div><p>　定義ファイルエディターでのオプション設定にある認証関連の設定は図7-3-2のようなものです。こちらにも、userおよびgroupは配列での指定が必要であり、複数の要素を設定する必要がある場合にはカンマで区切って指定します。設定値については、表7-3-2に示します。表に記載の内容も、順次説明します。</p><div class="picture"><img class="picture-small" src="figs/ng-shot-301.png"/><div class="caption">図7-3-2　定義ファイルエディターでのオプション設定内の認証関連設定</div></div><div class="table"><table><tr><th>指定場所</th><th>キー</th><th>値と動作</th></tr><tr><td rowspan="11">オプション/<span xmlns="" id="ix-81"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>authentication</td><td><span xmlns="" id="ix-82"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>user</td><td>ユーザー名の配列を指定すれば、それらのユーザーのみに許可が与えられる。省略するとすべてのユーザー</td></tr><tr><td><span xmlns="" id="ix-83"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>group</td><td>グループ名の配列を指定すれば、それらのグループのみに許可が与えられる。省略するとすべてのグループ</td></tr><tr><td><span xmlns="" id="ix-84"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>user-table</td><td>ユーザーテーブルの名前がauthuserでない場合にここにその名前を指定する</td></tr><tr><td><span xmlns="" id="ix-85"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>group-table</td><td>グループテーブルの名前がauthgroupでない場合にここにその名前を指定する</td></tr><tr><td><span xmlns="" id="ix-86"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>corresponding-table</td><td>グループ対応テーブルの名前がauthcorでない場合にここにその名前を指定する</td></tr><tr><td><span xmlns="" id="ix-87"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>challenge-table</td><td>ハッシュテーブルの名前がissuedhashでない場合にここにその名前を指定する</td></tr><tr><td><span xmlns="" id="ix-88"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>storing</td><td><span xmlns="" id="ix-89"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-90"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>認証情報を記録して再利用する方法を指定する。"<span xmlns="" id="ix-91"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>cookie"ならそのディレクトリ内で共有、"<span xmlns="" id="ix-92"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>cookie-domainwide"は同一ドメイン内で共有、"<span xmlns="" id="ix-93"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>session-storage"はブラウザーのデータベースを利用して共有、"<span xmlns="" id="ix-94"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>credential"は認証情報をhttp-onlyのクッキーに保存する。既定値はcredentialであり、原則として、credentialを利用するように設定する。</td></tr><tr><td><span xmlns="" id="ix-95"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>authexpired</td><td>認証情報の記録の<span xmlns="" id="ix-96"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>タイムアウト。ここで指定した時間、通信がないと認証状態を無効にする。既定値は3600秒</td></tr><tr><td><span xmlns="" id="ix-97"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>realm</td><td><span xmlns="" id="ix-98"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>認証領域名。ログインパネルに表示される。また、認証状態の記録時のキー名に付加される。この文字列には半角のドットは指定しない</td></tr><tr><td><span xmlns="" id="ix-99"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>email-as-username</td><td><span xmlns="" id="ix-100"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-101"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>emailフィールドの値をユーザー名として受け入れる場合にはtrue、省略はfalseと同じ</td></tr><tr><td><span xmlns="" id="ix-102"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>issuedhash-dsn</td><td>isshedhashテーブルが存在するデータベースのDSNを指定する。省略時は他で指定されるデータベースでisshedhashテーブルを運用</td></tr></table><div class="caption">表7-3-2　オプション設定内の認証関連設定</div></div><p>　ユーザーやグループなど、同様な設定がコンテキスト定義にもオプション設定にもあります。もちろん、オプション設定は、定義ファイルで定義したすべてのコンテキストに対して適用されるのに対して、コンテキストへの定義はそのコンテキストだけに適用されるものです。ただし、すべての設定が両方にあるわけではなく、実運用を考慮してオプション設定には全体的な設定、コンテキスト定義には詳細な設定が存在するようにしました。</p><p>　storingキーには多様な選択肢がありますが、Ver.11現在で新たなアプリケーションを開発する場合は、credentialにして、http-onlyのクッキーに認証情報を記録する方法を採用してください。この方法では認証情報はJavaScriptから取得ができなくなり、安全性がいくらか高くなります。それ以外の方法ではJavaScriptから認証情報を取り出せるため、何らかのアタックに引っかかった場合に認証情報が第三者に取り出される可能性はあります。</p><h3><span id="H3-ANC-20"><span style="display:none">→</span></span>設定例による<span xmlns="" id="ix-103"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-104"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>認証の設定</h3><p>　設定の詳細も重要ですが、複雑なので、ここと次のセクションで、用途に応じてどのような設定を行うのかを例で示します。以下の表記は定義ファイルでのPHPでの記述を行います。なお、いずれも、『7-2　ユーザー認証とアクセス権適用を行う仕組み』で説明したテーブルが用意されていて、ユーザーやグループが定義されていることを前提として説明します。</p><h4>すべてのコンテキストで認証が必要</h4><p>　あるページにおいて、認証を必要とするものの、認証さえできれば、ページ内での読み書きすべてができるといった、非常にシンプルな動作の場合は、リスト7-3-3のように、オプション設定にauthenticationキーの値さえあれば構いません。なお、定義ファイルでは、値が「array()」という設定はできません。そのため、storingキーで認証継続の設定や、authexpiredキーで認証継続の時間等をデフォルトと同じでもいいので設定をして、authenticationキーに要素のある配列が設定されるようにします。</p><div class="code"><div class="caption">リスト7-3-3　すべてのコンテキストで認証が必要になる定義ファイル</div><pre><code>IM_Entry(
	array(	/* コンテキストにauthenticationの指定はなし*/	),
	array(
		'authentication' =&gt; array( ),	//項目のみ
	),
	...
)</code></pre></div><h4>特定のユーザーのみがログインできる</h4><p>　ページ全体にわたって、特定のユーザーのみがログインして利用できるようにするには、リスト7-3-4のように、オプション設定のauthenticationキーに、userキーの配列を指定します。この設定は定義ファイルエディターではuserの項目に「user3, user4」のように指定をします。カンマの前後の空白は無視します。したがって、読みやすくするために自由に空白を入れることができます。ここでは、user3ないしはuser4はログインができて、ログイン後は読み書きの処理が全て許可される状態になります。その他のユーザーは、たとえパスワードが正しくても、認証エラーとなってログインができず、データ処理は一切できない状態になります。なお、この目的だけなら、オプション設定のauthenticationキーは不要ですが、認証継続の方法などの指定が必要ならば、オプション設定の記述を行います。</p><div class="code"><div class="caption">リスト7-3-4　特定のユーザーのみがログインできる定義ファイル</div><pre><code>IM_Entry(
	array(	/* コンテキストにauthenticationの指定はなし*/	),
	array(
		'authentication' =&gt; array(
			'user' =&gt; array( 'user3', 'user4' ),
		),
	),
	...
)</code></pre></div><h4>特定のグループのユーザーのみがログインできる</h4><p>　ページ全体にわたって、特定のグループに所属するユーザーのみがログインして利用できるようにするには、リスト7-3-5のように、オプション設定のauthenticationキーに、groupキーの配列を指定します。この設定は定義ファイルエディターではgroupの項目に「group1, group2」のように指定をします。カンマの前後の空白は無視します。ここでは、group1ないしはgroup2に所属するユーザーはログインができ、ログイン後は読み書きの処理が全て許可される状態になります。その他のユーザーは、たとえパスワードが正しくても、認証エラーとなってログインができず、データ処理は一切できない状態になります。なお、この目的だけなら、オプション設定のauthenticationキーは不要ですが、認証継続の方法などの指定が必要ならば、オプション設定の記述を行います。</p><div class="code"><div class="caption">リスト7-3-5　特定のグループのユーザーのみがログインできる定義ファイル</div><pre><code>IM_Entry(
	array(	/* コンテキストにauthenticationの指定はなし*/	),
	array(
		'authentication' =&gt; array(
			'group' =&gt; array( 'group1', 'group2' ),
		),
	),
	...
)</code></pre></div><h3><span id="H3-ANC-21"><span style="display:none">→</span></span><span xmlns="" id="ix-105"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-106"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ログインの継続方法と設定</h3><p>　storingの設定がcredentialの場合は、ログインパネルでログインをした結果、その後にログイン状態を続けるためにクッキーを利用しています。同一の認証空間で、複数のページがある場合、あるページで認証したら、その状態を継続して別のページでも利用できないとかなり不便です。INTER-Mediatorはクッキーで認証情報を記録しており、ページ内はもちろん、ページ間をまたいでの認証継続も可能です。その場合、同一のissuedhashテーブルを使っている範囲が「同一の認証空間」となります。なお、authexpiredキーの値が経過すると、認証は不成立となります。この設定を省略すると、3600秒つまり1時間と成ります。この設定は、最後にアクセスしてからの時間であり、「何もしない時間がauthexpiredだけあればクッキー情報は消える」ということになります。</p><p>　クッキーやセッションストレージに記録される情報を表7-3-3にまとめました。なお、realmキーの値を設定すると、これらのキーの後にアンダーラインに続いて指定されます。realmが「Sample」なら、最初のキーは「_im_username_Sample」となります。異なるサイトで別々に認証したいのは当然なので、通常はサイトに固有のrealmの値を指定する必要があるでしょう。</p><div class="table"><table><tr><th>キー名</th><th>記録内容</th></tr><tr><td><span xmlns="" id="ix-107"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>_im_username</td><td>ログインしているユーザー名</td></tr><tr><td><span xmlns="" id="ix-108"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>_im_clientid</td><td>サーバー側で発行したクライアントID</td></tr><tr><td><span xmlns="" id="ix-109"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>_im_credential_token</td><td>認証用のトークン（http-only）</td></tr><tr><td><span xmlns="" id="ix-110"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>_im_mediatoken</td><td>画像等のメディア認証のための情報</td></tr></table><div class="caption">表7-3-3　クッキーに記録される情報</div></div><p>　クッキーでの記録はブラウザーを終了しても時間が来るまで残るので、その意味では便利です。期間を1週間くらいにしておくと、ほぼずっと認証が継続されるようになります。クッキーを第三者に取り出される危険性は、通信の傍受と、任意のJavaScriptコードを実行される場合があります。傍受ができないように、必ずTLSを使用してクライアントとサーバー間の通信を暗号化してください。さらに、_im_credential_tokenについては、JavaScript側から参照したり書き換えができないクッキーですので、任意のコードを実行されても取り出すことはできません。もちろん、任意のコードが実行できる状態でも大丈夫と言えなくもないのですが、任意のコードを実行できる状態では他にたくさんのセキュリティ的なアタックが可能なので、そのような状態にしないようにするのが基本です。</p><p>　この章の最初でも説明したとおり、認証に関する大きな脅威はログイン中のブラウザーを他人が使うことです。あるユーザーがログインをしてサイトを利用している時、PC/Macを操作できる状態で席を立つとします。すると、別の人が開いているブラウザーを使用して、元からログインをした人になりすますことができます。この問題は、すべての認証を伴うWebサイトに発生する問題点であり、INTER-Mediatorも例外ではありません。もちろん、クリックするたびにパスワード入力をすれば防げるとはいえ、それではシステムを利用する気にはなれないでしょう。この問題は、「ログアウトしない」という点に集約できます。利用者が席をはずすときには、ログアウト、あるいはOSの機能を利用してロックするのが現在のPC/Macの利用の上では原則です。INTER-Mediatorではその対策はできないですが、それは他のフレームワークやシステムも同様です。</p><h3><span id="H3-ANC-22"><span style="display:none">→</span></span>ユーザ名を電子メールアドレスにする</h3><p>　通常は、authuserのusernameフィールドの値をユーザー名としますが、<span xmlns="" id="ix-111"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-112"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>電子メールアドレスをユーザー名としたい場合もあります。その時は、オプション設定に、email-as-usernameキーと値を追加し、値はtrueにします。あるいはparams.phpファイルで変数emailAsAliasOfUserNameにtrueを代入します。これで、authuserテーブルのemailフィールドの電子メールアドレスをユーザー名として扱って認証ができます。ただし、内部的には、usernameの値を使うので、usernameは一意な値を指定しておく必要があります。電子メールでの認証を可能にした場合、電子メールアドレスをusernameフィールドの値に変換するためにデータベース処理が増えます。SQLサーバーはその程度であればあまり問題にならないでしょうが、FileMakerの場合はパフォーマンスに影響が出る可能性があるので、慎重に導入しましょう。</p><h3><span id="H3-ANC-23"><span style="display:none">→</span></span>issuedhashテーブルのみPDO経由で利用する</h3><p>　オプション設定にあるissuedhash-dsnキーには、issuedhashテーブルに対するDSNを別途指定することができます。params.phpファイルでは$issuedHashDSN変数で指定します。FileMakerデータベースではissuedhashテーブルのやり取りに多数のデータベース処理を行うと目に見えてパフォーマンスが落ちます。そこで、issuedhashテーブルをSQLiteで運用することができるように、こうした設定を追加しました。issuedhashテーブルは独立して利用できるように設計されています。authuserテーブルなどはFileMaker側に持ち、issuedhashテーブルだけをSQLiteで運用します。データベースを保存したパスなどを含むDSNを値として指定します。なお、SQLiteのデータベースを用意するには、INTER-Mediatorに含まれているdist-docs/sample_schema_sqlite.sqlを利用します。このファイルよりデータベースファイルを作り、それを利用することで問題ありません。他のテーブルは無視されます。こうして作成したSQLiteのデータベースを/var/db/imに置いたとすれば、issuedhash-dsnキーの値としては以下のように指定して利用することができます。</p><div class="code"><div class="caption">リスト7-3-6　issuedhash-dsnキーの指定例</div><pre><code>'issuedhash-dsn' =&gt; 'sqlite:/var/db/im/sample.sq3',</code></pre></div><div class="code"><div class="caption">リスト7-3-7　$issuedHashDSN関数の指定例</div><pre><code>$issuedHashDSN = 'sqlite:/var/db/im/sample.sq3';</code></pre></div><h3><span id="H3-ANC-24"><span style="display:none">→</span></span>ログインパネルとカスタマイズ</h3><p>　INTER-Mediatorでは<span xmlns="" id="ix-113"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ログインパネルを自動的に生成します。どのようなログインパネルなのかはこの後の演習の画面ショット等で確認してください。ログインパネルのページがあるわけではなく、既存のページで認証が要求されると自動的にオブジェクトをページに追加して、ログインパネルを表示します。背景が薄く見えるようなスタイル付けをしています。</p><p>　なお、<span xmlns="" id="ix-114"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ログアウトは、ページネーションコントロールに表示されるので、ページネーションの表示の定義が行われていれば、ログアウトボタンもページ上に表示されます。あるいは、以下の1行のプログラムを実行するボタン等を追加してください。なお、この1行の実行にも、ページファイルを読み込むSCRIPTタグが必要です。</p><div class="code"><div class="caption">リスト7-3-8　ログアウトを行うJavaScriptのプログラム</div><pre><code>INTERMediatorOnPage.logout();location.reload()</code></pre></div><p>　<span xmlns="" id="ix-115"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-116"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>INTER-Mediator標準のログインパネルの動作等をカスタマイズするためのJavaScriptのAPIをリスト7-3-9に紹介します。いずれも、INTERMediatorOnPage.doBeforeConstructメソッド（『8-5　ブラウザーを判断するページ』を参照）内など、ページ合成の前に実行します。設定が全てプロパティとなっているので、代入文による利用がほとんどでしょう。</p><div class="code"><div class="caption">リスト7-3-9　標準のログインパネルのカスタマイズ</div><pre><code>//<span xmlns="" id="ix-117"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-118"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>認証の失敗回数の変更（既定値は4）
INTERMediatorOnPage.<span xmlns="" id="ix-119"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>authCountLimit = 2;

//<span xmlns="" id="ix-120"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>パスワード変更の機能をログインパネルに出さない
INTERMediatorOnPage.<span xmlns="" id="ix-121"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>isShowChangePassword = false;

//<span xmlns="" id="ix-122"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-123"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ログインパネルのスタイル設定をしない
INTERMediatorOnPage.<span xmlns="" id="ix-124"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>isSetDefaultStyle = false;

//<span xmlns="" id="ix-125"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-126"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ログインパネルのRealm名を置き換える
INTERMediatorOnPage.<span xmlns="" id="ix-127"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>authPanelTitle = 'なんとかシステム';

//ログインパネル自体を独自のHTMLに置き換える
INTERMediatorOnPage.<span xmlns="" id="ix-128"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>loginPanelHTML = "....";</code></pre></div><p>　カスタムログインパネルは、params.phpファイルで$customLoginPanel変数にHTMLの文字列を定義しても構いません。</p><p>　ログインパネルの各要素は、スタイルシートを利用して、スタイルの設定ができます。ただし、「INTERMediatorOnPage.isSetDefaultStyle = false;」を実行して、INTER-Mediator側のスタイル設定をしないようにします。そして表7-3-4に示す、クラスあるいはID属性の要素に対して、スタイル設定を行います。もちろん、一部の設定のみを変更しても構いません。</p><div class="table"><table><tr><th>分類</th><th>キーワード</th><th>タグ</th><th>設定対象</th></tr><tr><td>class</td><td><span xmlns="" id="ix-131"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>_im_authpanel</td><td>DIV</td><td>認証パネル全体</td></tr><tr><td/><td><span xmlns="" id="ix-132"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>_im_authlabel</td><td>SPAN</td><td>「ユーザー名」などのラベル</td></tr><tr><td>id</td><td><span xmlns="" id="ix-133"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>_im_username</td><td>INPUT</td><td>ユーザー名のテキストフィールド</td></tr><tr><td/><td><span xmlns="" id="ix-134"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>_im_password</td><td>INPUT</td><td>パスワードのテキストフィールド</td></tr><tr><td/><td><span xmlns="" id="ix-135"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>_im_authbutton</td><td>BUTTON</td><td>ログインボタン</td></tr><tr><td/><td><span xmlns="" id="ix-136"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>_im_newpassword</td><td>INPUT</td><td>新しいパスワードのテキストフィールド</td></tr><tr><td/><td><span xmlns="" id="ix-137"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>_im_changebutton</td><td>BUTTON</td><td>パスワード変更ボタン</td></tr></table><div class="caption">表7-3-4　<span xmlns="" id="ix-129"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-130"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ログインパネルのスタイル設定のためのセレクタ</div></div><p>　ログインパネル自体を完全に置き換えるには、リスト7-3-9のリストの最後にあるINTERMediatorOnPage.loginPanelHTMLプロパティへ、HTMLで記述した文字列の代入を行います。ここでのHTMLは、HTMLタグから始まるものではなく、通常はDIVタグで開始することになると思われます。この時、HTML内では、表7-3-4の1列目がidの要素が含まれているようにします。例えば、「&lt;input type="text" id="_im_username"/&gt;」などの要素が含まれている必要があります。少なくとも、最初の3つは必要ですが、パスワードの変更が不要なら、最後の2つの要素は用意する必要はありません。また、FORMタグは必要ありません。</p><h3><span id="H3-ANC-25"><span style="display:none">→</span></span><span xmlns="" id="ix-138"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-139"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>パスワードのリセット</h3><p>　パスワードのリセットは、ログインパネルにその機能を含めてあります。この時、現在のパスワードを正しく入力しないと、パスワードの変更はできません。もし、独自にパスワード変更のページを作成したいとしたら、JavaScriptでリスト7-3-10のAPIを呼び出すことで可能です。</p><div class="code"><div class="caption">リスト7-3-10　パスワード変更のAPI</div><pre><code>INTERMediator_DBAdapter.<span xmlns="" id="ix-140"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>changePassowrd(ユーザー名, 旧パスワード, 新パスワード);</code></pre></div><p>　なお、現在の自分のパスワードが分からなくなってしまった場合は、事前に登録してある電子メールアドレスへのメッセージを利用してパスワードをリセットする機能もINTER-Mediatorで利用できますが、PHPを利用したプログラミングが必要です。<!--こちらについては、<span class="referencing" refsign="authandphp">[別の場所]</span>で説明を行います。--></p><h3><span id="H3-ANC-26"><span style="display:none">→</span></span><span class="exsign">演習</span>認証の実現とパスワード変更</h3><p>　この演習では、認証が必要なページを作成するための必要な記述と、実際の認証の動作を確認します。設定により、INTER-Mediatorによってログインパネルが表示されてログインができるようになります。また、ユーザーが自分自身のパスワードを変更する方法を説明します。</p><h4>最初のページ用の定義ファイルに必要な設定を行う</h4><div class="step"><span class="stepnumber">1</span>演習環境を起動します（『1-2　演習を行うための準備』を参照）。続いて、ブラウザーで、「http://localhost:9080」に接続します。「トライアル用のページファイルと定義ファイル」というタイトルの部分を特定します。</div><div class="step"><span class="stepnumber">2</span>「def22.phpを編集する」をクリックし、定義ファイルエディターでdef22.phpファイルを編集します。（もし、22番を他の用途に使ってしまっていれば、別の番号のファイルを利用してください。異なる番号のセットを利用した場合、ソースコードの記述が変わる部分がありますが、以下の手順では可能な限り注記します。）</div><div class="step"><span class="stepnumber">3</span>Contextsの中のQueryと書かれた背景がグレーの部分を特定します。そして、その次の行の右の方にある「削除」をクリックして、Queryの設定がある行を削除します。</div><div class="step"><span class="stepnumber">4</span>「レコードを本当に削除していいですか？」とたずねられるので、OKボタンをクリックします。</div><div class="step"><span class="stepnumber">5</span>同様に、Sortingの次の行にある「削除」ボタンを押し、確認にOKボタンをクリックして、こちらの設定も削除しておきます。</div><div class="step"><span class="stepnumber">6</span>Contextsでは、name、table、viewに「invoice」、keyに「id」、pagingに「true」repeat-controlに「confirm-insert confirm-delete」、recordsおよびmaxrecordsに「1000」と指定します。Contextsにあるその他のテキストフィールドは空白にします。この設定によりinvoiceテーブルを表示し、ページナビゲーションは表示しますが、ページの移動はおそらく発生しないくらいの1ページのサイズになります。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-308.png"/></div><div class="step"><span class="stepnumber">7</span>Database Settingsに設定を行います。</div><div class="step-wo-number">[MySQL]の場合<br/>db-classは「PDO」のままでかまいません。dsnに「mysql:host=db;dbname=test_db;charset=utf8mb4」と入力します。そして、userに「web」、passwordに「password」と入力します。</div><div class="step-wo-number">[FileMaker]の場合<br/>db-classを「FileMaker_DataAPI」に書き換えます。databaseは「TestDB」、userに「web」、passwordに「password」、serverに「gateway.docker.internal」、portに「443」、protocolに「https」、cert-vefifyingに「false」と入力します。</div><div class="step"><span class="stepnumber">8</span>Debugについては、「false」にすると、デバッグ情報が出なくなります。なお、デバッグ情報をみながら動作を確認したい方は、「2」のままにしてこの後の作業を行ってください。</div><h4>最初のページのページファイルの作成</h4><div class="step"><span class="stepnumber">1</span>「http://localhost:9080」で開いたページに戻り「page22.htmlを編集する」をクリックし、ページファイルのpage22.htmlを編集するページファイルエディターを開きます。HTMLでの記述内容を以下のように変更します。太字が追加する箇所を示します。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。番号にかかる部分は、SCRIPTタグのプログラムの内部にもあります。）</div><div class="code"><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;script type="text/javascript" src="def22.php"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
<strong>&lt;div id="IM_NAVIGATOR"&gt;&lt;/div&gt;
&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;作成日&lt;/th&gt;
      &lt;td&gt;&lt;input type="text" data-im="invoice@issued"/&gt;&lt;/td&gt;
	&lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;タイトル&lt;/th&gt;
      &lt;td&gt;&lt;input type="text" data-im="invoice@title"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</strong>
&lt;/body&gt;
&lt;/html&gt;</code></pre></div><div class="step"><span class="stepnumber">2</span>「http://localhost:9080」で開いたページに戻り「page22.htmlを表示する」をクリックします。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）初期状態では3レコードが作られていますが、別の演習でレコードが増減しているかもしれません。ここでは内容はなんでも構いませんので、レコードが見えていることをまずは確認してください。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-309.png"/></div><h4>ページを開くのに認証を必要とするように変更する</h4><div class="step"><span class="stepnumber">1</span>def22.phpを定義ファイルエディターで編集します。すでにタブあるはウインドウで見えている場合はそれを呼び出します。閉じてしまった場合には、「http://localhost:9080」で開いたページに戻り「def22.phpを編集する」をクリックします。</div><div class="step"><span class="stepnumber">2</span>ページの最初にある「Show All」ボタンをクリックして、設定項目を全て表示します。そして、ページの最後の方に移動し、Optionsの中の「Authentication and Authorization」の「storing」に「credential」と入力します。Tabキー等をクリックして別のテキストフィールドに移動し、確実に設定を保存してください。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-310.png"/></div><div class="step"><span class="stepnumber">3</span>page22.htmlを表示します。すでにタブあるはウインドウで見えている場合はそれを呼び出します。そして、ブラウザーの更新ボタンをクリックして、画面の更新を行ってください。閉じてしまった場合には、「http://localhost:9080」で開いたページに戻り「page22.htmlを表示する」をクリックしてページを開きます。</div><div class="step"><span class="stepnumber">4</span>すると、ログインパネルが表示されます。このログインパネルは、INTER-Mediator標準のもので、フレームワークが生成しています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-312.png"/></div><div class="step"><span class="stepnumber">5</span>まずは、正しいユーザー名とパスワードを入力してみます。ユーザー名とパスワードいずれも「user1」と入力して、「ログイン」ボタンをクリックします。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-313.png"/></div><div class="step"><span class="stepnumber">6</span>ページが表示され、データベースの内容が表示されています。見えている内容が、認証を必須にする前と同様であれば問題はありません。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-314.png"/></div><div class="step-wo-number">ここではすでに認証に必要なテーブルが用意されていて、ユーザーも最初から設定されているので、ページの定義ファイルに認証が必須になるような設定を追加するだけで認証ができるようになっています。作業は簡単ですが、実際の開発ではテーブルを用意したりといった作業が発生する点は知っておきましょう。</div><div class="step"><span class="stepnumber">7</span>ページナビゲーションには、ログインしているユーザーとして「user1」が見えています。また、「ログアウト」ボタンも見えています。「ログアウト」ボタンをクリックして、ログアウトしておきます。</div><h4>認証とパスワード変更の動作を確認する</h4><div class="step"><span class="stepnumber">1</span>ログアウトすると、またログインパネルが表示されます。ここで、ユーザー名は「user1」として、パスワードに空欄あるいは「user1」以外の間違えたパスワードを入力して、「ログイン」ボタンをクリックします。赤い文字でエラーが表示されログインができず、ページの内容やデータベースのデータは表示されません。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-315.png"/></div><div class="step"><span class="stepnumber">2</span>間違ったパスワードを何度も入力してみてください。5回目に認証エラーとなって、これ以上作業はできなくなります。パスワードを空欄で入力した場合はカウントされませんので、適当に間違えたパスワードを何か入力してください。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-316.png"/></div><div class="step"><span class="stepnumber">3</span>ブラウザーの更新ボタンをクリックして画面を更新します。するとログインパネルがまた表示されます。続いて、パスワードの変更を行ってみます。</div><div class="step"><span class="stepnumber">4</span>ユーザー名に「user1」と入力します。パスワードは「user1」以外の文字列を入力します。つまり、パスワードは違っている状況であるとします。「新パスワード」に「1234」と入力します。「パスワード変更」ボタンをクリックします。すると、パスワードの変更に失敗したことがレポートされています。この状態ではパスワードは変わっていません。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-303.png"/></div><div class="step"><span class="stepnumber">5</span>ユーザー名とパスワードに、いずれも「user1」と入力します。つまり、正しいユーザー名とパスワードを入力します。「新パスワード」に「1234」と入力します。パスワードはなんでも構いませんが、以下の手順をこの通り進めるために、ここでは「1234」と入力してください。そして「パスワード変更」ボタンをクリックします。パスワード変更が成功したメッセージが表示されます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-302.png"/></div><h4>認証の継続の様子を確認する</h4><div class="step"><span class="stepnumber">1</span>ユーザー名「user1」、パスワード「1234」でログインを行って、認証された状態でページを表示します。ここでページのウインドウあるいはタブを閉じます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-304.png"/></div><div class="step"><span class="stepnumber">2</span>「http://localhost:9080」で開いたページで「page22.htmlを表示する」をクリックしてページを再度開きます。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-305.png"/></div><div class="step"><span class="stepnumber">3</span>元のページが表示されており、認証が成功したことを示しています。認証情報はクッキーで保存されているため、ページを閉じても認証情報は残っており、指定した一定時間内であれば認証は継続するようになっています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-306.png"/></div><h4>認証の継続の仕組みを確認する</h4><div class="step"><span class="stepnumber">1</span>クッキーにどのような情報が記録されているかを確認してみます。以下の操作はブラウザの「デベロッパーツール」を使います。場合によってはクッキーの情報は、ここでの画面ショットを見るだけでも結構です。</div><div class="step"><span class="stepnumber">2</span>デベロッパーツール（Safariでは「Webインスペクター」）を表示して、上のタブで、「ストレージ」を選択します。左側でCookieを選択すると、現在のページに設定されたクッキーが一覧されています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-307.png"/></div><div class="step"><span class="stepnumber">3</span>_im_usernameはユーザー名が設定されます。_im_clientidは、クライアントごとにサーバから振られるランダムな番号です。_im_credential_tokenは認証が成功した時にサーバ側から設定され、この値をサーバに接続するごとに送信して、以前に認証が成功したことを伝達します。この値は、第三者に漏れるとそのユーザーとしてサーバーにアクセスできてしまう可能性があるものですが、HttpOnlyのチェックがついており、クライアントのJavaScriptからは読み出すことができません。また、通常はドメイン制限をしているので、他のサイトに移動したときに取り出すこともできません。HTTPの通信を暗号化したHTTPSで通信していれば、第三者による取得が可能な明確な方法はないと言えます。</div><div class="step"><span class="stepnumber">4</span>データベースに保存されているhashedpasswdフィールドの値を調べてみます。データベースエンジンによって操作が違います。</div><div class="step"><span class="stepnumber">5</span>[MySQLの場合]「http://localhost:9080」のアドレスのページを開き、「ユーザー管理ページサンプル」をクリックして、ユーザー管理アプリケーションを起動します。ログパネルでは、ユーザー名に「user1」、パスワードに「1234」を入力して、認証を行います。user1のHashed Passwordの列の値と、_im_credential_tokenの値は違うものになっています。</div><div class="picture"><img class="picture-small" src="figs/ng-shot-311.png"/></div><div class="step"><span class="stepnumber">6</span>[FileMakerの場合]FileMaker Proで、Test_DBデータベースを開き、「authuser」レイアウトを開きます。そこで、該当するユーザーのhashedpasswdフィールドの値を確認してください。</div><div class="step-wo-number">セキュリティ上で考慮しなければならない点は、すでに説明しています。認証情報をクッキーに入れる場合にはクッキーのデータがHTTPのやり取りでネットワークを流れるので、少なくとも、TLSを利用して、通信を傍受されないようにすることは必須です。</div><h4>演習のまとめ</h4><ul><li>定義ファイルのIM_Entry関数の呼び出しにおいて、第2引数（オプション）にauthenticationキーの設定を行うことで、すべてのコンテキストの利用に認証が必要になります。</li><li>認証の継続のために、セッションストレージやクッキーに、認証情報を保存することができます。クッキーの場合はブラウザーを再起動しても認証は継続しますが、データベースに記録するハッシュ関数から得られた値をネットワークに流すので、最低限でもTLSでの運用が必要です。</li><li>パスワードの変更は、ユーザーによって、ログインパネル上で行うことができます。</li></ul><h3><span id="H3-ANC-27"><span style="display:none">→</span></span>メールを利用したユーザー登録</h3>
INTER-Mediatorには、メールを利用してのユーザー登録や、メールを利用したパスワードのリセットを行う仕組みを組み込む最低限の機能を持ったファイルを、samples/Auth_Support/User_Enrollmentおよびsamples/Auth_Support/PasswordResetフォルダーに入れています。こちらについてはサーバーサイドのプログラムについての全般的な知識が必要なので、『7-6　メールを利用したユーザー登録とパスワードのリセット』でまとめて説明をします。

<h3><span id="H3-ANC-28"><span style="display:none">→</span></span><span xmlns="" id="ix-141"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>パスワードポリシーの定義</h3>
<p>　params.phpファイルで$passwordPolicy変数を定義して、<span xmlns="" id="ix-142"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-143"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>パスワードのルールを指定できます。表7-3-5に設定可能なキーワードを示します。これらの文字列を空白で区切ってひとつの文字列で指定します。例えば、"useNumber useAlphabet length(10)" は、指定したパスワードに、数字、アルファベットが必ず含まれ、かつ10文字以上である必要があることを定義します。</p>

<div class="table"><table><tr><th>キーワード</th><th>適用されるルール</th></tr><tr><td>useAlphabet</td><td>アルファベットが必ず入っている</td></tr><tr><td>useNumber</td><td>数字が必ず入っている</td></tr><tr><td>useUpper</td><td>アルファベットの大文字が必ず入っている</td></tr><tr><td>useLower</td><td>アルファベットの小文字が必ず入っている</td></tr><tr><td>usePunctuation</td><td>記号類が必ず入っている</td></tr><tr><td>length(n)</td><td>長さがn文字以上</td></tr><tr><td>notUserName</td><td>ユーザー名と同一ではいけない</td></tr></table><div class="caption">表7-3-5　パスワードのルールに指定できる文字列</div></div>

<p>　なお、この設定は、authuserテーブルに単にパスワードを指定するときには適用されません。初期パスワードをSQLステートメントのテキストで与えるような場合には、ここで指定したルールに合致しているかどうかの判定は行われません。ここで指定したパスワードのルールは、ログインパネル上でパスワードの変更したときや、ログインパネルのパスワード変更処理で呼び出されるJavaScriptあるいはPHPのメソッドを利用した場合に、ルールが適用できます。したがって、このルール適用は、パスワード変更時に適用されるという理解で問題はありませんが、初期値がルール通りかどうかは開発者あるいはシステム管理者が決定して必要なら自身でチェックをしてください。</p>

<h3><span id="H3-ANC-29"><span style="display:none">→</span></span>このセクションのまとめ</h3>
<p>　認証のための設定は、多くは定義ファイル上で行うことで実現可能です。むしろ、データベースにユーザーやグループのテーブルを用意する方がよほど手間がかかる仕事と言えるでしょう。このセクションでは認証を実現する方法やそこでのさまざまな設定、ログインパネルやそのカスタマイズなどを説明しました。しかしながら、認証を伴うアプリケーションはセキュリティ上の問題を抱えやすいシステムでもありますので、どういう原理で認証が稼働していて、やってはいけないことや、運用上どうしても必要になることに対してなぜそのような結果になっているのかをなるべく正しく理解をするようにしましょう。</p>

<!-- ============ SECTION START ============ -->
<h2><span id="H2-ANC-4"><span style="display:none">→</span></span><span class="sectionnumber">7-4</span>コンテキストにおけるアクセス制御</h2>
<p class="section-lead">アクセス権の制御は、基本となる4つのデータ操作のCRUD（Create Read Update Delete）について、それぞれ、どのユーザーあるいはグループに対して許可しているのかをコンテキスト定義で規定します。操作ごとのアクセス権は、オプション設定では指定はできず、個々のコンテキスト定義で行います。</p>

<h3><span id="H3-ANC-30"><span style="display:none">→</span></span>設定例による<span xmlns="" id="ix-144"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-145"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>アクセス権の設定</h3>
<p>　前のセクションに続いて、用途に応じてどのような設定を行うのかを例で示します。以下の表記は定義ファイルでのPHPでの記述を行います。なお、いずれも、『7-2　ユーザー認証とアクセス権適用を行う仕組み』で説明したテーブルが用意されていて、ユーザーやグループが定義されていることを前提として説明します。また、設定の詳細は、『7-3　認証とアクセス権の設定』の最初の部分に表で示してあります。</p>

<h4>読み出しはできて書き込みができないコンテキスト</h4>
<p>　読み出しはできても書き込みを一切できないようにしたい場合、認証の設定を使わない方法もあります。リスト7-4-1のように、コンテキストのviewキーの値には存在するビューやテーブル名を指定し、tableキーの値には存在しないエンティティ名（ビューあるいはテーブルの名前）を指定します。authenticationキーの設定はありません。もちろん、その状態で書き込みをしてもエラーになるということで何も起こらないことを意図したものです。ユーザーインターフェースで書き込み可能なものを配置しないだけでは、定義ファイルへネットワークを通じて直接アクセスされた場合に書き込みや更新ができてしまう可能性があります。この設定は、そうした意図しないアクセスからも、書き込み処理を排除してデータを保護します。単に読み出しだけでいいようなコンテキストは認証の有無にかかわらずよくあり、安全面からも、なるべくtableキーの値に存在しないエンティティ名を指定するようにすべきです。また、認証がされていても書き込みを排除したい場合には、この手法は有効です。</p>

<div class="code"><div class="caption">リスト7-4-1　読み出しはできて書き込みができないコンテキスト定義</div><pre><code>IM_Entry(
    array(
        array(
            'name' =&gt; 'person',
            'view' =&gt; 'person_view',	//データベースには存在する
            'table' =&gt; 'dummydummy',	//データベースには存在しない
            'records' =&gt; 1,
            'key' =&gt; 'id',
        ),
    ),
    array( ... ),
    ...
);</code></pre></div>

<h4>特定のユーザーが読み込みだけの権限でログインできる</h4>
<p>　特定のコンテキストで、認証を必要とし、加えて書き込みができないようにするには、リスト7-4-2のような定義ファイルを作成します。この例では、コンテキストのtableキーに存在しないテーブル名を指定して、書き込み処理がエラーになるようにしています。そして、adminユーザーは認証して読み出しができますが、書き込みができるユーザーは誰もいないという状態になります。この時、この定義ファイルの他に、authenticationキーのないコンテキストがあれば、どのユーザーもログインを行うことなくデータベースを利用できます。</p>

<div class="code"><div class="caption">リスト7-4-2　特定のユーザーが読み込みだけの権限でログインできるコンテキストを含む定義ファイル</div><pre><code>IM_Entry(
	array(	
		array(
			'name' =&gt; 'mycontext',
			'view' =&gt; 'mycontext',
			'table' =&gt; 'dummydummy',	//実在しないテーブル名
			'authentication' =&gt; array(
				'read' =&gt; array(
					'user' =&gt; array( 'admin' ),
				),
			),
		),
	),
	array(	/* 'authentication' キーはなし */ ),
	...
)</code></pre></div>

<h4>認証したユーザーに対して読み出しと更新のみを許可するコンテキスト</h4>
<p>　データベースの4つの主要な処理であるCRUDそれぞれに対するアクセス権を、コンテキスト定義の中で設定することができます。この時、read、update、create、deleteの4つの操作をすべて記述してください。そして、その中で、userあるいはgroupキーで許可を与えるユーザーやグループを配列で与えます。それぞれの操作で一切許可しないものは、架空のグループを割り当てておけば良いでしょう。リスト7-4-3のコンテキストmycontextでは、adminsグループのユーザーであればログインをして、読み出しと更新処理はできますが、dummyグループは存在しないグループなので、レコード作成や削除ができなくなります。ここでは、viewとtableキーがないので、「mycontext」テーブルに読み書き処理が行われます。</p>

<div class="code"><div class="caption">リスト7-4-3　認証したユーザーに対して読み出しと更新のみを許可するコンテキストを含む定義ファイル</div><pre><code>IM_Entry(
	array(	
		array(
			'name' =&gt; 'mycontext',
			'authentication' =&gt; array(
				'read' =&gt; array('group' =&gt; array( 'admins' ),),
				'update' =&gt; array('group' =&gt; array( 'admins' ),),
				'create' =&gt; array('group' =&gt; array( 'dummy' ),),
				'delete' =&gt; array('group' =&gt; array( 'dummy' ),),
			),
		),
	),
	array( /* 'authentication' キーはなし */ ),
	...
)</code></pre></div>

<h4>認証したユーザーに対して全ての操作を許可するコンテキスト</h4>
<p>　CRUDのそれぞれの操作に対する設定が全て同じであるのなら、allキーを使って1行で指定が可能です。リスト7-4-4のコンテキストmycontextでは、adminsグループのユーザーであればログインをして、データベースの全ての処理ができます。</p>

<div class="code"><div class="caption">リスト7-4-4　認証したユーザーに対して全ての操作を許可するコンテキストを含む定義ファイル</div><pre><code>IM_Entry(
	array(	
		array(
			'name' =&gt; 'mycontext',
			'authentication' =&gt; array(
				'all' =&gt; array('group' =&gt; array( 'admins' ),),
			),
		),
	),
	array( /* 'authentication' キーはなし */ ),
	...
)</code></pre></div>

<h4>コンテキストでのフィールド単位の制限</h4>
コンテキスト定義の中では、特定のフィールドに対する書き込みや読み出しできないようにする設定が可能です。リスト7-4-5のように、protect-writingあるいはprotect-readingというフィールドの設定ができます。例えば、外部キーフィールドや、次のセクションで説明するユーザー名のフィールドに対して更新できないようにしたり、検索やソートでは使うものの読み出しはできないようにしたいフィールドがあれば、その名前を配列で指定します。

<div class="code"><div class="caption">リスト7-4-5　コンテキストでのフィールド単位の制限を含む定義</div><pre><code>IM_Entry(
    array(
        array(
            'name' =&gt; 'person',	// view, tableは省略
            'records' =&gt; 1,
            'key' =&gt; 'id',
            'protect-writing' =&gt; array( 'id' ),
            'protect-reading' =&gt; array( 'username' ),
        ),
    ),
    array( ... ),
    array( ... ),
    false
);</code></pre></div>

<h3><span id="H3-ANC-31"><span style="display:none">→</span></span><span class="exsign">演習</span>コンテキストにアクセス権を設定する</h3>
<p class="section-lead">コンテキストに対するアクセス権の設定を行ってみます。ここでの演習は、『7-3　認証とアクセス権の設定』の『認証の実現とパスワード変更』で作成したページを続けて利用します。データベースの4つの処理に対して、それぞれ可能なユーザーやグループの設定ができます。ここではグループの設定と、権限がない場合にはデータベース処理がなされないことを確認します。</p>

<h4>アクセス権の設定と動作を確認する</h4>
<div class="step"><span class="stepnumber">1</span>前のセクションの演習から続けて作業を行う場合には、いったんWebブラウザーを終了して、改めて起動し、「http://localhost:9080」に接続して演習環境のホームを表示してください。</div>
<div class="step"><span class="stepnumber">2</span>def22.phpを定義ファイルエディターで編集します。すでにタブあるはウインドウで見えている場合はそれを呼び出します。閉じてしまった場合には、「http://localhost:9080」で開いたページに戻り「def22.phpを編集する」をクリックします。</div>
<div class="step"><span class="stepnumber">3</span>ページの最初にある「Show All」ボタンをクリックして、設定項目を全て表示します。そして、コンテキストの途中にある「Authentication, Authorization and Security」で入力を行います。readのgroupに「group2」、updateのgroup、createのgroup、deleteのgroupに存在しないグループである「dummy」を指定します。　最後にTabキーを押して、4つのテキストフィールドに対応するフィールドの更新を確実に行うようにします。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-318.png"/></div>
<div class="step-wo-number">ここでの設定は、このコンテキストからの読み出しはgroup2に対して許可するが、その他の更新や新規レコード、レコード削除はdummyグループに対してのみ許可することを意味します。しかしながら、dummyグループは存在しないので、すべてのユーザーは更新などの書き込み処理はできません。コンテキストのユーザーやグループの設定を行うときには、4つのデータベース処理のすべてに対して設定を行ってください。空欄にすると、設定がないものとみなしてしまいます。</div>
<div class="step"><span class="stepnumber">4</span>page22.htmlを表示します。すでにタブあるはウインドウで見えている場合はそれを呼び出ます。そして、ブラウザーの更新ボタンをクリックして、画面の更新を行ってください。閉じてしまった場合には、「http://localhost:9080」で開いたページに戻り「page22.htmlを表示する」をクリックしてページを開きます。</div>
<div class="step"><span class="stepnumber">5</span>ログインパネルが表示されるので、ユーザー名とパスワードに「user2」と入力して、「ログイン」ボタンをクリックします。user2はgroup2には所属していないために、正しいパスワードを入力してもページの表示は行いません。つまり、アクセス権が設定されていないので、認証はできても認可エラー扱いにして、再度認証パネルが表示されます。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-319.png"/></div>
<div class="step"><span class="stepnumber">6</span>group2に所属する「user4」でログインします。ユーザー名もパスワードも「user4」です。すると、データベースの内容を表示することができました。ログインユーザーがuser4であることを確認してください。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-320.png"/></div>
<div class="step"><span class="stepnumber">7</span>ここで、適当なテキストフィールドのデータを変更してTabキーを押して、更新を行います。ここで、このコンテキストのupdateのgroupに存在しないグループのdummyが設定されていることを思い出してください。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-321.png"/></div>
<div class="step"><span class="stepnumber">8</span>ページが表示されますが、データは修正されていません。ブラウザーの更新ボタンをクリックして、画面を更新し、データベースの値を再度取り出してみます。すると、フィールドに見えている値は修正前の値になっています。したがって、実際には、データベースの更新はアクセス権がないために行われませんでした。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-322.png"/></div>
<div class="step-wo-number">更新できない時の動作としてはあまりスマートな感じではありませんが、ここでの演習は、「コンテキストにアクセス権を設定すれば、更新が阻止できる」ことを示すためのものです。もし、あるデータベースフィールドの内容を表示しかしないのであれば、ここで作ったページのようにテキストフィールドを利用することはあり得ません。DIVやSPANタグで表示をすれば済みます。しかしながら、利用者がサーバー通信を独自に構築して更新をしようとしても、コンテキストの設定で阻止ができることをこの演習で確認していただきました。コンテキストの設定はサーバー側で記録されているので、コンテキストのアクセス権の設定はユーザーには変更できず、アクセス権の設定は設計者の意図通りに機能します。</div>

<h4>レコード作成と削除の権限がない場合の動作</h4>
<div class="step"><span class="stepnumber">1</span>def22.phpを定義ファイルエディターで編集します。すでにタブあるはウインドウで見えている場合はそれを呼び出します。閉じてしまった場合には、「http://localhost:9080」で開いたページに戻り「def22.phpを編集する」をクリックします。</div>
<div class="step"><span class="stepnumber">2</span>ページの最初にある「Show All」ボタンをクリックして、設定項目を全て表示します。そして、コンテキストの途中にある「Authentication, Authorization and Security」にあるupdateのgroupに「group2」を指定します。Tabキーを押して、テキストフィールドに対応するフィールドの更新を確実に行います。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-323.png"/></div>
<div class="step"><span class="stepnumber">3</span>page22.htmlを表示します。すでにタブあるはウインドウで見えている場合はそれを呼び出ます。そして、ブラウザーの更新ボタンをクリックして、画面の更新を行ってください。閉じてしまった場合には、「http://localhost:9080」で開いたページに戻り「page22.htmlを表示する」をクリックしてページを開きます。</div>
<div class="step"><span class="stepnumber">4</span>適当なフィールドの内容を変更してTabキーを押し、データの更新を行います。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-324.png"/></div>
<div class="step"><span class="stepnumber">5</span>問題なく、更新ができました。今度は、group2に対して更新の権限が与えられているので、group2に所属するuser4での更新ができたということです。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-325.png"/></div>
<div class="step"><span class="stepnumber">6</span>何からのレコードの「削除」ボタンをクリックして、レコード削除を試みます。確認のダイアログボックスでは、OKをクリックします。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-327.png"/></div>
<div class="step"><span class="stepnumber">7</span>ページが再度表示されていますが、削除したレコードはそのままで削除はされていません。ブラウザーの更新ボタンをクリックして、ページを再表示しても、削除しようとしたレコードは削除されずに残っています。つまり、user4には削除の権限が与えられていないので、レコード削除ができないのです。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-328.png"/></div>
<div class="step"><span class="stepnumber">8</span>ページネーションコントロールにある「レコード追加: invoice」をクリックして、レコードの追加を試みます。ダイアログボックスが表示されれば、OKをクリックします。以降、適当にダイアログボックスへ対処してください。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-329.png"/></div>
<div class="step"><span class="stepnumber">9</span>ページが再表示されますが、レコードの個数を見ても、レコードが新しく作れていないことは確認できます。ブラウザーの更新ボタンをクリックしても、レコードが追加された形跡はありません。user4にはレコード作成の権限が与えられていないのです。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-330.png"/></div>
<div class="step-wo-number">レコード作成や削除ができない時の動作としてはあまりスマートな感じではありませんが、ここでの演習は、「コンテキストにアクセス権を設定すれば、レコード作成や削除が阻止できる」ことを示すためのものです。もし、あるコンテキストに対してレコード作成や削除をしないのであれば、ここで作ったページのように作成や削除のボタンを表示することはあり得ません。しかしながら、利用者がサーバー通信を独自に構築してレコードの作成や削除をしようとしても、コンテキストの設定で阻止ができることをこの演習で確認していただきました。コンテキストの設定はサーバー側で記録されているので、コンテキストのアクセス権の設定はユーザーには変更できず、アクセス権の設定は設計者の意図通りに機能します。</div>

<h4>演習のまとめ</h4>
<ul><li>コンテキスト定義にauthenticationキーでの指定を行うことで、データベースの4つの操作であるCRUDそれぞれに対して実施可能なユーザーやグループを定義できます。</li><li>誰にも操作されたくない場合には、存在しないグループを指定するのが確実かつ手軽な方法です。</li></ul>

<h3><span id="H3-ANC-32"><span style="display:none">→</span></span>このセクションのまとめ</h3>
<p>　コンテキスト定義において、CRUDの各操作が可能なユーザーやグループの指定ができるので、特定のユーザーに対するアクセス権の付与が可能です。また、tableキーの値に存在しないテーブル名を与えて、書き込み処理を阻止するという手段も利用できます。</p>

<!-- ============ SECTION START ============ -->

<h2><span id="H2-ANC-5"><span style="display:none">→</span></span><span class="sectionnumber">7-5</span>レコード単位のアクセス権とメディアデータのアクセス権</h2>
<p class="section-lead">同一のテーブルでレコードごとに違うユーザーに読み書き権限を与えて運用できます。そして、各レコードは他のユーザーからは操作できないように保護されています。また、写真のファイル等の読み出しにおいて、レコード単位のアクセス権を適用することもできるので、画像などもユーザーごとに保護した状態で参照ができます。</p>

<h3><span id="H3-ANC-33"><span style="display:none">→</span></span><span xmlns="" id="ix-146"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-147"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>レコード単位のアクセス権</h3>
<p>　同一のテーブルの個々のレコードに対してアクセス権を設定するためには、そのレコードが誰に対してアクセス権を持っているのかを何らかの方法で記録が必要です。そのために、そのテーブルに、ユーザー名あるいはグループ名を記憶するフィールドを設けて、そのフィールドに設定されているユーザーあるいはグループに対しての権限が与えられるような動作をフレームワークが行います。</p>
<p>　設定はコンテキスト定義のauthenticationキーの配列の中で、操作名をキーにした配列で、targetキーとfieldキーを指定します。targetキーは、「field-user」ならfieldキーで指定したフィールドにある名前のユーザーに対して権限が与えられます。targetキーの値が「field-group」ならfieldキーで指定したフィールドにある名前のグループに対して権限を与えます。targetキーが「table」あるいは省略の場合には、テーブル全体で同一のアクセス権の設定となります。</p>
<p>　fieldキーに指定するフィールドは文字型にします。そのフィールドには、authuserテーブルのusernameフィールドの文字列を入力します。主キーとなるidフィールドの値ではなく、ユーザー名の文字列を入力します。また、電子メールをユーザー名に使う場合でも、対応するusernameフィールドの値を設定します。</p>
<p>　クエリーやレコード削除、更新の場合の検索条件に、ANDで「fieldのフィールド名=ログイン中のユーザー名」という検索条件を付与します。したがって、全ての操作で、他のユーザーのレコードに対してデータの削除・更新が行われることはありません。また、新規にレコードを作成するときに、fieldで指定したフィールドにユーザー名を自動的に設定します。こうして、レコードの生成から更新、削除に至る全ての場面で、ログインしているユーザーに権限のあるレコードだけが処理対象になるということです。また、言い換えれば、他人のレコードを削除しようとしても認証しない限りはできないのです。ただし、このAND演算がポイントであるため、FileMakerの場合に検索条件をORで構成している場合には、レコード単位のアクセス権の設定は適用できません。</p>
<p>　リスト7-5-1はレコードごとのアクセス権を、chatというコンテキストに対して設定しています。オプション領域には、user1あるいはgroup2に所属するユーザーのみが、まず認証してログインできることが定義されています。その上でコンテキスト定義のauthenticationでは、全てのデータベースオペレーションに対して、userという名前のフィールドにユーザー名を記録して、各レコードはuserフィールドのユーザーだけが読み書きできるようになります。さらに、protect-writingキーで、userフィールドの更新を阻止します。この設定を行っても、新規レコードを作るときには、userフィールドにはログインしているユーザーのユーザー名が設定されます。</p>

<div class="code"><div class="caption">リスト7-5-1　レコードごとのアクセス権を設定した例</div><pre><code>IM_Entry(
    array(
        array(
            'records' =&gt; 100000000,
            'name' =&gt; 'chat',
            'key' =&gt; 'id',
            'repeat-control' =&gt; 'delete',
            'authentication' =&gt; array(
                'all' =&gt; array(
                    'target' =&gt; 'field-user',
                    'field' =&gt; 'user',
                ),
            ),
            'protect-writing' =&gt; array( 'user' ),
        ),
    ),
    array(
        'authentication' =&gt; array( // オプション設定
            'user' =&gt; array('user1'), // ログイン可能なユーザー
            'group' =&gt; array('group2'), // ログイン可能なグループ
        ),
    ),
    array('db-class' =&gt; 'PDO'),
    false
);</code></pre></div>

<h3><span id="H3-ANC-34"><span style="display:none">→</span></span><span class="exsign">演習</span>レコード単位のアクセス権を設定する</h3>
<p>　同一のテーブル内で、レコードごとに参照できるユーザーを切り替えたい場合があります。その時、ユーザー名やグループ名を入力する文字型フィールドを用意して、そのフィールドをログインしているユーザー名で自動的に絞り込むという動作で実現しています。レコードを新規作成するときに、そのフィールドに自動設定されることなども確認しましょう。</p>

<h4>最初のページ用の定義ファイルに必要な設定を行う</h4>
<div class="step"><span class="stepnumber">1</span>演習環境を起動します（『1-2　演習を行うための準備』を参照）。続いて、ブラウザーで、「http://localhost:9080」に接続します。「トライアル用のページファイルと定義ファイル」というタイトルの部分を特定します。</div>
<div class="step"><span class="stepnumber">2</span>「def23.phpを編集する」をクリックし、定義ファイルエディターでdef23.phpファイルを編集します。（もし、23番を他の用途に使ってしまっていれば、別の番号のファイルを利用してください。異なる番号のセットを利用した場合、ソースコードの記述が変わる部分がありますが、以下の手順では可能な限り注記します。）</div>
<div class="step"><span class="stepnumber">3</span>Contextsの中のQueryと書かれ背景がグレーの部分を特定します。そして、その次の行の右の方にある「削除」をクリックして、Queryの設定がある行を削除します。</div>
<div class="step"><span class="stepnumber">4</span>「レコードを本当に削除していいですか？」とたずねられるので、OKボタンをクリックします。</div>
<div class="step"><span class="stepnumber">5</span>同様に、Sortingの次の行にある「削除」ボタンを押し、確認にOKボタンをクリックして、こちらの設定も削除しておきます。</div>
<div class="step"><span class="stepnumber">6</span>Contextsでは、nameに「invoice-all」、table、viewに「invoice」、keyに「id」、pagingに「true」と指定します。Contextsにあるその他のテキストフィールドは空白にします。この設定によりinvoiceテーブルを表示します。単にすべてのレコードを一覧表示したいので、簡単な定義とします。</div>
<div class="step"><span class="stepnumber">7</span>Contextsの見出しの下にある「追加」ボタンをクリックして新たなコンテキスト定義を追加します。そして、name、table、viewに「invoice」、keyに「id」、repeat-controlに「delete insert」と指定します。Contextsにあるその他のテキストフィールドは空白にします。この設定によりinvoiceテーブルを表示し、レコードの追加や削除ができるようにします。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-336.png"/></div>
<div class="step"><span class="stepnumber">8</span>定義ファイルエディターのページの冒頭にある「Show All」ボタンをクリックします。そして、nameが「invoice」の方のコンテキスト定義の中にある「Authentication, Authorizaton and Security」の見出しにあるall:targetを「field-user」、all:fieldを「authuser」とします。Tabキーを押すなどして、入力したフィールドから別のフィールドに移動して、確実に保存をしてください。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-332.png"/></div>
<div class="step"><span class="stepnumber">9</span>Optionsの中にある「Authentication and Authorizaton」を探します。そして、storingに「credential」、realmに「Sample」と入力します。こちらも、Tabキーを押すなどして、入力したフィールドから別のフィールドに移動して、確実に保存をしてください。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-333.png"/></div>
<div class="step"><span class="stepnumber">10</span>Database Settingsに設定を行います。</div>
<div class="step-wo-number">[MySQL]の場合<br/>db-classは「PDO」のままでかまいません。dsnに「mysql:host=db;dbname=test_db;charset=utf8mb4」と入力します。そして、userに「web」、passwordに「password」と入力します。</div>
<div class="step-wo-number">[FileMaker]の場合<br/>db-classを「FileMaker_DataAPI」に書き換えます。databaseは「TestDB」、userに「web」、passwordに「password」、serverに「gateway.docker.internal」、portに「443」、protocolに「https」、cert-vefifyingに「false」と入力します。</div>
<div class="step"><span class="stepnumber">11</span>Debugについては、「2」のままにしてこの後の作業を行ってください。最後にデータベースとの通信結果を確認します。デバッグ情報を見ない場合には、ページの冒頭にある「clear」ボタンをクリックするなどして、適時画面から消しても構いません。</div>

<h4>最初のページのページファイルの作成</h4>
<div class="step"><span class="stepnumber">1</span>「http://localhost:9080」で開いたページに戻り「page23.htmlを編集する」をクリックし、ページファイルのpage23.htmlを編集するページファイルエディターを開きます。HTMLでの記述内容を以下のように変更します。太字が追加する箇所を示します。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。番号にかかる部分は、SCRIPTタグのプログラムの内部にもあります。）</div>
<div class="code"><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type="text/javascript" src="def23.php"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
<strong>&lt;div style="display: flex"&gt;
&lt;div id="IM_NAVIGATOR"&gt;&lt;/div&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;作成日&lt;/th&gt;&lt;th&gt;タイトル&lt;/th&gt;&lt;th&gt;ユーザー&lt;/th&gt;&lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td data-im="invoice@id"&gt;&lt;/td&gt;
      &lt;td&gt;&lt;input type="text" data-im="invoice@issued"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;input type="text" data-im="invoice@title"/&gt;&lt;/td&gt;
      &lt;td data-im="invoice@authuser"&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table style="margin-left: 10px"&gt;
  &lt;thead&gt;
    &lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;作成日&lt;/th&gt;&lt;th&gt;タイトル&lt;/th&gt;&lt;th&gt;ユーザー&lt;/th&gt;&lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td data-im="invoice-all@id"&gt;&lt;/td&gt;
      &lt;td data-im="invoice-all@issued"&gt;&lt;/td&gt;
      &lt;td data-im="invoice-all@title"&gt;&lt;/td&gt;
      &lt;td data-im="invoice-all@authuser"&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;</strong>
&lt;/body&gt;
&lt;/html&gt;</code></pre></div>

<div class="step"><span class="stepnumber">2</span>「http://localhost:9080」で開いたページに戻り「page23.htmlを表示する」をクリックします。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div>
<div class="step"><span class="stepnumber">3</span>ログインパネルが表示されるので、ここではユーザー名、パスワードを「user2」としてログインを行います。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-334.png"/></div>
<div class="step"><span class="stepnumber">4</span>ページが表示されました。authenticationのキーのある左側のinvoiceコンテキストはレコードが表示されていません。右側のinvoice-allのコンテキストは、invoiceテーブルのすべてのレコードを表示しています。ユーザー列は、authuserフィールドの値を示しており、おそらくすべてのレコードが空欄になっていると思われます。ページネーションコントロールでは、現在のログインユーザーを確認できます。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-337.png"/></div>

<h4>コンテキストにレコードを追加する</h4>
<div class="step"><span class="stepnumber">1</span>左側のテーブルの下にある「追加」ボタンをクリックします。すると、左側にレコードが追加されます。作成日とタイトルを適当に入力します。作成日は、MySQLでは「2023-7-1」のように年月日、FileMakerでは「07/01/2023」のように、月日年でスラッシュ区切りとなるように入力します。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-338.png"/></div>
<div class="step"><span class="stepnumber">2</span>念のためにページネーションコントロールの「更新」ボタンをクリックして、ページ内容を更新します。左側には追加されたレコードが見えていますが、右側のテーブルにも見えるようになりました。</div>
<div class="step"><span class="stepnumber">3</span>左側で「追加」ボタンをクリックしてもうひとつレコードを追加します。そして、適当にフィールドに入力し、「更新」ボタンをクリックして、右側のテーブルも更新します。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-339.png"/></div>
<div class="step-wo-number">右側のテーブルは、inoviceテーブルをすべて表示しています。これに対して、authenticationキーを設定した左側は、「ログインをしているユーザー名が、authuserフィールドに設定されているレコードのみ見えている」という状況になっています。</div>
<div class="step"><span class="stepnumber">4</span>ページネーションコントロールの「ログアウト」ボタンをクリックして、ログアウトします。</div>
<div class="step"><span class="stepnumber">5</span>ログインパネルが表示されるので、次は前と違うユーザーでログインをします。例えば、ユーザー名とパスワードに「user3」と入力して「ログイン」ボタンをクリックします。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-340.png"/></div>
<div class="step"><span class="stepnumber">6</span>user3でログインをしました。まだ、authuserフィールドがuser3のレコードがないので、左側のテーブルにはレコードは表示されていません。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-341.png"/></div>
<div class="step"><span class="stepnumber">7</span>「追加」ボタンをクリックします。左側の「ユーザー」列にはすでにuser3と見えており、ログインしているユーザーのユーザー名が自動的に設定されていることが分かります。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-342.png"/></div>
<div class="step"><span class="stepnumber">8</span>フィールドに適当に入力し、ページを更新します。今度は、ログインしているuser3のレコードだけが左側で見えています。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-343.png"/></div>

<h4>データベースへのリクエスト内容を確認する</h4>
<div class="step"><span class="stepnumber">1</span>ページを更新し、レコードが表示された状態で、デバッグログは消さずに、左側のテーブルの下にある「追加」ボタンをクリックした状態にして、データベースへ送信されたSQLステートメントあるいはリクエストのパラメーターを確認します。なお、以下の画面は一例です。異なるユーザーでログインしている場合にはその名前に入れ替わるなど状況によって異なるので、手元の結果を確認してください。</div>
<div class="step"><span class="stepnumber">2</span>まず、invoiceコンテキストにレコードを追加する部分を探します。ログの中に「新規レコードアクセス: Accessing:/def23.php, Parameters:access=create&amp;name=invoice…」と記載された部分を特定します。</div>
<div class="step"><span class="stepnumber">3</span>[MySQLの場合]少し先にINSERTステートメントがあり、初期値としてauthuserフィールドに対してログインしているユーザーのユーザー名が入力されたレコードのみを検索しているSQLコマンドが見えています。（[FileMakerの場合]は表示が異なります。）</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-344.png"/></div>
<div class="step"><span class="stepnumber">4</span>続いて、invoiceコンテキストのデータ取得部分を探します。ログの中に「クエリーアクセス: Accessing:/def23.php, Parameters:access=read&amp;name=invoice…」と記載された部分を特定します。</div>
<div class="step"><span class="stepnumber">5</span>[MySQLの場合]その少し先に「SELECT * FROM `invoice`…」の部分をみてください。ここでは、authuserフィールドがログインしているユーザ名のuser3のレコードに絞り込む検索条件が自動的に追加されています。（[FileMakerの場合]は表示が異なります。）</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-345.png"/></div>

<h4>ユーザー名のフィールドの更新を阻止する</h4>
<div class="step"><span class="stepnumber">1</span>def23.phpを定義ファイルエディターで編集します。すでにタブあるはウインドウで見えている場合はそれを呼び出します。閉じてしまった場合には、「http://localhost:9080」で開いたページに戻り「def23.phpを編集する」をクリックします。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）「Show All」ボタンを押した状態でないのであれば、ページの冒頭にある「Show All」ボタンをクリックしてください。</div>
<div class="step"><span class="stepnumber">2</span>nameが「invoice」の方のコンテキストを特定します。「Authentication, Authorizaton and Security」の見出しにあるprotect-writingを「authuser」とします。Tabキーを押すなどして、入力したフィールドから別のフィールドに移動して、確実に保存をしてください。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-348.png"/></div>
<div class="step"><span class="stepnumber">3</span>page23.htmlをページファイルエディターで編集します。すでにタブあるはウインドウで見えている場合はそれを呼び出します。閉じてしまった場合には、「http://localhost:9080」で開いたページに戻り「page23.htmlを編集する」をクリックします。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div>
<div class="step"><span class="stepnumber">4</span>以下のように太字の箇所を変更します。左側のテーブルの「ユーザー」列のフィールドを、ページ上で変更可能にします。</div>
<div class="code"><pre><code>&lt;body&gt;
&lt;div style="display: flex"&gt;
&lt;div id="IM_NAVIGATOR"&gt;&lt;/div&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;作成日&lt;/th&gt;&lt;th&gt;タイトル&lt;/th&gt;&lt;th&gt;ユーザー&lt;/th&gt;&lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td data-im="invoice@id"&gt;&lt;/td&gt;
      &lt;td&gt;&lt;input type="text" data-im="invoice@issued"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;input type="text" data-im="invoice@title"/&gt;&lt;/td&gt;
      <strong>&lt;td&gt;&lt;input type="text" data-im="invoice@authuser"/&gt;&lt;/td&gt;</strong>
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
:</code></pre></div>

<div class="step"><span class="stepnumber">5</span>page23.htmlがすでにタブあるはウインドウで見えている場合はそれを呼び出し、ブラウザーの更新ボタンをクリックして、ページを再度表示します。閉じてしまった場合には、「http://localhost:9080」で開いたページに戻り「page23.htmlを表示する」をクリックします。（別の番号のセットで作業している場合には、該当する番号のリンクをクリックしてください。）</div>
<div class="step"><span class="stepnumber">6</span>左側のテーブルの「ユーザー」の列の適当なテキストフィールドの内容を書き換えてみます。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-347.png"/></div>
<div class="step"><span class="stepnumber">7</span>Tabキーを押して更新処理をしますが、更新ができない旨のエラーが表示されています。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-349.png"/></div>
<div class="step"><span class="stepnumber">8</span>ページを更新してください。書き直したフィールドは、データベース上では更新されていません。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-350.png"/></div>
<div class="step-wo-number">テキストフィールドでなければ書き直しはできませんが、それでも、定義ファイルへのアクセスを独自に記述して直接行うことで書き直してしまうことは、技術的には不可能ではありません（もちろん、プログラムを自分で作ることになります）。しかしながら、protect-writingの設定があれば、更新可能なコンテキストでも指定したフィールドは更新ができなくなります。</div>
<div class="step"><span class="stepnumber">9</span>「追加」ボタンをクリックして、レコードを追加してみます。レコードの追加はエラーなく行え、ユーザー列には現在ログインしているユーザー名が見えています。</div>
<div class="picture"><img class="picture-small" src="figs/ng-shot-351.png"/></div>

<h4>演習のまとめ</h4>
<ul><li>コンテキスト定義に設定を行うことで、レコード単位での参照や更新の可否を、ユーザーやグループに対して設定ができます。</li><li>参照時や更新、削除時には、ログインしているユーザー名であるものだけを絞り込む検索条件を付加します。新規レコード作成時には、自動的にログインしているユーザーの名前を指定したフィールドに設定します。</li><li>ユーザー名のフィールドだけをページ側から更新できなくすることもできます。</li></ul>

<h3><span id="H3-ANC-35"><span style="display:none">→</span></span>データベース外のファイルに対して<span xmlns="" id="ix-148"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-149"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>認証アクセスする</h3>
<p>　データベースからデータを取り出すときに、認証を確認し、アクセス権を適用しますが、一方で、画像などのようにデータベースに入れない情報の取り出しについても認証やアクセス権を設定したい場合もあります。ここでは、画像ファイルなどのデータを「メディアデータ」と呼ぶことにします。</p>
<p>　メディアデータを送信するための準備としては、メディアデータのファイルを保存するディレクトリをWebサーバーの公開ディレクトリ外に用意して、ディレクトリやファイルに適切な、すなわちWebサーバーのプロセスが、読み出し可能なアクセス権を設定しておくことです。そして、そのディレクトリのパスを、オプション設定（IM_Entry関数の2つ目の引数）のmedia-root-dirキーの値に指定します。これは、Webサーバーのドキュメントディレクトリ外にします。ドキュメント内部では、場合によっては偶発的にパスが漏洩してしまって、認証せずに画像を見られてしまうかもしれません。</p>
<p>　画像などのメディアデータをWebブラウザーから参照させるには、定義ファイルへのアクセスを利用します。定義ファイル自体はINTER-Mediatorの本体を取り出したり、データベースアクセスを行って結果を送り返すなどさまざまな用途に利用しますが、URLのパラメーターにmedia=で値を指定すると、その値を相対パスとしたファイルの内容を取り出します。基準となるパスは、media-root-dirキーの値です。</p>
<p>　例えば、nameキーの値がcontextというコンテキストがあって、そのコンテキストのimagefileフィールドに、画像ファイル名が入力されているとします。そのコンテキストにおいて、認証が通るか、オプション設定にあるユーザーやグループでの認証が通った時に、画像に対しても認証が通ったクライアントからのリクエストのみ受け付けるには、まず、コンテキストをリスト7-5-2のように記述します。必要最低限の記述を示します。</p>

<div class="code"><div class="caption">リスト7-5-2　メディアデータの読み出しに認証を適用する定義ファイルの例</div><pre><code>IM_Entry(
    array(
        array( //コンテキスト定義
            'name' =&gt; 'context',
            'key' =&gt; 'id',
            'authentication' =&gt; array(
               'media-handling' =&gt; true,
            ),
        ),
    ),
    array( // オプション設定
        'media-root-dir' =&gt; '/var/www/files',
        'authentication' =&gt; array(
        ),
    ),
    array('db-class' =&gt; 'PDO'),
    false
);</code></pre></div>

<p>　media-handlingがあれば、このコンテキストに対して読み出しのリクエストがあった時、そのレスポンスに、ランダムなコードを返します。そのコードを、定義ファイルのアクセス時にクッキーとしてサーバーに送り、そのコードがサーバーによって発行されたものであるならば、認証されたものとみなします。サーバーとクライアントで認証情報をやり取りする方法はクッキーで固定されています。1回のレスポンスで返るコードは、複数のメディアデータへのアクセスに利用できるので、逆に言えば、セキュリティ面には注意が必要です。この方法でメディアデータに認証を設定するのであれば、TLS 1.2での通信回線上の暗号化が必要になります。</p>
<p>　リスト7-5-2の定義ファイルがdef.phpだとして、contextコンテキストのimagefileフィールドにパスが保存されていた場合のIMGタグの記述例はリスト7-5-3の通りです。例えば、あるレコードで、imagefileフィールドが「products/pencil.jpg」だったとします。すると、「def.php?media=products/pencil.jpg」というURLがsrc属性に設定され、その時に画像を取得するリクエストが定義ファイルに対してクライアントから送られてきます。media=とあるのでmedia-root-dirの値と合成され、サーバー上では「/var/www/files/products/pencil.jpg」という絶対パスのファイルを開き、ファイルの内容とともにMIMEタイプを適切設定されたレスポンスがクライアントに返されます。その結果、サーバー上にある画像ファイルの内容が、クライアントにも見えるということです。このリクエストを送る時、media-handlingキーが設定されているので、サーバーから得られたコードをクッキーに乗せてサーバーに送り込み、サーバー側では自分が発行したものかを確かめて、そうであるならファイルの内容を返します。関係ないコードの場合には何も返しません。</p>

<div class="code"><div class="caption">リスト7-5-3　画像ファイルを取り出すIMG要素の例</div><pre><code>&lt;img src="def.php?media=" data-im="context@imagefile@#src" /&gt;</code></pre></div>

<p>　この章の最初に、ユーザー名やグループ名をフィールドに記述することで、そのレコードに対するアクセス権を指定したユーザーやグループにだけ許可する方法を『レコード単位のアクセス権』として説明しました。その特定のレコードに記録したパスのファイルを、特定のユーザーにだけ表示可能にすることもできます。なお、グループに対するアクセス権の設定はメディアデータではサポートしていません。</p>
<p>　まず、定義ファイルの例は、リスト7-5-4の通りです。オプション設定側には、メディアデータのルートを指定するmedia-root-dirを指定しています。そしてコンテキスト定義「context」にはauthenticationキーがあり、メディアデータに対する認証を行うための情報をコンテキストの構築時にクライアントに送ります。また、userフィールドに設定されたユーザーに対してレコードのアクセス権をCRUDのすべての操作に割り当てるようにしています。</p>

<div class="code"><div class="caption">リスト7-5-4　メディアデータの読み出しにレコードごとのアクセス権を適用する定義ファイルの例</div><pre><code>IM_Entry(
    array(
        array(
            'name' =&gt; 'context',
            'key' =&gt; 'id',
            'authentication' =&gt; array(
                'media-handling' =&gt; true,
                'all' =&gt; array(
                    'target' =&gt; 'field-user',
                    'field' =&gt; 'user',
                ),
            ),
            'protect-writing' =&gt; array( 'user' ),
        ),
    ),
    array( // オプション設定
        'media-root-dir' =&gt; '/var/www/files',
        'authentication' =&gt; array(
        ),
    ),
    array('db-class' =&gt; 'PDO'),
    false
);</code></pre></div>

<p>　そして、画像ファイルを取り出すIMG要素の例は、リスト7-5-5の通りです。レコード単位のアクセス権を設定するには、ファイル自体を規定されたディレクトリに入れる必要があります。例えば、ここでは、contextコンテキストのあるレコードについて、idフィールドは「120」、imagefileフィールドは「cutter.jpg」だったとします。以下のIMGタグの設定は、このファイルが「/var/www/files/context/id=120/cutter.jpg」である必要があります。つまり、media-root-dirと定義ファイルへのURLのmediaパラメーターの値を繋いだものがファイルのパスになるのは、単に認証を設定する場合と同じですが、そのファイルが、どのレコードに対するメディアデータなのかをパスで記録し、アクセス時には指定が必要です。つまり、「コンテキスト名/キーフィールド=その値」という相対パスを間に入れて、画像ファイル名を指定します。サーバー上でもこのようなディレクトリを用意して記録しておく必要があります。</p>

<div class="code"><div class="caption">リスト7-5-5　画像ファイルを取り出すIMG要素の例</div><pre><code>&lt;img src="defs.php?media=context/id=$/"
data-im="context@id@$src context@imagefile@#src" /&gt;</code></pre></div>

<p>　ここでは、contextコンテキストは、すべて、フィールドuserにログインしているユーザーと同じユーザー名がある場合のみに、データベースに対する処理が許可されています。メディアデータの読み込みの場合も同様ですが、リクエスト自体からアクセス許可されているかどうかを判定します。前の例だと、id=120のcontextコンテキストのレコードのuserフィールドと、ログインユーザー名が同じかどうかを確認します。ここで、他のユーザーに対するアクセス権があるパスを指定しても、userフィールドの値とログインユーザーは異なるため、メディアデータへのアクセスは拒否され、メディアデータ自体がユーザーのアクセス権を適用されていることになります。</p>
<p>　このような「context/id=120/cutter.jpg」のようなパスを指定するのは厄介ではありますが、計算フィールド等を利用して、パスを生成してもいいでしょう。また、『5-4　JavaScriptコンポーネントの利用』で指定したファイルのアップロードコンポーネントは、ファイルを保存するときにコンテキスト名や主キーフィールドと値を絡めたパスを生成します。つまり、「自分でアップロードしたファイルは自分しか見えない」という動作を想定して機能を組み込んでいます。</p>

<h3><span id="H3-ANC-36"><span style="display:none">→</span></span>このセクションのまとめ</h3>
<p>　ユーザー単位あるいはグループ単位にアクセス権を設定するテーブルの運用も可能です。ユーザー名やグループ名を記録するフィールドを用意し、定義ファイルのコンテキスト定義で、必要な設定を行います。メディアデータについても認証をかけることができます。なお、ユーザーによる制限のみがメディアデータに対しては可能です。</p>

<!-- ============ SECTION START ============ -->
<h2><span id="H2-ANC-6"><span style="display:none">→</span></span><span class="sectionnumber">7-6</span>メールを利用したユーザー登録とパスワードのリセット</h2>
<p class="section-lead">INTER-Mediatorのレポジトリの中には、ユーザー登録をメール確認後に行う機能を作るためのファイルや、パスワードのリセットをメール経由で行うためのファイルが含まれています。これらは、全くそのまま使えるものではないかもしれませんが、主要な機能は組み込まれているので、ページのデザインを合わせれば即座に使えるものです。これらの機能の動作やカスタマイズのポイントを説明しましょう。</p>

<h3><span id="H3-ANC-37"><span style="display:none">→</span></span>メールを利用した<span xmlns="" id="ix-150"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-151"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>ユーザー登録</h3>
<p>　INTER-Mediatorのレポジトリにある「samples/<span xmlns="" id="ix-152"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Auth_Support/<span class="referring">User_Enrollment</span>」フォルダーには、ユーザー登録を自動的に行う仕組みのための素材が入っています。管理者が1人ずつauthuserテーブルにレコードを作ればユーザーを増やすことができますが、オンラインサービスなどいつどこからアカウントの申し込みがあるか分からない場合には、リクエストごとにユーザーを追加するのは多大な手間を必要とします。そこで、オンラインから自動的に申し込みたいのですが、そうなると勝手に人のメールアドレスで登録をしてしまうなどのトラブルが懸念されます。そこで、メールアドレスとともに申し込みを行い、そのメールアドレス宛に本当に登録をしていいのかどうかを問い合わせ、メールを受信できた人が手作業で登録許可を行うという仕組みが一般的に利用されます。そのような仕組みは「<span xmlns="" id="ix-153"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>セルフサービス」と呼ばれることもあります。その仕組みの必要最小限の機能をコードで提供しますので、ご自分のニーズに合わせてデザインを行い、必要に応じて改変をしてください。ただし、改変にはPHPによるWebアプリケーションの開発に関する知識は必要です。『Chapter 8　サーバーサイドでのプログラミング』についても参照してください。</p>
<p>　なお、メールアドレスでの確認プロセスを行うサイトでは、ユーザー名をメールアドレスにすることが一般的と思われます。ここで紹介するプログラムも基本的にはユーザー名はメールアドレスにすることを前提にしています。そのためには、例えばparams.phpファイルに「$emailAsAliasOfUserName = true;」という行を指定します。しかしながら、改造をすればユーザー名もユーザー自身で指定できるようにできます。ただしそれはかなり大幅な改造になります。</p>
<p>　ユーザーの登録を「申し込み」と「確認」の2段階で行います。表7-6-1には、INTER-Mediatorに含まれるファイルのファイル名と主な用途をまとめました。</p>

<div class="table"><table><tr><th>段階</th><th>ファイル名</th><th>用途</th></tr><tr><td rowspan="5">申し込み</td><td>enroll.html</td><td>申し込みのページの基本HTML。JavaScriptのプログラムを含む</td></tr><tr><td>EnrollStart.php</td><td>ユーザーレコードを追加後に行う処理</td></tr><tr><td>enrollmail.txt</td><td>申し込みをした後に送られるメールの本文。ここに確認に必要な情報が含まれる</td></tr><tr><td>context.php</td><td>enroll.htmlで利用する定義ファイル</td></tr><tr><td>accountcheck.php</td><td>enroll.htmlで利用する指定したメールアドレスがすでに登録されているかを得るスクリプト</td></tr><tr><td rowspan="2">確認</td><td>confirm.php</td><td>確認の段階で呼び出される。処理は呼び出したときに実行されるが、処理結果はHTMLで表示</td></tr><tr><td>confirmmail.txt</td><td>確認をした後に送られるメールの本文。ここにログインに必要な情報が含まれる</td></tr></table><div class="caption">表7-6-1　User_Enrollmentフォルダーにあるファイル</div></div>

<p>　これらのファイルに記述された処理のポイントを説明し、読者の皆さんが改造して自身のアプリケーションに組み込むことができるようになることをここでの解説の目標とします。</p>

<h3><span id="H3-ANC-38"><span style="display:none">→</span></span>名前とメールアドレスを入力するページ</h3>
<p>　まず、accountcheck.phpは、指定したメールアドレスのレコードがすでに存在するかどうかを確認するためのものです。URLに「m=メールアドレス」で指定して呼び出すと、そのメールアドレスのレコードがauthuserテーブルにいくつあるかを返します。単独のファイルで、INTER-Mediatorのデータベースからの読み出しを行ってレコード数を数えて、クライアントにその数値のみを返します。</p>
<p>　enroll.htmlは、ポストオンリーモードで稼動するINTER-Mediatorのページファイルで、定義ファイルとしてcontext.phpを利用しています。authuserテーブルのrealnameとemailフィールドに入力するデータを受け付ける2つのテキストフィールドが用意されています。INTERMediatorOnPage変数のオブジェクトに定義するprocessingBeforePostOnlyContextメソッドを定義して、新規レコード作成のための通信を行う前に、メールアドレスがすでに登録されているものかどうかをaccountcheck.phpを同期通信で利用してレコード数を求め、すでに存在していればアラートボックスを表示して、新規レコードは作りません。</p>
<p>　context.phpにはuser-enrollというコンテキストがひとつ定義されています。authenticationキーの指定により、新規レコードの処理しかできなくしてあります。また、validationキーにより、名前の入力やメールアドレスの形式判定を行っています。メールアドレスの形式判定の正規表現は、非常に大雑把なものですので、厳密な検査が必要な場合には、正規表現を変更してください。さらにsend-mailキーにより、新規レコードを作った時に、enrollmail.txtファイルの内容を本文のテンプレートとして、作成したテーブルのemail, realname, hashの3つのフィールドの値をテンプレートに埋め込んで、テキストフィールドに指定したメールアドレスにメールが送信されます。enrollmail.txtファイルはもちろん、送信者等はご自分で利用可能なメールアドレスに変更してください。enrollmail.txtファイルでは、confirm.phpを呼び出す正しいURLを記述します。</p>

<h3><span id="H3-ANC-39"><span style="display:none">→</span></span>ユーザーレコードの作成前後に行う処理</h3>
<p>　コンテキストでは、extending-classキーで「EnrollStart」が指定されています。これにより、EnrollStart.phpファイルに記述された同名のクラスの処理が加わります。このクラスでは、新規レコードを作成する前に呼び出されるdoBeforeCreateToDBメソッドおよび作成後に呼び出されるdoAfterCreateToDBメソッドの2つのメソッドが定義されています。まず、doBeforeCreateToDBメソッドでは、authuserテーブルのハッシュ化したパスワードを保存するhashedpasswordフィールドの値として、無効な値であることが分かるように「dummydummydummy」を設定します。そして、usernameフィールドの値として、現在の日時とメールアドレスをつなげたものを指定しています。ここでは、usernameフィールドはユーザー側には見せないでシステム内部で使うためのものとして位置付けています。そのため、確実に重複のないユーザー名になるように文字列を作っています。もっとも、存在しないメールアドレスを利用しているのでシステム内のユニークIDとしてメールアドレスだけを使ったとしても、理論上は問題ありません。しかし、手作業でユーザーのレコードを作ることと併用したときに確実に区別できるように、意図的に日時とメールアドレスを組み合わせています。</p>
<p>　doAfterCreateToDBメソッドでは、updatedRecordメソッドにより、新規に作成されたレコードを取得しています。そして、userEnrollmentStartメソッドで、ランダムな文字列を作成し返り値として得ます。そのランダムな文字列は、issuedhashテーブルに保存されます。clientidフィールドをNULLにして、ユーザー登録時のランダム文字列であることが分かるようにしています。そして、setUpdatedRecordメソッドで、新規作成したレコードの中にhashフィールドを新たに付け加えて、ランダム文字列を値に指定しています。これで、送信するメールのテンプレートの3つ目のフィールドがレコードに加わり、ランダム文字列をメールに含めて送信できるのです。</p>

<h4><span class="object">DB_Proxy</span>-&gt;<span xmlns="" id="ix-154"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>userEnrollmentStart($userID)</h4>
<p class="exp">引数に指定したユーザーID（idフィールドの値）のユーザーを、userEnrollmentStartメソッドで有効化するためのコードを生成して返す。ユーザー作成時にコードを生成してメールとしてユーザーに送り、そのメールを受け取ったユーザーがコードを利用してアカウントをアクティベートする仕組みを提供する。</p>

<h3><span id="H3-ANC-40"><span style="display:none">→</span></span>レコード作成の確認とパスワードの設定</h3>
<p>　ユーザーレコードを作った後のメールに記載されたURLにより、confirm.phpが「c=ランダム文字列」のパラメーターを伴って呼び出されます。confirm.phpは、単独で稼働するファイルです。DB_Proxyクラスを生成してデータベース処理を2回行っています。まず、アルファベットと数字を使って6文字の初期パスワードを作成します。最初のDB_Proxyの生成ではコンテキストとは関係なく、userEnrollmentActivateUserメソッドを利用して、ランダム文字列を作成したユーザーのhashedpasswordフィールドに値を設定します。その処理に成功すると、2回目のDB_Proxyの生成を行い、その前に変数で定義したコンテキストに対するクエリーを行います。ここでは、作成したauthuserテーブルのレコードを検索して、その結果をもとにメールを送信することを行っています。メールのテンプレートはconfirmmail.txtです。このテンプレートによって出されるメールで、ユーザー名（メールアドレス）に対するパスワードが確定して通知されます。</p>

<h4><span class="object">DB_Proxy</span>-&gt;<span xmlns="" id="ix-155"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>userEnrollmentStart(userEnrollmentActivateUser($challenge, $password, $rawPWField = false))</h4>
<p class="exp">引数$challengeにはuserEnrollmentStartメソッドの返り値、$passwordには新たに設定するパスワードを指定して、ユーザーをアクティベートする。その結果、ユーザーには引数に指定したパスワードのハッシュが設定され、事前に決められたユーザー名とこのパスワードでログインができるようになる。もし、パスワードそのものをどこかのフィールドに残したい場合は3つ目の引数に、生のパスワードを残すフィールド名を指定する。</p>

<h3><span id="H3-ANC-41"><span style="display:none">→</span></span>メールを利用した<span xmlns="" id="ix-156"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-157"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>パスワードリセット</h3>
<p>　authuserテーブルのemailフィールドに、ユーザーごとに一意なメールアドレスが設定されている場合、そのメールアドレスを利用してパスワードのリセットを行うのが、INTER-Mediatorのディストリビューションにある「samples/Auth_Support/<span xmlns="" id="ix-158"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>PasswordReset」フォルダーにある一連のファイルです。</p>
<p>　パスワードのリセットの処理は2段階で行います。最初の「変更要求」の段階では、フォーム上でメールアドレスを入力すると、そのメールアドレスに、ランダムな文字列を伴ったURLが送られます。その文字列はシステム側で、メールアドレスに対応したユーザーを特定することができます。メールのURLにアクセスすると、2段階目の「変更処理」に移行し、メールアドレスに対応するユーザーのパスワードを入力してリセットできるページが開きます。メールアドレスに届くメールが特定のユーザーにしか参照できない状況が保持されていれば、他人にパスワードのリセットは行えない仕組みです。しかしながら、メール自体は暗号化されていないこともあり、絶対安全とは言えない方法です。Webアプリケーション自体の通信がTLSで暗号化されているのであれば、2段階の処理をなるべく早く行い、リセットを行った後、ログインパネルからパスワードを変更するのが安全な方法であると言えます。ログインパネル上での通信はTLSで暗号化されていて盗聴の危険性はないからです。</p>
<p>　それぞれのファイルについては表7-6-2に概要を示します。</p>

<div class="table"><table><tr><th>段階</th><th>ファイル名</th><th>用途</th></tr><tr><td rowspan="2">変更要求</td><td>requestpwreset.php</td><td>メールアドレスを指定して、変更処理が可能なURLをメールで知らせる</td></tr><tr><td>requestmail.txt</td><td>変更処理可能なURLを通知するメールのテンプレート</td></tr><tr><td rowspan="3">変更処理</td><td>resetpassword.php</td><td>パスワードの変更処理を行うフォーム形式のページ</td></tr><tr><td>resetcontext.php</td><td>resetpassword.phpから利用する定義ファイル</td></tr><tr><td>resetmail.txt</td><td>パスワード変更を通知するメールのテンプレート</td></tr></table><div class="caption">表7-6-2　Auth_Support/PasswordResetフォルダーにあるファイル</div></div>

<h3><span id="H3-ANC-42"><span style="display:none">→</span></span>パスワードの変更要求処理</h3>
<p>　パスワードの変更要求を行うrequestpwreset.phpには、メールアドレスを入力するテキストフィールドが2つあります。この部分は、INTER-Mediatorを使わない普通のフォーム形式になっています。Submitボタンをクリックすると、同じくrequestpwreset.phpを呼び出し、ファイルの前半に記述した処理を実行します。この部分のポイントは、DB_ProxyクラスのresetPasswordSequenceStartメソッドを呼び出しているところです。引数にはフォームで指定したメールアドレスを引数に指定します。そのメールアドレスを持つauthuserテーブルのレコードを特定し、issuedhashmテーブルにランダムな文字列をユーザーレコードのキーフィールドの値とともにレコードを作成して記述します。返り値はfalseなら処理が失敗、処理が成功すると連想配列が帰りますが、キーがranddataなら生成したランダム文字列、usernameならばauthuserテーブルのusernameフィールドを取り出すことができます。</p>
<p>　その後に、requestmail.txtをテンプレートとしてパスワードの変更要求があったことを、メールで知らせます。requestmail.txtでは、次の段階であるresetpassword.phpを呼び出すURLを正しく記述します。</p>

<h4><span class="object">DB_Proxy</span>-&gt;<span xmlns="" id="ix-159"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>resetPasswordSequenceStart($email)</h4>
<p class="exp">引数に指定したメールアドレスemailフィールドに持つレコードのユーザーのパスワードをリセットするために呼び出す。返り値は連想配列で、'randdata'キーはランダムな値、'username'キーはユーザー名を得られる。ランダム値をresetPasswordSequenceReturnBackメソッドで与えてパスワードのリセットの可否を決める。</p>

<h3><span id="H3-ANC-43"><span style="display:none">→</span></span>パスワードのリセット処理</h3>
<p>　resetpassword.phpは、定義ファイルをresetcontext.phpとするページファイルのようにも見えますが、このresetpassword.phpも一般的なフォームを利用したページです。定義ファイルを指定しているのは、パスワードのハッシュを生成するための関数を使うためだけです。</p>
<p>　フォームには、メールアドレスと、パスワードを2つ入力する場所があります。メールアドレスは、パスワード要求時にクッキーに記憶させているので、その情報で自動入力可能ですが、もちろん、要求を出したときに使っていたブラウザーを開いたままパスワードリセットの処理に入る必要があります。フォームへの入力が正しく行われているかどうかなどは、一般的なPHPによるフォームのアプリケーションの作成方法です。</p>
<p>　パスワードなどが入力されると、DB_ProxyクラスのresetPasswordSequenceReturnBackメソッドが呼び出されます。このメソッドは、メールアドレス、要求時に生成したランダムな文字列、そしてパスワードをハッシュ化した文字列を引数として持ちます。issuedhashテーブルを検索するなどして、ランダムな文字列がそのメールアドレスに対して発行されたものが確認されると、hashedpasswordフィールドの値を設定してパスワードのリセットが完了します。その結果trueが戻されます。</p>
<p>　trueが戻されると、念のために、パスワードが変更されたことを指定したメールアドレス宛にメールを送ります。もちろん、自分が行っていないようなパスワードリセットが何かの問題（未知の問題）で発生したときの手がかりになります。</p>

<h4><span class="object">DB_Proxy</span>-&gt;<span xmlns="" id="ix-160"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>resetPasswordSequenceReturnBack($username, $email, $randdata, $newpassword)</h4>
<p class="exp">引数には順番にユーザー名、メールアドレス、resetPasswordSequenceStartで得られるランダムなコード、そして設定する新しいパスワードを指定する。設定に成功すればtrueが返され、失敗するとfalseが返される。</p>

<h3><span id="H3-ANC-44"><span style="display:none">→</span></span>このセクションのまとめ</h3>
<p>　オンラインでメールを利用して承認を進める形式のユーザー登録、そしてメールアドレス宛にパスワード変更可能なURLを送付することでのパスワードリセット、これらの機能を持つ最小限のアプリケーションをINTER-Mediatorに含めています。オンラインサービスを構築するための素材として利用できます。このセクションではその動作の説明と、改良する場合のポイントをまとめてあります。</p>

<!-- ============ SECTION START ============ -->
<h2><span id="H2-ANC-7"><span style="display:none">→</span></span><span class="sectionnumber">7-7</span>SAML認証</h2>
<p>　INTER-Mediatorでは内蔵の認証システム以外に、SAMLに対応した外部の認証システムを利用した認証にも対応しています。ここではINTER-MediatorでSPを運用して、認証に利用する方法を説明します。なお、演習はありません。</p>

<h3><span id="H3-ANC-45"><span style="display:none">→</span></span>SAMLについて</h3>
<p>　<span xmlns="" id="ix-161"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>SAML（Security Assertion Markup Language）は、異なるドメイン間での認証を実現するXMLベースの規格ですが、現在はアプリケーションサーバーとは異なる認証サーバーで認証してアプリケーションを利用できる仕組みの基礎となる規格として利用されています。SAML Ver.2が2005年に制定され、現在もそのバージョンで利用されています。認証に利用できるサーバにはさまざまな種類がありますが、その認証サーバをシンプルに使うとなると、認証サーバの種類や方式ごとにアプリケーションサーバー側での対応が必要になります。一方、SAMLを利用することで、認証サーバによらない統一的な方法でアプリケーションに認証機能を組み込めるという点で非常に便利です。</p>
<p>　INTER-Mediatorでは内蔵の認証システムを持っており、単一の、あるいは同じデータベース上で稼働するアプリケーション上での認証機能はこれまでに説明したとおり実現できています。しかしながら、<span xmlns="" id="ix-162"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Active Directoryや<span xmlns="" id="ix-163"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>LDAPサーバに認証情報がすでにあるという組織の場合、それら認証サーバにあるアカウントを利用したいと考えます。INTER-MediatorはVer.6までの間に、LDAP、GoogleのOAuthに対応したクラスを用意してきましたが、認証方式ごとに対応するのは効率的ではないと考え、SAML2での認証に一本化をする前提で進めています。INTER-MediatorはVer.8でSAMLに対応しました。</p>
<p>　SAMLでは、認証の処理を実際に行う<span xmlns="" id="ix-164"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>IdP（<span xmlns="" id="ix-165"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Identity Provider）と、認証要求を行う<span xmlns="" id="ix-166"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>SP（<span xmlns="" id="ix-167"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Service Provider）が存在します。一般には、IdPは独立したドメインで運用し、SPはWebアプリケーションの内部に組み込んであるという状況が多いと思われます。IdP自身が認証処理を行う場合もありますが、別の認証サーバーと連携することもよく利用される形式です。例えば、IdPを立てると同時にIdPとLDAPサーバが通信して、実際のユーザ認証はLDAPサーバ側で行うという仕組みが構築できます。</p>
<p>　一方、SPは、Webアプリケーションと直接やりとりを行う部分です。SPとIdPはお互いに相互に<span xmlns="" id="ix-168"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>メタデータ交換を行なっています。具体的には、SPのメタデータをIdPに登録すると同時に、IdPのメタデータをSPに登録します。メタデータにはそれぞれのホストのSAMLをやり取りするURLの情報などが入っています。加えて、それぞれのホストの公開鍵が入っており、この公開鍵を利用して、双方の通信を暗号化しています。交換されたということで、双方は信頼できると判断できますが、信頼性の検証は結果的に人間が行うことになります。</p>
<p>　Webアプリケーションで認証が必要になり、SPを利用すると、最初はまずクライアントが、IdPの認証のためのURLにリダイレクトされて、ユーザは認証パネルでユーザ名とパスワードを入れることになります。認証が成功すると、Webアプリケーション側のURLにさらにリダイレクトされます。そして、WebアプリケーションがSPを利用すると、今度はIdPとのやりとりを含めて認証が成立しているので、Webアプリケーションはその結果をもとに認証が通った状態の処理を続けることになります。大まかには以上の流れで認証が進められます。</p>

<h3><span id="H3-ANC-46"><span style="display:none">→</span></span>PHPでSAMLを実現するSimpleSAMLphp</h3>
<p>　PHPでは<span xmlns="" id="ix-169"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>SimpleSAMLphpという名前のライブラリがよく利用されており、INTER-MediatorでもこのライブラリをSPとして利用します。SimpleSAMLphpはSPとしての機能だけでなく、IdPにもなります。なお、SimpleSAMLphpは2023年まではVer.1系列が開発されてきましたが、2023年よりVer.2系列に入ったものの、さらにVer.3のアルファ版も見えるなど、どのバージョンを使うのか迷う状況でもあります。Ver.1系列は、Ver.1.19.4まであり、これを利用するという方法もありますが、Ver.2についてはVer.2.0.4までがリリースされています。これらはユーザインターフェースが結構違っており、Ver.2の方が洗練したデザインなのではありますが、状況によってはVer.1を使うことになるかもしれません。なお、SimpleSAMLphpのバージョン1も2も、SAMLのバージョンはVer.2ですので混同しないようにしましょう。</p>
<p>　すでにIdPとなるものが存在していれば、Webアプリケーション側はSPの用意だけで済みます。例えば、<span xmlns="" id="ix-170"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>Shibboleth 1.3の認証サーバがある場合は、SPをセットアップすればOKです。なお、SimpleSAMLphpのVer.2ではShibbolethの機能は落とされているので、認証サーバがShibbolethの場合はVer.1系列で運用することも検討が必要です。</p>
<p>　一方で、IdPになるものがない場合、独自にIdPを立てる必要があります。もちろん、SimpleSAMLphpを使えば良いのですが、やはりサーバをひとつ起動して色々セットアップも難しいだけに、そこそこの手間はかかります。例えば、LDAPサーバーを利用したい場合、LDAPサーバーとIdPが連携するように、IdP側に設定を行います。SPはそのIdPを利用するというのが基本的な設置方法になります。</p>
<p>　ここからは、どこかにIdPが稼働しているという前提で話を進めます。IdP自体のセットアップも作業として発生する場合もあると思われますが、SimpleSAMLphpを使ったIdPの設置手順は筆者のBlog記事（<a href="https://blog.msyk.net/?p=1566" target="_blank">SimpleSAMLphp Ver.2を使ってみる(1)</a>、<a href="https://blog.msyk.net/?p=1580" target="_blank">SimpleSAMLphp Ver.2を使ってみる(2)</a>）で紹介しているので参考にしてください。</p>

<h3><span id="H3-ANC-47"><span style="display:none">→</span></span>INTER-MediatorをSAMLのSPにする</h3>
<p>　SimpleSAMLphpは、INTER-Mediatorのレポジトリのルートにある<span xmlns="" id="ix-171"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>composer.jsonファイルに記述があるので、composerを動かしたときにセットアップされます。もし、INTER-Mediatorディレクトリのルートをカレントディレクトリにしてcompose update等でインストールした場合、「INTER-Mediator/vendor/simplesamlphp/simplesamlphp」にSimpleSAMLphpがインストールされることになります。アプリケーションのテンプレートなどをINTER-Mediator自体もcomposerのインストール対象になっている場合は、「アプリケーションのルート/vendor/simplesamlphp/simplesamlphpにSimpleSAMLphp」にインストールされます。</p>
<p>　まず、そのSimpleSAMLphpのルートにある<span class="referring">publicディレクトリ</span>が、Web公開されている必要があります。この部分へWebブラウザからアクセスすることにより、SPの管理ページを開くことができるのです。通常、INTER-Mediatorのディレクトリは公開しているので、publicディレクトリも公開されているのですが、さらに、「https://ホスト名<span xmlns="" id="ix-172"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>/simplesaml」のURLで、そのpublicディレクトリを参照できるように設定を行います。管理ツールを使う場合など、simplesaml以下に自動的にパスが設定されるので、ドキュメントルートからsimplesamlで、SimpleSAMLphpのpublicに接続できるようにしておく必要があります。例えば、Apache2の場合だとリスト7-7-1のような<span class="referring">Alias</span>ディレクティブを記述するなどします。</p>

<div class="code"><div class="caption">リスト7-7-1　/simplesamlで公開すべきpublicディレクトをアクセスできるようにする</div><pre><code>Alias /simplesaml "/var/www/demo_im_com/saml-trial/lib/src/INTER-Mediator/vendor/simplesamlphp/simplesamlphp/public"
# INTER-Mediatorは、/var/www/demo_im_com/saml-trial/lib/src/INTER-Mediator
# INTER-Mediator/vendor内にSimpleSAMLphpが存在する</code></pre></div>

<h3><span id="H3-ANC-48"><span style="display:none">→</span></span>SPの設定ファイルを用意する</h3>
<p>　composerでインストールしたSimpleSAMLphpをSPとして利用するには、これらのディレクトリ内に設定ファイルを記述しなければなりません。設定ファイルをディレクトリ内部に直接記述してもいいのですが、composerの操作によってはそれらは消されてしまうので、どこか別のディレクトリに設定ファイルを作っておき、その設定ファイルを該当する場所にコピーして運用することにします。設定をサポートするスクリプトが「INTER-Mediatorのルート/samples/<span xmlns="" id="ix-173"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>saml-config」にあります。このsaml-configフォルダをどこかにコピーします。例えば、アプリケーションのルート以下、libディレクトリあたりにコピーをしておき、必要ならアプリケーション自体のレポジトリに設定ファイルを記録しておくと良いでしょう。以下、「コピーしたsaml-configフォルダ」として、コピー先のフォルダを参照します。</p>
<p>　コピーしたsaml-configフォルダには、<span xmlns="" id="ix-174"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>gettemplates.shというスクリプトがあります。このスクリプトは、libあるいはlib/src、さらにはアプリケーションのルートにあるvendorディレクト以下のINTER-Mediatorを探して、そこから設定ファイルのテンプレートをコピーします。いずれにしても、このgettemplates.shをシェルスクリプトとして稼働すると、ディレクトリを探して、config.php、authsources.php、acl.php、saml20-idp-remote.php、saml20-idp-hosted.php、saml20-sp-remote.phpのコピーを作ります。ファイルが作られない場合には想定したフォルダにINTER-MediatorやSimpleSAMLphpが存在しないことになり、その場合はスクリプトを修正して、設定ファイルのテンプレートが存在するディレクトリに変更してください。これらのファイルのうち、通常はconfig.php、authsources.php、saml20-idp-remote.phpのファイルを変更します。</p>

<h3><span id="H3-ANC-49"><span style="display:none">→</span></span>証明書の用意</h3>
<p>　SAMLではSP、IdPともに<span xmlns="" id="ix-175"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>証明書を作ります。証明書というよりも、<span xmlns="" id="ix-176"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>秘密鍵と公開鍵を作り、メタデータ交換により公開鍵を相手（SPならIdP）に渡しておくことで、自分自身への暗号化通信を実現しています。ただ、秘密鍵と公開鍵よりも、証明書として鍵を作った方が何かと便利なので、証明書を用意します。これは、WebサイトのTLSのために用意したものでも構いませんが、SimpleSAMLphpのインストールの説明では、<span class="referring">自己署名証明書</span>で期限が10年と言った証明書を作っており、確かに一定の条件を満たせば、それでも問題はないとも言えるでしょう。以下のコマンドは、saml-configディレクトリを利用するという前提なので、saml-configをカレントディレクトリにしてコマンド入力します。そして、生成する秘密鍵のファイルと証明書のそれぞれは、ファイル名をsp.pem、sp.crtというきめうちのファイル名にします。</p>

<div class="code"><div class="caption">リスト7-7-2　自己署名証明書を生成するコマンドの例</div><pre><code><span xmlns="" id="ix-177"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>openssl req -newkey rsa:3072 -new -x509 -days 3652 -nodes -out sp.crt -keyout sp.pem</code></pre></div>

<p>　このコマンド入力後、証明書の内容についての問い合わせが行われます。これらは適当に入力すればいいでしょう。ただし、Common NameではSPを稼働するホスト名を正しく入れておくのが良いと思われます。</p>

<h3><span id="H3-ANC-50"><span style="display:none">→</span></span>設定ファイルの修正</h3>
<p>　続いて、コピーしてきた設定ファイルを修正します。まず、<span xmlns="" id="ix-178"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>config.phpについては、以下のキーの値を修正します。これらのキーはファイル内で連続した場所にないので、ひとつずつ探して修正をしていきましょう。なお、baseurlpathは、publicディレクトリがある場所への絶対パスを記述します。technicalcontact_emailは自分のメールアドレスを指定します。secretsaltについては乱数から生成しますが、ファイルのコメントで生成のためのコマンドが紹介されているので、そのコマンドで生成します。auth.adminpasswordはSPの管理ページで利用できるパスワードを指定します。</p>

<div class="code"><div class="caption">リスト7-7-3　config.phpファイルの修正ポイント</div><pre><code>'baseurlpath' =&gt; 'saml-trial/lib/src/INTER-Mediator/vendor/simplesamlphp/simplesamlphp/public/',
'technicalcontact_email' =&gt; 'your_email',
'secretsalt' =&gt; 'your_salt',
'auth.adminpassword' =&gt; 'your_admin_pass',</code></pre></div>

<p>　続いて<span xmlns="" id="ix-179"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>authsources.phpを修正します。default-spキーの配列の要素に、certificateとprivatekeyのエントリーを用意して、ここで作成したキーファイルと証明書ファイルを指定します。そして、entityIDをサイトのドメインに設定しておきます。</p>

<div class="code"><div class="caption">リスト7-7-4　authsources.phpファイルの修正ポイント</div><pre><code>'default-sp' =&gt; [
  'saml:SP',
  'certificate' =&gt; 'sp.crt',
  'privatekey' =&gt; 'sp.pem',

   // The entity ID of this SP.
   'entityID' =&gt; 'https://demo.inter-mediator.com/',
   :</code></pre></div>

<p>　さらに、<span xmlns="" id="ix-180"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>saml20-idp-remote.phpを修正します。このファイルの最後（とはいえ、中身は短いコメントがあるのみ）に、IdPの管理ページからコピーした<span xmlns="" id="ix-181"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-182"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>IdPのメタデータを示す配列をコピーしておきます。</p>

<div class="picture"><img class="picture-small" src="figs/ng-shot-370.png"/><div class="caption">図7-7-1　saml20-idp-remote.phpにIdPのメタデータを追加する</div></div>

<h3><span id="H3-ANC-51"><span style="display:none">→</span></span>書き直した設定ファイルなどを展開する</h3>
<p>　証明書を用意し、設定ファイルを書き直すと、<span xmlns="" id="ix-183"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>saml-configディレクトリに入っている<span xmlns="" id="ix-184"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>copyconfig.shというスクリプトファイルを実行します。これも、最初に稼働させたgettemplates.shと同様に、SimpleSAMLphpをいくつかの典型的な場所から探してその内部のいくつかのフォルダにファイルをコピーします。スクリプトを実行して、エラーが出なければ、おそらくはファイルの元をコピーしたSimpleSAMLphpのフォルダへ、設定ファイルを書き出していると思われます。もし、うまくいかない場合はスクリプトを修正するなどしてください。なお、このスクリプトで実行しているのは、sp.pem、sp.crtをSimleSAMLphpのルート以下certディレクトリへ、config.php、authsources.phpをconfigディレクトリへ、saml20-idp-remote.phpをmetadataディレクトリへコピーしています。</p>
<p>　なお、設定変更するときには、saml-configディレクトリにあるファイルを変更して、その都度、copyconfig.shスクリプトを実行すれば良いでしょう。</p>

<h3><span id="H3-ANC-52"><span style="display:none">→</span></span><span xmlns="" id="ix-185"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-186"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>SPのメタデータを取り出す</h3>
<p>　以上で、SPとして稼働するはずです。ここで、SPの管理ページにログインをして、SPのメタデータを取り出します。そのためには、ブラウザより「https://ホスト名<span xmlns="" id="ix-187"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>/simplesaml/admin」に接続します。図7-7-2のようなログインパネルが表示されるので、ユーザ名はadmin、パスワードはconfig.phpのauth.adminpasswordキーに指定したパスワードを指定して認証します。ログインできるはずです。</p>

<div class="picture"><img class="picture-small" src="figs/ng-shot-371.png"/><div class="caption">図7-7-2　SPの管理ページにログインする</div></div>

<p>　管理ページにはさまざまな機能がありますが、上部で「連携」をクリックして、Hosted entitiesを表示し、そこにあるdefault-spの「V」の部分をクリックして、メタデータを表示します。このメタデータを、IdPの管理者に渡してこのデータをIdP側に登録すると、SAML認証ができるようになります。なお、通常はメタデータはXMLですが、IdPがSimpleSAMLphpなら、PHPのコードの方が作業が一手間少なくて済みます。</p>

<div class="picture"><img class="picture-small" src="figs/ng-shot-372.png"/><div class="caption">図7-7-3　SPのメタデータを取得する</div></div>

<h3><span id="H3-ANC-53"><span style="display:none">→</span></span><span xmlns="" id="ix-188"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-189"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>SAML認証の設定と動作</h3>
<p>　SAML認証に関わる設定は、params.phpで行います。リスト7-7-5に使用できる変数を示しました。</p>

<div class="code"><div class="caption">リスト7-7-5　params.phpファイルでのSAML関連の設定</div><pre><code>$isSAML = true; # The default value of isSAML is false.
$samlAuthSource = 'default-sp';
$samlExpiringSeconds = 1800;
$samlWithBuiltInAuth = true;
$samlAttrRules = ['username' =&gt; 'uid|0', 'realname' =&gt; 'eduPersonAffiliation|0'];
$samlAdditionalRules = ['username' =&gt; '(user02|user03)'];</code></pre></div>

<p>　まず、SAML認証の機能を有効にするかどうかは、<span xmlns="" id="ix-190"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>$isSAML変数で指定をします。通常はfalseになっているので、ここで明示的にtrueを代入しなければなりません。あるいは、IM_Entry関数の第2引数（オプション設定）で、authenticationキーの配列で<span xmlns="" id="ix-191"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>is-samlキーでtrue値を指定しても設定可能です。この設定と同時に、$samlAutuSource変数で、<span xmlns="" id="ix-192"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-193"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>SPのソース名を設定します。これまでの手順通りなら、設定名は「default-sp」になっているはずです。</p>
<p>　$isSAMLをtrueにすると、認証が必要なページでは、IdPのログインページにリダイレクトし、認証後はアプリケーションのページに戻るという動作になります。このとき、INTER-Mediatorは、内部的には組み込みのユーザを作り、通常の認証はそちらで行います。これは、認証サーバに都度都度認証処理をさせるとスピードが遅くなることを懸念してのことで、IdPでの認証が成功すると、特別な組み込みユーザを作り、乱数でパスワードを自動生成して認証の継続を行うようにします。ただし、直前の処理から<span xmlns="" id="ix-194"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>$samlExpiringSecondsで指定した秒数経過していると、改めてIdPに認証を求めます。通常はIdP/SPの連携によって認証状態が継続されますが、例えば何日も経過していると、IdPの認証パネルが出てくるようになっているのが一般的な動作でしょう。</p>
<p>　なお、SAML認証では、組み込みの認証の機能も使うので、$passwordHash = '2'; の定義も行うようにしてください。</p>
<p>　<span xmlns="" id="ix-195"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>$samlWithBuiltInAuthをtrueにすると、組み込みのユーザでのログインが可能になります。これを未定義のままにすると、この変数値はfalseになり、SAMLつまりはIdPが管理するユーザで以外はログインできません。一方trueにすると、IdPのユーザと、authuserテーブルで定義したユーザの両方でのログインが可能になります。このとき、アプリケーションでは、INTER-Mediatorのログインパネルを表示しますが、ログインパネルに<span xmlns="" id="ix-196"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>「SAML認証」ボタンが追加されています。authuserに設定してあるユーザは通常通りログインパネルでユーザーとパスワードを入力してログインしますが、IdPのユーザでログインするには「SAML認証」ボタンをクリックして、IdPのログインページに移動して、ログインをする必要があります。</p>
<p>　<span xmlns="" id="ix-197"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>$samlAttrRules変数は、認証時に得られる情報からauthuserテーブルにユーザを作るときにどのデータを取り出してどのフィールドに入力するかを示しています。変数に値を設定しなければ、uidの最初のデータをauthuserテーブルのusernameフィールドに設定するだけになります。この変数は連想配列で指定しますが、キーはauthuserテーブルのフィールド名、値はSAML認証で得られる認証ユーザーの情報からどのキーの何番目の配列の値を取り出すかを指定します。'realname' =&gt; 'eduPersonAffiliation|0'であれば、認証結果から得れたeduPersonAffiliationというキーの配列の最初の要素を、realnameフィールドにセットするということです。|の前にエントリー名、|に続いて配列の何番目の要素かを指定します。SAMLで得られるデータが複雑な場合は、この変数の要素として、'email' =&gt; 'urn:oid:0.9.2342.19200300.100.1.3|0' と言ったような記述を行うことにもなります。値の|までの部分はurn表記でのフィールド名となります。この設定は、次に説明する$samlAdditionalRulesに関連が深いとも言えます。</p>
<p>　変数の<span xmlns="" id="ix-198"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>$samlAdditionalRulesは連想配列を指定し、authuserテーブルのフィールド名とそれに対する値を指定します。これは、認証したユーザーの情報に対して、特定のフィールドが想定された値であるかどうかをチェックすることを意味し、連想配列の定義、つまりあるフィールドの値が決められたものでなければ、認証を失敗したものとみなすという処理になります。言い換えれば、ユーザ属性に応じて認証を失敗させる設定が可能です。この配列の値は、正規表現での指定が可能です。'username' =&gt; '(user02|user03)'であれば、username、つまりSAML認証で得られたuid[0]の値がuser02かuser03のユーザでないと認証は成立しないようになります。</p>
<p>　$samlAttrRulesと$samlAdditionalRulesの定義に関しては、一般的な説明が難しいですので、詳細な設定が必要な場合には、INTER-Mediatorのソースをチェックされることをお勧めします。設定に必要な情報はデバッグ情報として見えるようにはなっていますが、ソースと対照しないと分かりづらいと思われます。</p>

<h3><span id="H3-ANC-54"><span style="display:none">→</span></span>SAML動作に関するJavaScript</h3>
<p>　通常は、JavaScriptでのプログラミングは、SAML認証に関しては不要です。ただし、<span xmlns="" id="ix-199"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span><span xmlns="" id="ix-200"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>SAMLのログアウトを行うためのURLについては、<span xmlns="" id="ix-201"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>INTERMediatorOnPage.logoutURLにセットされています。このURLにジャンプすると、SAML認証が解消されるので、自分でログアウトボタンを作る場合にはこれを利用すると良いでしょう。なお、INTERMediatorOnPage.logout()も同時に呼び出すようにしてください。ページネーションの「ログアウト」ボタンは、これらのメソッドやURLジャンプのいずれも組み込まれています。</p>
<p>　$samlWithBuiltInAuthをtrueにしたときにログインパネルに表示される「SAML認証」ボタンにより、IdPのログインページに自動的に移動します。その移動さきのURLは、<span xmlns="" id="ix-202"><xhtml:span xmlns:xhtml="http://www.w3.org/1999/xhtml" style="display:none;">→</xhtml:span></span>INTERMediatorOnPage.loginURLより得られます。これについても、何かしら特定のUIを自分で組むようなときには必要な情報かもしれません。</p>
<p>　なお、logoutURL、loginURLのいずれのプロパティも、最初にログインした直後や、あるいは設定を変えて使い始めた直後などはnullになっている場合もあります。念の為nullかどうかをチェックしてから利用するようにしてください。これらのプロパティは、SAML認証以外の場合ではnullになっています。</p>


<h3><span id="H3-ANC-55"><span style="display:none">→</span></span>このセクションのまとめ</h3>
<p>　INTER-MediatorはSAMLに対応しています。SAMLのSPとして、Webアプリケーションに組み込んだSimpleSAMLphpを稼働させるための設定について、このセクションでは説明をしました。外部の認証サーバを利用したアプリケーション構築を行う場合には、SAMLの利用をまず検討しましょう。</p>

<!--
<p></p>




<h3></h3>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
-->


<!--以下、画像として ng-shot-352〜ng-shot-369を準備してある-->
<!--
<h3>OAuth2を認証に利用する</h3>
<p>INTER-Mediator Ver.5.3より、<span class="index"><span class="indexword" yomi="OAuth2">OAuth2</span><span class="indexword" yomi="でのにんしょう">〜での認証</span></span><span class="index"><span class="indexword" yomi="にんしょう">認証</span><span class="indexword" yomi="OAuth2での">OAuth2での〜</span></span>OAuth2での認証に対応しました。しかしながら、Ver.5.3の段階では、GoogleのアカウントによるOAuth2認証（もしくはOpenID認証）にのみ対応しています。今後のバージョンで、他のサービスプロバイダーにも対応が進むと思われますが、その場合には設定方法に若干違いが出てくる可能性もあります。</p>
<p>OAuth2での認証を行うには、認証プロバイダーによって発行されるIDやパスフレーズなどを入手しなければなりません。以下、Googleでの準備の流れを記述しますが、Googleの開発者向けサイトは変更が多く、ここで記述した通りではないかもしれません。この画面は、2016年1月27日に撮影したものです。また、Googleには多種多様なアカウントがありますが、以下の流れは個人で取得したGmailのアカウントを利用しています。少なくとも、<span class="index"><span class="indexword" yomi="Google Apps for NPO">Google Apps for NPO</span></span>Google Apps for NPOで作成したアカウントでは異なる応答をすることが分かっており、そのバリエーションはINTER-Mediatorに実装済みです。その他のバリエーションは確認のしようがないため、このセクションでは演習とせずに、手順のみを示します。</p>

<div class="stepauto"><span class="index"><span class="indexword" yomi="Google Developers Console">Google Developers Console</span></span>Google Developers Console（<a href="https://console.developers.google.com/">https://console.developers.google.com/</a>）に接続します。自分自身のGoogleのアカウントで認証してください。</div>
<div class="stepauto">最初にプロジェクトを作成します。ひとつのWebアプリケーションでひとつのプロジェクトを作成するのが適切と考えられます。ページの上部の青背景のバーの中で右寄りの位置で文字が見えている箇所があります。画面ショットでは「IM-OAuth-Test」と見えていますが、この文字列はログインした人によって変わります。ここをクリックするとドロップダウンが表示されるので、「プロジェクトの作成」を選択します。</div>
<div class="picture"><img class="picture-small" src="figs/shot3151.png" /></div>
<div class="stepauto">新しいプロジェクトを作成するパネルが表示されました。ここでは適当にプロジェクト名を指定して、「作成」ボタンをクリックします。</div>
<div class="picture"><img class="picture-small" src="figs/shot3152.png" /></div>
<div class="stepauto">ダッシュボードの冒頭に新しく作られたプロジェクトが表示されました。ページ上部の青背景のバーでは、作成したプロジェクト名が見えていて、現在、そのプロジェクトが選択されていることが分かります。プロジェクト名の下の部分をクリックすると、プロジェクトIDなどを表示したり非表示にしたりができます。これらの番号は、Webアプリケーションでは使用しません。</div>
<div class="picture"><img class="picture-small" src="figs/shot3153.png" /></div>
<div class="stepauto">続いて「API Manager」の機能を利用します。前の手順の画面ショットのように、「Google APIを利用する」という青いボックスが見えていれば、そのボックスをクリックします。すでにある程度の設定があれば青いボックスは見えないかもしれませんが、プロジェクトの概要の下に「API」マークのアイコンが見えている場合もあります。状況によって移動方法が変わりますので、臨機応変に作成をしてください。</div>
<div class="picture"><img class="picture-small" src="figs/shot3163.png" /></div>
<div class="stepauto">多数のAPI名がありますが、Social APIのグループにあるにある「Google+ API」をクリックします。画面ショットの状態から、少しスクロールすると、左側にSocial APIのグループが出てきます。</div>
<div class="picture"><img class="picture-small" src="figs/shot3154.png" /></div>
<div class="stepauto">Google+ APIは最初は無効になっていますが、ページ上部の「APIを有効にする」ボタンをクリックして、Google+ APIを有効にしてください。GoogleのOAuth2の仕組みを利用するには、このAPIをオンにしておく必要があります。</div>
<div class="picture"><img class="picture-small" src="figs/shot3166.png" /></div>
<div class="stepauto">左側にある「認証情報」をクリックします。そして、「新しい認証情報」ボタンをクリックして認証情報を追加します。</div>
<div class="picture"><img class="picture-small" src="figs/shot3156.png" /></div>
<div class="stepauto">ポップアップメニューでは「OAuthクライアントID」をクリックします。</div>
<div class="picture"><img class="picture-small" src="figs/shot3157.png" /></div>
<div class="stepauto">何も項目がないときには、同意画面の仕様を決める必要があります。「同意画面を設定」をクリックします。</div>
<div class="picture"><img class="picture-small" src="figs/shot3158.png" /></div>
<div class="stepauto">同意画面では、ログインしているユーザーのメールアドレスとサービス名を指定します。他はオプションになっていますが、同意を求める時のアイコンなどは後からでも指定できます。「保存」ボタンをクリックします。</div>
<div class="picture"><img class="picture-small" src="figs/shot3159.png" /></div>
<div class="stepauto">アプリケーションの種類では「ウェブアプリケーション」を選択します。「名前」は適当な識別名を記述します。そして、「承認済みのリダイレクトURI」の指定を行います。このURLのファイルは、Webアプリケーション側に用意しておく必要があり、Webアプリケーションの利用者のブラウザーからアクセス可能なものを指定します。このファイルの内容については、この後に説明をします。「作成」ボタンをクリックします。</div>
<div class="picture"><img class="picture-small" src="figs/shot3160.png" /></div>
<div class="stepauto">クライアントIDとクライアントシークレットの2つのコードが発行されました。このコードは2つともWebアプリケーションの設定として追加します。OKボタンをクリックします。</div>
<div class="picture"><img class="picture-small" src="figs/shot3161.png" /></div>
<div class="stepauto">認証情報に、項目が追加されました。右端のボタンをクリックすると、Webアプリケーションに必要な値を含むJSON形式のファイルがダウンロードできるので、実際に開発しているアプリケーションで指定するときにはそのファイルを利用すると良いでしょう。</div>
<div class="picture"><img class="picture-small" src="figs/shot3162.png" /></div>

<p>以上の手順で認証情報をGoogle側に作成します。後からの変更や参照は、API Managerに移動して、左側で「認証情報」を選択することで可能です。その時、プロジェクトをページ上部の青背景のバーで選択をしておきます。</p>
<p>認証情報の一覧の右にあるアイコンからダウンロードしたファイルの内容を整形したものを<span class="nextlist">次のリスト</span>に示します。params.phpファイルには<span class="nextlist" bias="1">次のリスト</span>のように指定をします。$oAuthProviderは「Google」、$oAuthClientIDはJSONファイルのclient_idキーの値、$oAuthClientSecretはJSONファイルのclient_secretキーの値、$oAuthRedirectはJSONファイルのredirect_urisキーの値のひとつを指定します。JSONファイルのその他の値は指定しなくて構いません。</p>

<div class="code">
<div class="caption">生成した認証情報（一部のデータは省略）</div>
<pre><code>{
    "web": {
        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs", 
        "auth_uri": "https://accounts.google.com/o/oauth2/auth", 
        "client_id": "672355285449-utu17kjmnk70k06rauro2l....", 
        "client_secret": "Dp6Rhoc6V3KMH....", 
        "project_id": "bustling-shape-120216", 
        "redirect_uris": [
            "http://msyk.net/awosomesystem/OAuthCatcher.php"
        ], 
        "token_uri": "https://accounts.google.com/o/oauth2/token"
    }
}</code></pre>
</div>
<div class="code">
<div class="caption">params.phpファイルに指定するOAuth2関連の設定</div>
<pre><code>$oAuthProvider = "Google";
$oAuthClientID = '672355285449-utu17kjmnk70k06rauro2l....';
$oAuthClientSecret = 'Dp6Rhoc6V3KMH....';
$oAuthRedirect = 'http://msyk.net/awosomesystem/OAuthCatcher.php';</code></pre>
</div>

<p>この状態で、例えばサンプルにある認証付きのフォームのページを動作してみます。サンプルの一覧では、左側の列で「Authentication Pages」に記述されているサンプルを動作させます。ファイルは、Samples/Sample_Authにあります。この段階でのテストでは、アクセス権の設定はしないで、認証だけが有効になるようにします。つまり、定義ファイルのコンテキストにはauthenticationキーの指定はなく、第2引数（オプション指定）にauthenticationキーがあり、そのキーの値の配列では、storingキーとrealmキーだけが指定されている状態にします。</p>
<p>ページを開くと、通常は最初にログインパネルが表示されます。ログインパネルには<span class="nextpicture">次の図</span>のように「OAuth認証」ボタンが見えており、Googleのアカウントでログインをするにはこのボタンをクリックします。ログインパネルにあるパスワード変更では、Googleなどの認証サービスプロバイダー側のパスワードの更新はできません。通常のログインのためのユーザーやパスワードを入れる枠も、不要といえば不要です。ただし、Google等の外部のプロバイダーによるアカウント以外に、authuserテーブルに追加したユーザーでも認証して利用した場合には、このままでも可能です。つまり、OAuth2対応にしても通常のログイン認証もできます。</p>

<div class="picture"><div class="caption">OAuth2をサポートするページでの認証パネル</div>
<img class="picture-small" src="figs/shot3164.png" /></div>

<p>「OAuth認証」ボタンにより、ブラウザーのページは認証情報にあるauth_uriのURLを開きます。すると、認証情報の利用の許可を求められます。<span class="nextpicture">次の図</span>はその例ですが、ちょっと殺風景です。しかしながら、見出しにはプロジェクト名があるので、プロジェクト名を適当な名前にしないで、きちんとWebアプリケーションを連想させる名前を付けておくべきでしょう。Google Developer ConsoleのAPI Managerにある「認証情報」の「OAuth同意画面」のところに情報を加えれば、そこに指定した情報もこの許可をリクエストするページに表示されます。つまり、利用者は自分自身の手作業で、Googleのアカウントを認証情報として利用する許可を行います。なお、複数のGoogleアカウントにログインをしている場合は、どのアカウントを利用するのかをたずねるページも表示されるので、どちらかを選択します。</p>

<div class="picture"><div class="caption">認証情報の利用の許可を求められる</div>
<img class="picture-small" src="figs/shot3165.png" /></div>

<p>「許可」をすれば、認証情報にあるredirect_urisキーのURLに対して、自動的にパラメーターが付与されて<span class="index"><span class="indexword" yomi="リダイレクト">リダイレクト</span></span>リダイレクトされます。この「リダイレクトURL」はWebアプリケーション側で用意をします。そのための雛型的なファイルが<span class="index"><span class="indexword" yomi="Auth_Support/OAuthCatcher.php">Auth_Support/OAuthCatcher.php</span></span>Auth_Support/<span class="index"><span class="indexword" yomi="OAuthCatcher.php">OAuthCatcher.php</span></span>OAuthCatcher.phpです。実際に利用する場合には、このファイルをフォルダーの外にコピーして、改変して利用するのが良いでしょう。OAuthCatcher.phpでは、リダイレクトされたときにGoogleと通信を行い、まず、認証の確認を行います。その後、Googleと通信をして、そのアカウントのさまざまな情報を得ます。その中から、氏名と電子メール、そしてユーザー名に相当する情報を得て、authuserテーブルに対してそれぞれrealname、email、usernameのフィールドに追加します。realnameやemailフィールドがない場合には、氏名を記録できる文字型のフィールドを用意します。</p>
<p>usernameに相当するユーザー名は、プロバイダーから与えられる一意な番号と、プロバイダーを示すドメイン名を@で結んで指定しています。この名前は自動的に入力するだけなので、手で打ち込むことはありません。初めて認証が成功したときには、authuserテーブルにユーザーを追加します。その時に、ランダムな文字列のパスワードを生成して、それをクライアントに伝達します。クライアントはユーザー名とパスワードのハッシュを保持することで、以後、認証状態を継続します。つまり、OAuth2による認証後は、INTER-Mediatorの通常の認証処理を行います。そして、24時間は認証結果を継続します（この有効時間はいずれ変数等で指定できるようにします）。</p>
<p>OAuthCatcher.phpによってGoogleと通信して、認証の確認が行われ、その後に、「OAuth認証」ボタンを押したページにリダイレクトします。通常は、認証が成り立った後となるので、ページは自動的に開きます。<span class="nextpicture">次の図</span>ではページネーションコントローラー（一定範囲のレコードだけを表示する仕組み）にユーザー名が見えていますが、長い数字がGoogleが識別のために利用している数値で、@以降が認証プロバイダーを示すドメイン名です。これがユーザー名です。</p>

<div class="picture"><div class="caption">Googleのアカウントで認証したページ</div>
<img class="picture-small" src="figs/shot3169.png" /></div>

<p>ここでauthuserテーブルを参照します。サンプルデータベースを利用しているのなら、サンプルの一覧ページでは左側の列に「Account Manager」と記述された部分のリンクより参照できます。<span class="nextpicture">次の図</span>ではリストの最後に見えるユーザーが、Googleアカウントで認証したことで作られたアカウントです。ここには表示していませんが、realnameフィールドには筆者の名前が入っているはずです。また、どのグループにも所属していません。パスワードのハッシュ値は自動生成され、認証の確認があるごとにパスワードは更新します。</p>

<div class="picture"><div class="caption">authuserに追加されたレコードを確認する</div>
<img class="picture-small" src="figs/shot3168.png" /></div>

<p>実際にアプリケーションを作る場合には、OAuthCatcher.phpをニーズに合わせて改変します。まず最初に、冒頭の方には$pathToIM変数で、INTER-Mediator.phpファイルがあるディレクトリへのパスを記述しています。そして、認証に関わる処理をOAuthAuthクラスで実施しています。通常は「OAuth認証」ページにリダイレクトされますが、setDoRedirectメソッドを使えば、リダイレクトしません。認証を受け付けてから、後で手作業等でグループに所属させたいような場合には、リダイレクトをしないようにして、OAuthCatcher.phpに必要な案内等を記述します。OAuthAuthクラスで利用できるメソッドとプロパティは、<span class="nexttable">次の表</span>の通りです。オブジェクトを生成したときに、サーバーのURL等がセットアップされ、isActiveでその状態を確認します。そして、afterAuthメソッドで認証処理を行うのが基本的な利用方法です。OAuthCatcher.phpには基本的な流れが作られているので、例えばメール送信を追加するなどの改変が必要になるかもしれません。認証したユーザーの情報は、getUserInfoメソッドで得られた連想配列から取得できます。</p>

<div class="table">
<div class="caption"><span class="index"><span class="indexword" yomi="OAuthAuthクラス">OAuthAuthクラス</span></span>OAuthAuthクラスのプロパティとメソッド</div>
<table>
<tr><th>種別</th><th>記述</th><th>動作</th></tr>
<tr><td>プロパティ</td><td><span class="index"><span class="indexword" yomi="isActive">isActive</span></span>isActive</td><td>プロバイダの設定がなされていればtrue</td></tr>
<tr><td>プロパティ</td><td><span class="index"><span class="indexword" yomi="debugMode">debugMode</span></span>debugMode</td><td>trueならデバッグモード（リダイレクトはしない）</td></tr>
<tr><td>メソッド</td><td><span class="index"><span class="indexword" yomi="setDoRedirect">setDoRedirect</span></span>setDoRedirect(value)</td><td>引数をfalseにするとリダイレクトしない（既定値はリダイレクトを実施）</td></tr>
<tr><td>メソッド</td><td><span class="index"><span class="indexword" yomi="afterAuth">afterAuth</span></span>afterAuth()</td><td>認証の処理を行い、成功すればtrueを返す</td></tr>
<tr><td>メソッド</td><td><span class="index"><span class="indexword" yomi="javaScriptCode">javaScriptCode</span></span>javaScriptCode()</td><td>認証が成功したときのクライアント側の処理プログラムを出力</td></tr>
<tr><td>メソッド</td><td><span class="index"><span class="indexword" yomi="errorMessage">errorMessage</span></span>errorMessage()</td><td>エラーメッセージをカンマで区切った文字列</td></tr>
<tr><td>メソッド</td><td><span class="index"><span class="indexword" yomi="getUserInfo">getUserInfo</span></span>getUserInfo()</td><td>afterAuthが成功した後に得られるアカウント情報の配列。キーはそれぞれ、username、realname、emailが指定されている</td></tr>
<tr><td>メソッド</td><td><span class="index"><span class="indexword" yomi="isCreate">isCreate</span></span>isCreate()</td><td>afterAuthが成功した後新たにユーザーレコードを作ったらtrue、既存のレコードを更新したらfalse</td></tr>
</table>
</div>
-->

<!-- ============ SECTION START ============ -->
<h2><span id="H2-ANC-8"><span style="display:none">→</span></span><span class="sectionnumber">7-8</span>(TBD)操作を記録する機能とカスタマイズ</h2>
<p>　(TBD)</p>

<h3><span id="H3-ANC-56"><span style="display:none">→</span></span>&gt;(TBD)操作ログを利用する</h3>
<p>　(TBD)</p>

<h3><span id="H3-ANC-57"><span style="display:none">→</span></span>&gt;(TBD)ロギングの結果をカスタマイズする</h3>
<p>　(TBD)</p>


</div></body></html>
