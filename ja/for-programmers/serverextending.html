<!DOCTYPE html>
<!--
/*
 * INTER-Mediator Ver.@@@@2@@@@ Released @@@@1@@@@
 *
 *   Copyright (c) 2010-2016 INTER-Mediator Directive Committee, All rights reserved.
 *
 *   This project started at the end of 2009 by Masayuki Nii  msyk@msyk.net.
 *   INTER-Mediator is supplied under MIT License.
 */
-->
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title></title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="../../lib/css/normalize.min.css" rel="stylesheet" media="screen">
    <link href="../../lib/css/style.min.css" rel="stylesheet" media="screen">
    <link href="../../lib/css/nav.min.css" rel="stylesheet" media="screen">
    <link rel="stylesheet" href="../../lib/css/styles/tomorrow-night.css">
    <link rel="apple-touch-icon" sizes="57x57" href="/images/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/images/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/images/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <script src="../../lib/js/pagebuilder-r2.js"></script>
    <script src="../../lib/pagebuilder-r2.php"></script>
    <script src="../../lib/highlight.pack.js"></script>
    <script>
    hljs.initHighlightingOnLoad()
    </script>
    <style>
    .object {
        color: white;
        background-color: #444444;
        padding: 2px;
    }
    h2 {
        font-size: 1.3em;
    }
    </style>
</head>

<body class="docs" data-page-title="for-programmers">
    <div class="container clearfix">
        <div class="page-title">
            <h1 id="pageTitle"></h1>
        </div>
        <ol id="breadcrumb" class="breadcrumb clearfix">
        </ol>
        <div class="docs-sidebar sticky clearfix">
            <nav>
                <ul id="pageIndex">
                </ul>
            </nav>
        </div>
        <article>
            <section>
                <h1>データコンバータクラスの利用方法</h1>
                <p>IM_Entry関数の第2引数で、'formatter'を利用して、特定のコンテキストのフィールドに対して、データベースの読み書き前後にフィルタを設定することができます。このときに使うクラスをデータコンバータクラスと呼びます。使用する箇所では、ネームスペースを除いたクラス名だけを記述します。自分で作成もできますが、以下のものが最初から組み込まれています。自分で作成する場合はDataConverter_template.phpを参照してください</p>
                <div class="table">
                    <table>
                        <tr>
                            <td>\INTERMediator\Data_Converter\AppendPrefix.php</td>
                            <td>parameterに指定した文字列を前につける</td>
                        </tr>
                        <tr>
                            <td>\INTERMediator\Data_Converter\AppendSuffix.php</td>
                            <td>parameterに指定した文字列を後につける</td>
                        </tr>
                        <tr>
                            <td>\INTERMediator\Data_Converter\Currency.php</td>
                            <td>parameterに指定した小数以下の桁数で、数値を通貨で表示する</td>
                        </tr>
                        <tr>
                            <td>\INTERMediator\Data_Converter\FMDateTime.php</td>
                            <td>FileMaker Serverの出力する「月/日/年」形式の日付や時刻を整える</td>
                        </tr>
                        <tr>
                            <td>\INTERMediator\Data_Converter\HTMLString.php</td>
                            <td>改行をBRタグ要素、そして&lt;や&gt;や&amp;を参照形式に変換する。parameterにautolinkと指定するとURLにAタグ要素を付加してリンクに変換する。バージョン4.2以降においてparameterにnoescapeと指定すると参照形式への変換を無効にする。データベースへの書き込み時はそのままの文字列</td>
                        </tr>
                        <tr>
                            <td>\INTERMediator\Data_Converter\MarkdownString</td>
                            <td>マークダウン表記のテキストをHTMLに整形する。コンバーターを通したフィールドは、innerHTMLで受ける必要がある。現在サポートしているマークダウン表記は以下のとおり。
                                <div class="table">
                                    <table>
                                        <tr>
                                            <th>行頭の記号</th>
                                            <th>動作</th>
                                        </tr>
                                        <tr>
                                            <td>*</td>
                                            <td>その行をHnタグで囲む。nは*の個数に対応する</td>
                                        </tr>
                                        <tr>
                                            <td>-</td>
                                            <td>その行を箇条書きにする。-を重ねて階層的に記述することも可能</td>
                                        </tr>
                                        <tr>
                                            <td>#</td>
                                            <td>クラスが「_im_markdown_p1」のPタグで囲む。#は2つおよび3つにも対応し、クラス名の末尾の数字と#の個数が対応する</td>
                                        </tr>
                                        <tr>
                                            <td>@@IMG[file]</td>
                                            <td>href属性がfileのIMGタグを生成すし、さらにクラスが「_im_markdown_para_img」のPタグで囲む</td>
                                        </tr>
                                        <tr>
                                            <td>|</td>
                                            <td>TABLEタグで表を作る。セルの区切りと末尾に|を入れる</td>
                                        </tr>
                                    </table>
                                </div>
                            </td>
                        </tr>
                        <tr>
                            <td>\INTERMediator\Data_Converter\MySQLDateTime.php</td>
                            <td>MySQLの出力する「年-月-日」形式の日付や時刻を整える</td>
                        </tr>
                        <tr>
                            <td>\INTERMediator\Data_Converter\Number.php</td>
                            <td>parameterに指定した小数以下の桁数で、数値をカンマ付きで表示する</td>
                        </tr>
                        <tr>
                            <td>\INTERMediator\Data_Converter\NumberBase.php</td>
                            <td>NumberやCurrencyの基底クラス</td>
                        </tr>
                        <tr>
                            <td>\INTERMediator\Data_Converter\NullZeroString.php</td>
                            <td>書き込み時にデータが''ならNULLとする、読み込み時は逆変換</td>
                        </tr>
                        <tr>
                            <td>\INTERMediator\Data_Converter\DataConverter_template.php</td>
                            <td>データコンバータのクラスのテンプレート</td>
                        </tr>
                    </table>
                </div>
            </section>
            <section>
                <h1>データベースアクセス処理のアドバイザクラスを定義する</h1>
                <p>データベース側の処理に割り込むには「データベースクラスを自作する」で説明する手法（「データアクセスクラスのサブクラスを利用する方法」と定義します）とここで説明する手法（「アドバイザクラスを定義する方法」とします）の2通りがあります。「データアクセスクラスのサブクラスを利用する方法」だと、すべてのコンテキストに対する処理を記述しなければなりません。言い換えれば、複数あるコンテキストの１つだけに対して処理を加えたい場合、そのコンテキストのときだけプログラムが実行されるようにする必要があります。コンテキストが増減したときのメンテナンスタスクが増えます。「アドバイザクラスを定義する方法」だと、特定のコンテキストにだけ利用されるクラスを指定するので、「コンテキストごとに分岐させる」処理は不要です。必要な処理だけを記述する「アドバイザクラスを定義する方法」を使う方がプログラムの作成は容易でしょう。</p>
                <p>IM_Entry関数の第一引数、つまりコンテキストの中に「extending-class」でクラス名を指定します。ここで指定したクラス名は任意のものでかまいませんが、そのクラスをPHPが認識できる場所に記述しておく必要があります。クラスは以下のようなインタフェースをインプリメントする必要があります。つまり、CRUDに対応する4種類のデータアクセス処理の前後にメソッドを含めることができるのです。</p>
                <div class="code"><pre><code>interface \INTERMediator\DB\Extending\BeforeRead {
    public function doBeforeReadFromDB();
}
interface \INTERMediator\DB\Extending\AfterRead {
    public function doAfterReadFromDB($result);
}
interface \INTERMediator\DB\Extending\AfterRead_WithNavigation {
    public function doAfterReadFromDB( $result);
    public function countQueryResult();
    public function getTotalCount();
}
interface \INTERMediator\DB\Extending\BeforeUpdate {
    public function doBeforeUpdateDB();
}
interface \INTERMediator\DB\Extending\AfterUpdate {
    public function doAfterUpdateToDB($result);
}
interface \INTERMediator\DB\Extending\BeforeCreate {
    public function doBeforeCreateToDB();
}
interface \INTERMediator\DB\Extending\AfterCreate{
    public function doAfterCreateToDB($result);
}
interface \INTERMediator\DB\Extending\BeforeDelete {
    public function doBeforeDeleteFromDB();
}
interface \INTERMediator\DB\Extending\AfterDelete {
    public function doAfterDeleteFromDB($result);
}
interface \INTERMediator\DB\Extending\BeforeCopy {
    public function doBeforeCopyInDB();
}
interface \INTERMediator\DB\Extending\AfterCopy{
    public function doAfterCopyInDB($result);
}</code>
</pre>
                </div>
                <h2>メソッドの引数</h2>
                <p>Deleteを除くdoAfter____メソッドの$result引数は、対象レコードが連想配列の配列の形式で入っています。1レコードがフィールド名をキーとした連想配列になっており、レコードの数だけその配列があります。doAfterGetFromDBでは複数のレコードが得られますが、doAfterSetToDBやdoAfterNewToDBでは1レコードだけが返されます。doAfterDeleteメソッドでは、削除できたかどうかの論理値が設定されます。</p>
                <h2>doAfter____メソッドの返り値</h2>
                <p>doAfter____メソッドがあれば、その返り値を、データベースのクエリー結果やあるいは更新処理などをした結果のレコードとしてクライアントに返します。シンプルな方法としては、引数をそのまま返すようにプログラムを作成しますが、ここで、データベースからの取得結果を加工して返しても構いません。たとえば、doAfterGetFromDBメソッドで集計処理などを行い、同様に連想配列の配列にして結果を返します。また、新たなフィールドを追加するなども行えます。もちろん、連想配列のキーがフィールドになります。</p>
                <h2>doBefore____メソッドの返り値</h2>
                Ver.8の途中より、doBefore____メソッドの返り値を利用できるようにしました。それ以前は、値を返しても何も使われていませんでした。通常は、doBefore___を実行し、クライアントから要求されたデータベース処理を行い、doAfter____を実行しますが、引数によってはdoBeforeで処理を終了させることができます。</p>
                <div class="table">
                    <div class="caption">doBefore____メソッドの返り値</div>
                    <table>
                        <tr>
                            <th>値</th>
                            <th>動作</th>
                        </tr>
                        <tr>
                            <td>false</td>
                            <td>データベース処理を中断して、英語のエラーメッセージを表示する</td>
                        </tr>
                        <tr>
                            <td>文字列</td>
                            <td>データベース処理を中断して、文字列をエラーメッセージとして表示する</td>
                        </tr>
                        <tr>
                            <td>""</td>
                            <td>データベース処理を中断する。メッセージなどは何も発しない</td>
                        </tr>
                        <tr>
                            <td>その他（返り値なしの場合も含む）</td>
                            <td>データベース処理を続ける</td>
                        </tr>
                    </table>
                </div>
                <h2>メソッドの作成例</h2>
                <p>以下は、データベースからレコードを取得した後に呼び出されるクラスの定義例です。MyProgramというクラス名は任意ですが、2つのメソッドはインタフェースに決められたものを定義します。doAfterGetFromDBはデータベースからデータを取得した後に呼び出されます。このとき、ナビゲーションを使ってページ送りの処理をしているのなら、「レコードの個数」をcountQueryResultメソッドで、「全レコード数」をgetTotalCountメソッドで返す必要があります。ナビゲーションがない場合にはこのメソッドの実装は不要です。また、ナビゲーションを使う場合でも、レコード総数がdoAfterGetFromDBの処理の後でも変わらないのであれば、countQueryResultメソッドは不要です。</p>
                <div class="code"><pre><code>class MyProgram extends \INTERMediator\DB\UseSharedObjects implements \INTERMediator\DB\Extending\AfterRead {
    function doAfterReadFromDB($result) {
        foreach( $result as $record ) {
            foreach( $record as $field =&gt; $value ) {
                :
            }
        }
        return $result;
    }
}</code>
</pre>
                </div>
                <p>countQueryResultメソッドを記述する場合の例を以下に示します。countQueryResultはdoAfterGetFromDBよりも後に呼び出されます。countQueryResultによって返されるのは、実際のレコード数ではなく、検索条件に合ったレコード数です。つまり、1万個のレコードのうち40個を表示している場合には、1万という数値を返す必要があります。doAfterGetFromDBで集計処理などをすると、1万レコードを取得して、それが20個などになると思います。その場合は20個を返さないといけません。この場合、自分でメンバ変数（dataCount）を定義して、そこに値を残しておくのが分かりやすい方法でしょう。</p>
                <div class="code"><pre><code>class MyProgram implements \INTERMediator\DB\Extending\WithNavigation {
    var $dataCount;
    
    function doAfterReadFromDB($result) {
            :
        $this-&gt;dataCount = count( $result );
        $return result;
    }
    
    function countQueryResult() {
        return $this-&gt;dataCount;
    }
}</code>
</pre>
                </div>
                <h2>アドバイザクラス内でさまざまな情報にアクセスする</h2>
                <p>アドバイザクラスで「\INTERMediator\DB\UseSharedObjects」クラスの子クラスにした場合は、他のオブジェクトへの参照が得られます。メソッドが呼び出された段階で、メンバ変数はオブジェクトを参照した状態になります。</p>
                <div class="table">
                    <div class="caption">\INTERMediator\DB\UseSharedObjectsを継承したときに利用できるメンバ変数</div>
                    <table>
                        <tr>
                            <th>メンバ変数</th>
                            <th>参照するもの</th>
                        </tr>
                        <tr>
                            <td>$this-&gt;dbClass</td>
                            <td>データベースクラスのインスタンス</td>
                        </tr>
                        <tr>
                            <td>$this-&gt;authDbClass</td>
                            <td>認証情報に使用するデータベースクラスのインスタンス</td>
                        </tr>
                        <tr>
                            <td>$this-&gt;dbSettings</td>
                            <td>\INTERMediator\DB\Settingsクラスのインスタンス</td>
                        </tr>
                        <tr>
                            <td>$this-&gt;logger</td>
                            <td>DB_Loggerクラスのインスタンス</td>
                        </tr>
                        <tr>
                            <td>$this-&gt;authCommon</td>
                            <td>DB_AuthCommonクラスのインスタンス</td>
                        </tr>
                        <tr>
                            <td>$this-&gt;formatter</td>
                            <td>DB_Formattersクラスのインスタンス</td>
                        </tr>
                    </table>
                </div>
                <h3>アドバイザクラスのメソッドでのデータベース処理</h3>
                <p>メソッド内で新たなデータベース処理を記述したい場合は、DB\Proxyクラスを新たに生成してメソッドを利用すれば可能です。どんなメソッドがあるかは以下の「サーバーサイドのプログラムで利用できるAPI」で説明しています。しかしながら、若干冗長だったので、Ver.8の途中でより簡単にデータベース処理が記述できるようなトレイトProxy_ExtSupportを定義しました。例えば、アドバイザクラスを次のように定義します。ポイントは、class内で「use Proxy_ExtSupport;」と記述するところです。これによりいくつかのメソッドが使えるようになります。</p>

                <div class="code"><pre><code>use \INTERMediator\DB\UseSharedObjects;
use \INTERMediator\DB\Extending\AfterRead;
use \INTERMediator\DB\Proxy_ExtSupport;

class Advisor extends UseSharedObjects implements AfterRead
{
  use Proxy_ExtSupport;

  public function doAfterReadFromDB($result)
  {
    $this->setFixedKey("id");
    $result = $this->dbRead("authuser",["username" => "admin"]);
    return $result;
  }
} </code></pre></div>
<p>Proxy_ExtSupportトレイトを利用したクラスでは、以下のメソッドが利用できます。いずれも、そのクラスにメソッドが追加されるので、this-&gt;で呼び出すことができます。</p>

                <h4>this-&gt;dbInit($datasource = null, $options = null, $dbspec = null, $debug = null)</h4>
                <p class="exp">Proxyクラスのインスタンスの初期化を行う方法。4つの引数は、定義ファイルのIM_Entry関数の引数と同様。引数は省略もでき、さらにこのメソッドの呼出自体も省略可能。</p>

               <h4>this-&gt;setFixedKey($key = null)</h4>
                <p class="exp">キーフィールドは、既定の状態では、「テーブル名_id」というネーミングルールに従うが、直後のデータベース処理で、キーフィールドを決め打ちしたい場合に引数に指定してこのメソッドを呼び出す。なお、コンテキスト定義を行なって引数に指定する場合は、keyキーを使って主キーを指定するので、このAPIを必ずしも使う必要はない。</p>

                <h4>this-&gt;getExtProxy()</h4>
                <p class="exp">内部で使っているProxyクラスへの参照。トランザクションをスタートしたりロールバックしたりするときに、この返り値にbeginTransaction()やcommitTransaction(), rollbackTransaction()を適用することができる。</p>

              <h4>this-&gt;dbRead($target, $query = null, $sort = null, $spec = null)</h4>
               <h4>this-&gt;dbUpdate($target, $query = null, $data = null, $spec = null)</h4>
               <h4>this-&gt;dbCreate($target, $data = null, $spec = null)</h4>
                 <h4>this-&gt;dbDelete($target, $query = null, $spec = null)</h4>
               <p class="exp">それぞれ名称通りのデータベース処理を行う。$specにはdbInitメソッドの$datasource引数に指定するコンテンツ定義の配列を指定できる。コンテンツ定義のどのコンテンツを利用するかは、$targetで指定する。$query引数は検索条件、$sort引数は並べ替えの条件、$dataは変更や追加するフィールドと値を示す。</p>
                <div class="table">
                    <div class="caption">コンテキストの指定のパターン</div>
                    <table>
                        <tr>
                            <th>パターン</th>
                            <th>説明</th>
                        </tr>
                        <tr>
                            <td style="white-space: nowrap">dbInit: なし<br>$spec: なし</td>
                            <td>$targetが文字列「product」なら、productテーブルに対して、キーフィールドproduct_idであることを前提にデータベース処理を行う。</td>
                        </tr>
                        <tr>
                            <td style="white-space: nowrap">dbInit: $datasourceを指定<br>$specなし</td>
                            <td>$targetには、$datasourceに存在するコンテキスト定義の名前（nameキーの値）を指定して、そのコンテキスト定義に応じたデータベース処理を行う。コンテキスト定義は複数あっても構わないので、1つのdbInitで複数のデータベース処理を行うことも可能。</td>
                        </tr>
                        <tr>
                            <td style="white-space: nowrap">dbInit: なし<br>$spec: 指定</td>
                            <td>$specには$datasourceと同じ形式の配列を指定する。そのメソッドを使うときにだけ、$specのコンテキスト定義が有効になる。もちろん、$targetは、$specに存在するコンテキスト定義の名前（nameキーの値）を指定する。$specがあれば、$dbInitの$datasourceの指定は無視する。</td>
                        </tr>
                    </table>
                </div>
                <div class="table">
                    <div class="caption">データベース処理の引数</div>
                    <table>
                        <tr>
                            <th>引数</th>
                            <th>説明</th>
                            <th>指定例</th>
                        </tr>
                        <tr>
                            <td>query</td>
                            <td>検索条件の指定</td>
                            <td><div class="code"><pre><code>[["field" => "id", "operator" => "=", "value" => $id],...]
// 基本的にはコンテキスト定義のqueryキーの定義と同じルール
["id" => $id,...] // フィールド名をキーにするとoperatorは=固定'</code></pre></div></td>
                        </tr>
                        <tr>
                            <td>sort</td>
                            <td>並べ替え条件の指定</td>
                            <td><div class="code"><pre><code>[["field" => "lastDT", "direction" => "desc"],...]
// 基本的にはコンテキスト定義のsoftキーの定義と同じルール
["lastDT" => "desc",...] // フィールド名をキーにもできる</code></pre></div></td>
                        </tr>
                        <tr>
                            <td>data</td>
                            <td>初期値、更新値</td>
                            <td><div class="code"><pre><code>[["field" => "lastDT", "value" => $nowDT],...]
// 基本的にはコンテキスト定義のdefault-valuesキーの定義と同じルール
["lastDT" => $nowDT,...] // フィールド名をキーにもできる</code></pre></div></td>
                        </tr>
                    </table>
                </div>
           </section>
            <section>
                <h1>データベースクラスを自作する</h1>
                <p>データベースクラスを独自に作成する場合には、以下のようなPHPのクラスが基本となります。もちろん、データベースクラスを1から作れるのですが、たぶん、そういうニーズはまずないと思います。データベースをPDOで使うならINTER-Mediatorの\INTERMediator\DB\PDO.php、FileMaer Serverを使うならDB_FileMaker_FX.phpを拡張したクラスを定義します。基底クラスの方のファイルも読み込みが必要です。以下の例は、INTER-Mediatorフォルダと同じフォルダに、このデータベースクラスのファイルがあるというわけです。自分が作るクラスでも、最初にDBをつけないといけません。IM_Entry関数の引数などでの設定は、この場合DB_をのぞいた「MyOriginalDB」を指定します。</p>
                <div class="code"><pre><code>class \INTERMediator\DB\MyOriginalDB extends \INTERMediator\DB\PDO.php {
    public function readFromDB() {
        /* ここにプログラムを追加できる */
        $result = super::readFromDB();
        /* ここにプログラムを追加できる */
        $this->mainTableCount = count( $result ); //レコード数
        return $result;
    }

    public function countQueryResult()  {
        return super::countQueryResult();
    }

    public function getTotalCount()  {
        return super::getTotalCount();
    }

    public function updateDB() {
        /* ここにプログラムを追加できる */
        $result = super::updateDB();
        /* ここにプログラムを追加できる */
        return $result;
    }
    
    public function createInDB($bypassAuth) {
        /* ここにプログラムを追加できる */
        $lastKeyValue = super::createInDB($bypassAuth);
        /* ここにプログラムを追加できる */
        return $lastKeyValue;
    }
    
    public function deleteFromDB() {
        /* ここにプログラムを追加できる */
         $result = super::deleteFromDB();
        /* ここにプログラムを追加できる */
        return $result;
    }
    public function copyInDB()  {
         $result = super::copyInDB();
        return $result;
    }
}</code></pre></div>
                <p>自分で作るクラスでは、要はCRUDに対応した4つのメソッドをオーバーライドすることによって、独自の仕組みを組み込むことができます。また、4つのうち、特にプログラムの追加がない場合には、定義する必要はありません。いずれの関数も、コンテキスト名を引数に取ります。そして、現在処理しているコンテキスト名が設定されてこれらのメソッドを呼び出します。</p>
                <p>readFromDBメソッドは、データベースからデータを取り出します。取り出し結果は連想配列の配列です。連想配列のキーがフィールド名になっています。そこから、特定のフィールドの値を元に集計をしたり、あるいは必要な値だけに取り除くなどの処理を、親クラスのreadFromDBメソッドを呼び出す後に入れればいいでしょう。リクエスト時と同じフィールド名を返す必要はなく（つまりINTER-Mediatorはそのチェックをしていない）、自由に連想配列の配列を作ります。そして、ページファイルの方で適切なフィールド名を指定すれば、集計結果が表示されます。なお、ページファイルで、一定レコード数ごとのページングをしているときには、mainTableCountメンバ変数にレコード数、つまり返す配列の要素数も指定します。何か問題が発生したのなら、array()を返します。以下のプログラムは売り上げのテーブルから集計を行う例です。</p>
                <div class="code"><pre><code>$result = super::readFromDB();
$summary = array();
foreach( $returnValue as $record ) {
    $summary[ $record[ 'itemNo' ]] += $record[ 'qty' ] * $record[ 'unitPrice' ];
    }
return array( $summary );</code>
</pre>
                </div>
                <p>updateDBとdeleteFromDBメソッドは、いずれも値の更新や削除のときに呼び出されるメソッドです。返り値は論理値で、処理が成功すればtrueで失敗ならfalseです。createInDBは新規レコードの作成です。メソッドの返り値は、新たに作ったレコードのキーフィールドの値である必要があります。問題があれば返り値をfalseにします。</p>
            </section>
            <section>
                <h1>サーバーサイドのプログラムで利用できるAPI</h1>
                <p>以下、<span class="object">\INTERMediator\DB\Proxy</span>は\INTERMediator\DB\Proxyクラスのオブジェクトへの参照を意味します。</p>
                <h4><span class="object">\INTERMediator\DB\Proxy</span>->initialize($datasource, $options, $dbspec, $debug, $target = null)</h4>
                <p class="exp">\INTERMediator\DB\Proxyクラスを初期化する。返り値はなし。生成した\INTERMediator\DB\Proxyクラスのオブジェクトに対して適用することで、さまざまな設定が反映されたオブジェクト群を形成する。</p>
                <div class="table">
                    <div class="caption">initializeメソッドの引数</div>
                    <table>
                        <tr>
                            <th>引数</th>
                            <th>指定する内容</th>
                        </tr>
                        <tr>
                            <td>$datasource</td>
                            <td>IM_Entry関数の第1引数と同様に、連想配列で表現されたコンテキストの配列。</td>
                        </tr>
                        <tr>
                            <td>$options</td>
                            <td>IM_Entry関数の第2引数と同様、さまざまな設定を含む連想配列。</td>
                        </tr>
                        <tr>
                            <td>$dbspec</td>
                            <td>IM_Entry関数の第3引数と同様、データベース接続に関する連想配列。</td>
                        </tr>
                        <tr>
                            <td>$debug</td>
                            <td>IM_Entry関数の第4引数と同様、falseならデバッグ出力なし、1ないしは2なら出力あり。</td>
                        </tr>
                        <tr>
                            <td>$target</td>
                            <td>コンテキストのnameキーの値のひとつを文字列で指定する。省略することも可能。</td>
                        </tr>
                    </table>
                </div>
                <h4><span class="object">\INTERMediator\DB\Proxy</span>->processingRequest($access, $bypassAuth)</h4>
                <p class="exp">初期化した\INTERMediator\DB\Proxyクラスのオブジェクトに対して処理を行う。返り値はない。引数$bypassAuthは、認証やアクセス権設定を無視するが、この指定は慎重に行う必要がある。既定値はfalse。引数$accessに、行うデータベース処理を示す文字列を指定する。nullを指定したときや省略したときにはPOST時のパラメーターの"access"キーの値を使用する。$accessに指定できる値と動作は次の通り：'create'（レコードの作成）、'read'（データベースへのクエリー）、'update'（レコードの更新）、'delete'（レコードの削除）、'copy'（レコードの複製）、'challenge'（チャレンジの生成＝原則として何もしない）、'changepassword'（パスワード変更）、'unregister'（Pusherによるクライアント同期の登録解除）、'describe'（スキーマ情報を得る）。他に'select' 'new'が過去の互換性のために利用可能となっている。それ以外の文字列の場合は、特に何もしない。</p>
                <h4><span class="object">\INTERMediator\DB\Proxy</span>->ignoringPost()</h4>
                <p class="exp">initializeメソッドではPOSTされたデータを取り込むが、その結果、処理拡張クラス内で新たに\INTERMediator\DB\Proxyクラスを生成してコンテキストを別途用意したとき、POSTデータの取り込みをしたくない場合も発生する。そのときにこのメソッドをinitializeメソッドよりも前に呼び出す。</p>
                <h4><span class="object">\INTERMediator\DB\Proxy</span>->getDatabaseResult()</h4>
                <p class="exp">データベースからの検索結果などで、1レコードが連想配列として表現され、その連想配列がレコード数分ある配列が返される。利用可能なprocessingRequestメソッドの最初の引数は、create（作成されたレコード）、read（検索結果）、update（更新後のレコード）、copy（複製後のレコード）、describe（スキーマ情報）。なお、レコード作成時にこの値が空の場合がまれにあるようです。PDOのlastInsertIdメソッドを使って新たに作成したレコードのキーフィールドの値を取得していますが、何らかの原因でそれが取得されず0が返され、作成したレコードの取得ができないのが原因です。解決策として、PHPのインストールをしなおしたら直ったなどが記載されていますが、決定的な方法はないようです。</p>
                <h4><span class="object">\INTERMediator\DB\Proxy</span>->getDatabaseResultCount()</h4>
                <p class="exp">processingRequestメソッドの最初の引数がreadの場合、検索結果に含まれるレコード数を返す。コンテキストのrecordsキーが上限値となるが、実際に検索されたレコード数はそれより少ない場合もある。</p>
                <h4><span class="object">\INTERMediator\DB\Proxy</span>->getDatabaseTotalCount()</h4>
                <p class="exp">processingRequestメソッドの最初の引数がreadの場合、検索条件に合致したレコード数を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Proxy</span>->getDatabaseNewRecordKey()</h4>
                <p class="exp">processingRequestメソッドの最初の引数がcreateあるいはcopyの場合、新たに作成されたレコードの主キーの値を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Proxy</span>->finishCommunication($notFinish)</h4>
                <p class="exp">出力するためのさまざまな準備を行う。</p>
                <h4><span class="object">\INTERMediator\DB\Proxy</span>->exportOutputDataAsJSON()</h4>
                <p class="exp">JSON形式のテキストで各種データを出力する。</p>
                <h4><span class="object">DB_Logger</span>->setDebugMessage($str, $level)</h4>
                <p class="exp">引数$strに指定した文字列を、引数$levelに指定したレベルでのデバッグメッセージとして記録する。レベルは1ないしは2のみをサポートし、引数$levelを省略すると1になる。</p>
                <h4><span class="object">DB_Logger</span>->setErrorMessage($str)</h4>
                <p class="exp">引数$strに指定した文字列を、エラーメッセージとして記録する。</p>
                <h4><span class="object">DB_Logger</span>->setWarningMessage($str)</h4>
                <p class="exp">引数$strに指定した文字列を、警告メッセージとして記録する。</p>
                <h4><span class="object">DB_Logger</span>->getDebugMessages()</h4>
                <p class="exp">記録されたデバッグメッセージを要素として含む配列を返す。</p>
                <h4><span class="object">DB_Logger</span>->getErrorMessages()</h4>
                <p class="exp">記録されたエラーメッセージを要素として含む配列を返す。</p>
                <h4><span class="object">DB_Logger</span>->getWarningMessages()</h4>
                <p class="exp">記録された警告メッセージを要素として含む配列を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setDataSourceName($dataSourceName)</h4>
                <p class="exp">引数に指定した文字列をnameキーの値として持つコンテキストを選択する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getDataSourceName()</h4>
                <p class="exp">現在、選択されているコンテキストのnameキーに対する値。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getDataSourceTargetArray()</h4>
                <p class="exp">現在、選択されているコンテキストの定義内容を連想配列で返す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getDataSourceDefinition($dataSourceName)</h4>
                <p class="exp">引数に指定した文字列をnameキーの値として持つコンテキスト定義の連想配列を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getEntityForRetrieve()</h4>
                <p class="exp">クエリー処理に利用するエンティティ名を返す。つまり、viewキーの値が指定されていればその値、指定されていない場合にはnameキーの値が返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getEntityForUpdate()</h4>
                <p class="exp">更新処理に利用するエンティティ名を返す。つまり、tableキーの値が指定されていればその値、指定されていない場合にはnameキーの値が返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setStart($st)</h4>
                <p class="exp">検索結果の最初のいくつ目から結果として取り出すかを、引数の数値で指定する。クライアントのINTERMediator.startFromの値が自動的に設定される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getStart()</h4>
                <p class="exp">検索結果の最初のいくつ目から結果として取り出すかが得られる。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setRecordCount($sk)</h4>
                <p class="exp">検索結果の中から、最大でいくつのレコードを取り出すかを引数の数値で指定する。コンテキストのrecordsキーの値や、クライアントINTERMediator.pageSizeの値など、すでに決まっている値が指定される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getRecordCount()</h4>
                <p class="exp">検索結果の中から、最大でいくつのレコードを取り出すかが得られる。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getAggregationSelect()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->setAggregationSelect($value)</h4>
                <p class="exp">選択されているコンテキストに指定したaggregation-selectキーの設定と取得</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getAggregationFrom()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->setAggregationFrom($value)</h4>
                <p class="exp">選択されているコンテキストに指定したaggregation-fromキーの設定と取得</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getAggregationGroupBy()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->setAggregationGroupBy($value)</h4>
                <p class="exp">選択されているコンテキストに指定したaggregation-group-byキーの設定と取得</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setDataSource($src)</h4>
                <p class="exp">引数には定義ファイルのIM_Entry関数の第1引数の値を指定して、コンテキスト定義の配列をオブジェクトに記録する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getDataSource()</h4>
                <p class="exp">定義ファイルのIM_Entry関数の第1引数の値が返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setOptions($src)</h4>
                <p class="exp">引数には定義ファイルのIM_Entry関数の第2引数の値を指定して、オプション指定の配列をオブジェクトに記録する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getOptions()</h4>
                <p class="exp">定義ファイルのIM_Entry関数の第2引数の値が返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setDbSpec($src)</h4>
                <p class="exp">引数には定義ファイルのIM_Entry関数の第3引数の値を指定して、データベース設定の配列をオブジェクトに記録する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getDbSpec()</h4>
                <p class="exp">定義ファイルのIM_Entry関数の第3引数の値が返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setFieldsRequired($fieldsRequired)</h4>
                <p class="exp">フィールドの配列として、引数の配列を設定する。このメソッドは、配列そのものを設定するが、addValueWithField、addTargetFieldメソッドにより、フィールド一覧を管理する配列へ要素が追加される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getFieldsRequired()</h4>
                <p class="exp">フィールドの配列を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->addTargetField($field)</h4>
                <p class="exp">フィールドの配列の要素として、引数に指定した文字列を追加する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getFieldOfIndex($ix)</h4>
                <p class="exp">フィールドの配列から、引数に指定した番号の要素を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setValue($values)</h4>
                <p class="exp">値の配列として、引数の配列を設定する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getValue()</h4>
                <p class="exp">値の配列を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->addValue($value)</h4>
                <p class="exp">値の配列の要素として、引数に指定した文字列を追加する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->addValueWithField($field, $value)</h4>
                <p class="exp">フィールドの配列および値の配列の要素として、引数に指定した文字列をそれぞれ追加する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getValuesWithFields()</h4>
                <p class="exp">フィールドの配列にある値をキー、そのキーに対する値を要素にした連想配列を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getValueOfField($targetField)</h4>
                <p class="exp">引数に指定したフィールド名をフィールドの配列の何番目なのかを判別し、値の配列の同じ番号の要素を返す。つまり、フィールド名に対応した値を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setForeignFieldAndValue($foreignFieldAndValue)</h4>
                <p class="exp">引数を外部キーの値を保持する配列に指定する。引数は、field、valueをキーとした連想配列の配列である必要がある。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getForeignFieldAndValue()</h4>
                <p class="exp">外部キーの値を保持する配列を返す。返される値は、field、valueをキーとした連想配列の配列。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->addForeignValue($field, $value)</h4>
                <p class="exp">引数に指定したフィールド名と値を、外部キーの値を保持する配列に追加する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getForeignKeysValue($targetField)</h4>
                <p class="exp">外部キーの値を保持する配列から、引数に指定したフィールドに対する値を返す。ない場合はnullが返る。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->addExtraCriteria($field, $operator, $value)</h4>
                <p class="exp">追加的な検索条件を保持する配列に、引数の3つの要素を持つ連想配列として追加する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getExtraCriteria()</h4>
                <p class="exp">追加的な検索条件を保持する配列を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->unsetExtraCriteria($index)</h4>
                <p class="exp">追加的な検索条件を保持する配列の中にある引数に指定したインデックスの要素を削除する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getCriteriaValue($targetField)</h4>
                <p class="exp">追加的な検索条件を保持する配列から、引数に指定した文字列をfieldキーの値として持つ最初の要素を特定し、その要素のvalueキーの値を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getCriteriaOperator($targetField)</h4>
                <p class="exp">追加的な検索条件を保持する配列から、引数に指定した文字列をfieldキーの値として持つ最初の要素を特定し、その要素のoperatorキーの値を返す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setGlobalInContext($contextName, $operation, $field, $value)</h4>
                <p class="exp">引数に指定したコンテキストに、残りの引数で指定した設定内容を持つglobalキーの連想配列を追加する。もちろん、FileMaker Serverのみで意味のある機能である。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setPrimaryKeyOnly($primaryKeyOnly)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getPrimaryKeyOnly()</h4>
                <p class="exp">検索条件の中から、主キー（コンテキストのkeyキー）で指定されたものだけを利用する設定とその状態の取得。なお、主キーのみを利用する検索は、データベースの更新前に楽観的ロックの仕組みを利用して、現在の値を取り出す場合に利用している。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->addExtraSortKey($field, $direction)</h4>
                <p class="exp">追加のソート条件を記録した配列に、引数にしていたフィールドと基準（昇順ないしは降順）を追加する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getExtraSortKey()</h4>
                <p class="exp">追加のソート条件を記録した配列を得る。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->addAssociated($name, $field, $value)</h4>
                <p class="exp">レコードのコピーにおいて、関連するコンテキストに対する設定を追加する。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getAssociated()</h4>
                <p class="exp">レコードのコピーにおいて使用される関連するコンテキストに対する配列を得る。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setDbSpecServer($str)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getDbSpecServer()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->setDbSpecPort($str)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getDbSpecPort()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->setDbSpecUser($str)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getDbSpecUser()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->setDbSpecPassword($str)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getDbSpecPassword()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->setDbSpecDataType($str)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getDbSpecDataType()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->setDbSpecDatabase($str)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getDbSpecDatabase()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->setDbSpecProtocol($str)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getDbSpecProtocol()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->setDbSpecDSN($str)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getDbSpecDSN()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->setDbSpecOption($str)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getDbSpecOption()</h4>
                <p class="exp">データベース処理に関する設定を行ったり取り出したりするメソッド。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setCurrentUser($str)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getCurrentUser()</h4>
                <p class="exp">クライアントから申告されたユーザー名の設定及び取得と行うメソッド。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setUserAndPasswordForAccess($user, $pass)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getAccessUser()<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getAccessPassword()</h4>
                <p class="exp">クライアントから申告されたユーザー名とパスワードの設定及び取得と行うメソッド。ネイティブ認証時にチャレンジに対応するレスポンスによって返されたユーザー名とパスワードが設定され、それ以外の時には設定されない。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setAuthentication($authentication)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getAuthentication()</h4>
                <p class="exp">IM_Entry関数の第2引数（オプション設定）の、authenticationキーに対する値を記録あるいは取り出す。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getAuthenticationItem($key)</h4>
                <p class="exp">IM_Entry関数の第2引数（オプション設定）のauthenticationキーに対する値に対し、さらに引数の文字列のキーの値を取り出す。もし、引数に与えたキーに対する値が定義されていない場合で、引数がテーブル名の場合には、規定のテーブル名を返す。あるいは認証継続時間の場合には既定値として8時間が返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getUserTable()</h4>
                <p class="exp">認証に使用するテーブル名を返す。定義ファイル等で未設定の場合には既定値のauthuserが返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getGroupTable()</h4>
                <p class="exp">グループ管理に使用するテーブル名を返す。定義ファイル等で未設定の場合には既定値のauthgroupが返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getCorrTable()</h4>
                <p class="exp">グループ所属記録に使用するテーブル名を返す。定義ファイル等で未設定の場合には既定値のauthcorrが返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getHashTable()</h4>
                <p class="exp">認証でのチャレンジ等を記録するためのテーブル名を返す。定義ファイル等で未設定の場合には既定値のissuedhashが返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getExpiringSeconds()</h4>
                <p class="exp">認証結果を保持する時間を返す。定義ファイル等で未設定の場合には既定値の8時間が返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setRequireAuthentication($requireAuthentication)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getRequireAuthentication()</h4>
                <p class="exp">ゲッターは、定義ファイルの内容から、認証が必要かどうかを求めた結果を返す。セッターはprocessingRequestメソッド内で判定結果を記録するために利用される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setRequireAuthorization($requireAuthorization)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getRequireAuthorization()</h4>
                <p class="exp">ゲッターは、定義ファイルの内容から、アクセス権の判定が必要かどうかを求めた結果を返す。セッターはprocessingRequestメソッド内で判定結果を記録するために利用される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setDBNative($isDBNative)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->isDBNative()</h4>
                <p class="exp">ゲッターは、定義ファイルの内容から、ネイティブ認証を行うかどうかを求めた結果を返す。セッターはprocessingRequestメソッド内で判定結果を記録するために利用される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setEmailAsAccount($emailAsAccount)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getEmailAsAccount()</h4>
                <p class="exp">ゲッターは、定義ファイルの内容から、電子メールを認証時のユーザー名として使用できるかどうかを返す。セッターはprocessingRequestメソッド内で設定を記録するために利用される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->getLDAPSettings()</h4>
                <p class="exp">params.phpファイルで定義されたLDAPの設定値を持つ配列を返す。要素は順番に、サーバー名、ポート番号、検索ベース、コンテナ名、ユーザー名のキー名。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setLDAPExpiringSeconds($sec)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getLDAPExpiringSeconds()</h4>
                <p class="exp">ゲッターは、params.phpファイルの内容から得られたLDAP認証の継続時間を返す。セッターは設定を記録するために利用される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setSeparator($sep)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getSeparator()</h4>
                <p class="exp">ターゲット指定の区切り文字（通常は「@」）を記録したり取得するメソッド。設定しない場合には、＠が返される。</p>
                <h4><span class="object">\INTERMediator\DB\Settings</span>->setSmtpConfiguration($config)<br/>
<span class="object">\INTERMediator\DB\Settings</span>->getSmtpConfiguration()</h4>
                <p class="exp">IM_Entry関数の第2引数（オプション設定）の、smtpキーに対する値を記録あるいは取り出す。</p>
            </section>
        </article>
    </div>
</body>

</html>